
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model JobProfile
 * 
 */
export type JobProfile = $Result.DefaultSelection<Prisma.$JobProfilePayload>
/**
 * Model Dealers
 * 
 */
export type Dealers = $Result.DefaultSelection<Prisma.$DealersPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Listing
 * 
 */
export type Listing = $Result.DefaultSelection<Prisma.$ListingPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Finance
 * 
 */
export type Finance = $Result.DefaultSelection<Prisma.$FinancePayload>
/**
 * Model Remainders
 * 
 */
export type Remainders = $Result.DefaultSelection<Prisma.$RemaindersPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model ScheduleMsg
 * 
 */
export type ScheduleMsg = $Result.DefaultSelection<Prisma.$ScheduleMsgPayload>
/**
 * Model SellerAccount
 * 
 */
export type SellerAccount = $Result.DefaultSelection<Prisma.$SellerAccountPayload>
/**
 * Model Products
 * 
 */
export type Products = $Result.DefaultSelection<Prisma.$ProductsPayload>
/**
 * Model ProductQuery
 * 
 */
export type ProductQuery = $Result.DefaultSelection<Prisma.$ProductQueryPayload>
/**
 * Model WishList
 * 
 */
export type WishList = $Result.DefaultSelection<Prisma.$WishListPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OrderStatus: {
  Pending: 'Pending',
  Delivered: 'Delivered'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const Category: {
  Event_Management: 'Event_Management',
  Construction_Projects: 'Construction_Projects',
  Software_Development: 'Software_Development',
  Marketing_Campaigns: 'Marketing_Campaigns',
  Corporate_Projects: 'Corporate_Projects',
  Others: 'Others'
};

export type Category = (typeof Category)[keyof typeof Category]


export const Typetrans: {
  Debit: 'Debit',
  Credit: 'Credit'
};

export type Typetrans = (typeof Typetrans)[keyof typeof Typetrans]


export const Status: {
  Success: 'Success',
  Pending: 'Pending'
};

export type Status = (typeof Status)[keyof typeof Status]


export const NoteType: {
  Finance: 'Finance',
  Legal: 'Legal'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]


export const Msgtype: {
  Email: 'Email',
  Whatsapp: 'Whatsapp'
};

export type Msgtype = (typeof Msgtype)[keyof typeof Msgtype]


export const ScheduleMsgStatus: {
  Pending: 'Pending',
  Delivered: 'Delivered'
};

export type ScheduleMsgStatus = (typeof ScheduleMsgStatus)[keyof typeof ScheduleMsgStatus]


export const Categories: {
  Basic_Electricals: 'Basic_Electricals',
  Construction_Essentials: 'Construction_Essentials',
  Party_Essentials: 'Party_Essentials',
  Food_Essentials: 'Food_Essentials',
  Pharma_Essentials: 'Pharma_Essentials',
  Apparels_Clothing_and_Garments: 'Apparels_Clothing_and_Garments',
  Electrical_Goods_and_Supplies: 'Electrical_Goods_and_Supplies',
  Hospital_and_Medical_Equipment: 'Hospital_and_Medical_Equipment',
  Industrial_Plants_Machinery_and_Equipment: 'Industrial_Plants_Machinery_and_Equipment',
  Food_Event_Services: 'Food_Event_Services',
  Beauty_Wellness: 'Beauty_Wellness',
  Home_Services: 'Home_Services',
  Local_Services: 'Local_Services',
  Errands_Delivery: 'Errands_Delivery',
  Miscellaneous_Services: 'Miscellaneous_Services',
  Consultancy: 'Consultancy'
};

export type Categories = (typeof Categories)[keyof typeof Categories]


export const Mode: {
  Home_Delivery: 'Home_Delivery',
  Offline: 'Offline',
  Call: 'Call'
};

export type Mode = (typeof Mode)[keyof typeof Mode]


export const Type: {
  Product: 'Product',
  Service: 'Service'
};

export type Type = (typeof Type)[keyof typeof Type]

}

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type Typetrans = $Enums.Typetrans

export const Typetrans: typeof $Enums.Typetrans

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

export type Msgtype = $Enums.Msgtype

export const Msgtype: typeof $Enums.Msgtype

export type ScheduleMsgStatus = $Enums.ScheduleMsgStatus

export const ScheduleMsgStatus: typeof $Enums.ScheduleMsgStatus

export type Categories = $Enums.Categories

export const Categories: typeof $Enums.Categories

export type Mode = $Enums.Mode

export const Mode: typeof $Enums.Mode

export type Type = $Enums.Type

export const Type: typeof $Enums.Type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobProfile`: Exposes CRUD operations for the **JobProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobProfiles
    * const jobProfiles = await prisma.jobProfile.findMany()
    * ```
    */
  get jobProfile(): Prisma.JobProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dealers`: Exposes CRUD operations for the **Dealers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dealers
    * const dealers = await prisma.dealers.findMany()
    * ```
    */
  get dealers(): Prisma.DealersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listings
    * const listings = await prisma.listing.findMany()
    * ```
    */
  get listing(): Prisma.ListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finance`: Exposes CRUD operations for the **Finance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Finances
    * const finances = await prisma.finance.findMany()
    * ```
    */
  get finance(): Prisma.FinanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remainders`: Exposes CRUD operations for the **Remainders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Remainders
    * const remainders = await prisma.remainders.findMany()
    * ```
    */
  get remainders(): Prisma.RemaindersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleMsg`: Exposes CRUD operations for the **ScheduleMsg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleMsgs
    * const scheduleMsgs = await prisma.scheduleMsg.findMany()
    * ```
    */
  get scheduleMsg(): Prisma.ScheduleMsgDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerAccount`: Exposes CRUD operations for the **SellerAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerAccounts
    * const sellerAccounts = await prisma.sellerAccount.findMany()
    * ```
    */
  get sellerAccount(): Prisma.SellerAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **Products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.ProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productQuery`: Exposes CRUD operations for the **ProductQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductQueries
    * const productQueries = await prisma.productQuery.findMany()
    * ```
    */
  get productQuery(): Prisma.ProductQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishList`: Exposes CRUD operations for the **WishList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishLists
    * const wishLists = await prisma.wishList.findMany()
    * ```
    */
  get wishList(): Prisma.WishListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.1
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    JobProfile: 'JobProfile',
    Dealers: 'Dealers',
    Order: 'Order',
    Project: 'Project',
    Member: 'Member',
    Inventory: 'Inventory',
    Team: 'Team',
    Listing: 'Listing',
    Task: 'Task',
    Transaction: 'Transaction',
    Finance: 'Finance',
    Remainders: 'Remainders',
    Note: 'Note',
    ScheduleMsg: 'ScheduleMsg',
    SellerAccount: 'SellerAccount',
    Products: 'Products',
    ProductQuery: 'ProductQuery',
    WishList: 'WishList',
    Review: 'Review',
    Document: 'Document'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "jobProfile" | "dealers" | "order" | "project" | "member" | "inventory" | "team" | "listing" | "task" | "transaction" | "finance" | "remainders" | "note" | "scheduleMsg" | "sellerAccount" | "products" | "productQuery" | "wishList" | "review" | "document"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      JobProfile: {
        payload: Prisma.$JobProfilePayload<ExtArgs>
        fields: Prisma.JobProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          findFirst: {
            args: Prisma.JobProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          findMany: {
            args: Prisma.JobProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>[]
          }
          create: {
            args: Prisma.JobProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          createMany: {
            args: Prisma.JobProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>[]
          }
          delete: {
            args: Prisma.JobProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          update: {
            args: Prisma.JobProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          deleteMany: {
            args: Prisma.JobProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>[]
          }
          upsert: {
            args: Prisma.JobProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobProfilePayload>
          }
          aggregate: {
            args: Prisma.JobProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobProfile>
          }
          groupBy: {
            args: Prisma.JobProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobProfileCountArgs<ExtArgs>
            result: $Utils.Optional<JobProfileCountAggregateOutputType> | number
          }
        }
      }
      Dealers: {
        payload: Prisma.$DealersPayload<ExtArgs>
        fields: Prisma.DealersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          findFirst: {
            args: Prisma.DealersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          findMany: {
            args: Prisma.DealersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>[]
          }
          create: {
            args: Prisma.DealersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          createMany: {
            args: Prisma.DealersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>[]
          }
          delete: {
            args: Prisma.DealersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          update: {
            args: Prisma.DealersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          deleteMany: {
            args: Prisma.DealersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>[]
          }
          upsert: {
            args: Prisma.DealersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealersPayload>
          }
          aggregate: {
            args: Prisma.DealersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealers>
          }
          groupBy: {
            args: Prisma.DealersGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealersGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealersCountArgs<ExtArgs>
            result: $Utils.Optional<DealersCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Listing: {
        payload: Prisma.$ListingPayload<ExtArgs>
        fields: Prisma.ListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findFirst: {
            args: Prisma.ListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findMany: {
            args: Prisma.ListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          create: {
            args: Prisma.ListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          createMany: {
            args: Prisma.ListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          delete: {
            args: Prisma.ListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          update: {
            args: Prisma.ListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          deleteMany: {
            args: Prisma.ListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          upsert: {
            args: Prisma.ListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          aggregate: {
            args: Prisma.ListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing>
          }
          groupBy: {
            args: Prisma.ListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListingCountArgs<ExtArgs>
            result: $Utils.Optional<ListingCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Finance: {
        payload: Prisma.$FinancePayload<ExtArgs>
        fields: Prisma.FinanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          findFirst: {
            args: Prisma.FinanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          findMany: {
            args: Prisma.FinanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          create: {
            args: Prisma.FinanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          createMany: {
            args: Prisma.FinanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          delete: {
            args: Prisma.FinanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          update: {
            args: Prisma.FinanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          deleteMany: {
            args: Prisma.FinanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>[]
          }
          upsert: {
            args: Prisma.FinanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancePayload>
          }
          aggregate: {
            args: Prisma.FinanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinance>
          }
          groupBy: {
            args: Prisma.FinanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinanceCountArgs<ExtArgs>
            result: $Utils.Optional<FinanceCountAggregateOutputType> | number
          }
        }
      }
      Remainders: {
        payload: Prisma.$RemaindersPayload<ExtArgs>
        fields: Prisma.RemaindersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemaindersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemaindersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          findFirst: {
            args: Prisma.RemaindersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemaindersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          findMany: {
            args: Prisma.RemaindersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>[]
          }
          create: {
            args: Prisma.RemaindersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          createMany: {
            args: Prisma.RemaindersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemaindersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>[]
          }
          delete: {
            args: Prisma.RemaindersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          update: {
            args: Prisma.RemaindersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          deleteMany: {
            args: Prisma.RemaindersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemaindersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RemaindersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>[]
          }
          upsert: {
            args: Prisma.RemaindersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemaindersPayload>
          }
          aggregate: {
            args: Prisma.RemaindersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemainders>
          }
          groupBy: {
            args: Prisma.RemaindersGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemaindersGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemaindersCountArgs<ExtArgs>
            result: $Utils.Optional<RemaindersCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      ScheduleMsg: {
        payload: Prisma.$ScheduleMsgPayload<ExtArgs>
        fields: Prisma.ScheduleMsgFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleMsgFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleMsgFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          findFirst: {
            args: Prisma.ScheduleMsgFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleMsgFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          findMany: {
            args: Prisma.ScheduleMsgFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>[]
          }
          create: {
            args: Prisma.ScheduleMsgCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          createMany: {
            args: Prisma.ScheduleMsgCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleMsgCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>[]
          }
          delete: {
            args: Prisma.ScheduleMsgDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          update: {
            args: Prisma.ScheduleMsgUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleMsgDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleMsgUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleMsgUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleMsgUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleMsgPayload>
          }
          aggregate: {
            args: Prisma.ScheduleMsgAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleMsg>
          }
          groupBy: {
            args: Prisma.ScheduleMsgGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleMsgGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleMsgCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleMsgCountAggregateOutputType> | number
          }
        }
      }
      SellerAccount: {
        payload: Prisma.$SellerAccountPayload<ExtArgs>
        fields: Prisma.SellerAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          findFirst: {
            args: Prisma.SellerAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          findMany: {
            args: Prisma.SellerAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>[]
          }
          create: {
            args: Prisma.SellerAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          createMany: {
            args: Prisma.SellerAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellerAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>[]
          }
          delete: {
            args: Prisma.SellerAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          update: {
            args: Prisma.SellerAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          deleteMany: {
            args: Prisma.SellerAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SellerAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>[]
          }
          upsert: {
            args: Prisma.SellerAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerAccountPayload>
          }
          aggregate: {
            args: Prisma.SellerAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerAccount>
          }
          groupBy: {
            args: Prisma.SellerAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SellerAccountCountAggregateOutputType> | number
          }
        }
      }
      Products: {
        payload: Prisma.$ProductsPayload<ExtArgs>
        fields: Prisma.ProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findFirst: {
            args: Prisma.ProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          findMany: {
            args: Prisma.ProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          create: {
            args: Prisma.ProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          createMany: {
            args: Prisma.ProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          delete: {
            args: Prisma.ProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          update: {
            args: Prisma.ProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          deleteMany: {
            args: Prisma.ProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>[]
          }
          upsert: {
            args: Prisma.ProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.ProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      ProductQuery: {
        payload: Prisma.$ProductQueryPayload<ExtArgs>
        fields: Prisma.ProductQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          findFirst: {
            args: Prisma.ProductQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          findMany: {
            args: Prisma.ProductQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>[]
          }
          create: {
            args: Prisma.ProductQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          createMany: {
            args: Prisma.ProductQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>[]
          }
          delete: {
            args: Prisma.ProductQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          update: {
            args: Prisma.ProductQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          deleteMany: {
            args: Prisma.ProductQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductQueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>[]
          }
          upsert: {
            args: Prisma.ProductQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductQueryPayload>
          }
          aggregate: {
            args: Prisma.ProductQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductQuery>
          }
          groupBy: {
            args: Prisma.ProductQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductQueryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductQueryCountAggregateOutputType> | number
          }
        }
      }
      WishList: {
        payload: Prisma.$WishListPayload<ExtArgs>
        fields: Prisma.WishListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          findFirst: {
            args: Prisma.WishListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          findMany: {
            args: Prisma.WishListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>[]
          }
          create: {
            args: Prisma.WishListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          createMany: {
            args: Prisma.WishListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WishListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>[]
          }
          delete: {
            args: Prisma.WishListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          update: {
            args: Prisma.WishListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          deleteMany: {
            args: Prisma.WishListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WishListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>[]
          }
          upsert: {
            args: Prisma.WishListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishListPayload>
          }
          aggregate: {
            args: Prisma.WishListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishList>
          }
          groupBy: {
            args: Prisma.WishListGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishListGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishListCountArgs<ExtArgs>
            result: $Utils.Optional<WishListCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    jobProfile?: JobProfileOmit
    dealers?: DealersOmit
    order?: OrderOmit
    project?: ProjectOmit
    member?: MemberOmit
    inventory?: InventoryOmit
    team?: TeamOmit
    listing?: ListingOmit
    task?: TaskOmit
    transaction?: TransactionOmit
    finance?: FinanceOmit
    remainders?: RemaindersOmit
    note?: NoteOmit
    scheduleMsg?: ScheduleMsgOmit
    sellerAccount?: SellerAccountOmit
    products?: ProductsOmit
    productQuery?: ProductQueryOmit
    wishList?: WishListOmit
    review?: ReviewOmit
    document?: DocumentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    team: number
    Listing: number
    Dealer: number
    Review: number
    WishList: number
    Member: number
    ProductQuery: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    team?: boolean | UserCountOutputTypeCountTeamArgs
    Listing?: boolean | UserCountOutputTypeCountListingArgs
    Dealer?: boolean | UserCountOutputTypeCountDealerArgs
    Review?: boolean | UserCountOutputTypeCountReviewArgs
    WishList?: boolean | UserCountOutputTypeCountWishListArgs
    Member?: boolean | UserCountOutputTypeCountMemberArgs
    ProductQuery?: boolean | UserCountOutputTypeCountProductQueryArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDealerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQueryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    product: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | OrderCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    member: number
    Task: number
    documents: number
    ScheduledMsg: number
    Inventory: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | ProjectCountOutputTypeCountMemberArgs
    Task?: boolean | ProjectCountOutputTypeCountTaskArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    ScheduledMsg?: boolean | ProjectCountOutputTypeCountScheduledMsgArgs
    Inventory?: boolean | ProjectCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountScheduledMsgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleMsgWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type FinanceCountOutputType
   */

  export type FinanceCountOutputType = {
    transaction: number
    notes: number
    remainder: number
  }

  export type FinanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | FinanceCountOutputTypeCountTransactionArgs
    notes?: boolean | FinanceCountOutputTypeCountNotesArgs
    remainder?: boolean | FinanceCountOutputTypeCountRemainderArgs
  }

  // Custom InputTypes
  /**
   * FinanceCountOutputType without action
   */
  export type FinanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinanceCountOutputType
     */
    select?: FinanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinanceCountOutputType without action
   */
  export type FinanceCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * FinanceCountOutputType without action
   */
  export type FinanceCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * FinanceCountOutputType without action
   */
  export type FinanceCountOutputTypeCountRemainderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemaindersWhereInput
  }


  /**
   * Count Type SellerAccountCountOutputType
   */

  export type SellerAccountCountOutputType = {
    Product: number
    Order: number
  }

  export type SellerAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | SellerAccountCountOutputTypeCountProductArgs
    Order?: boolean | SellerAccountCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * SellerAccountCountOutputType without action
   */
  export type SellerAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccountCountOutputType
     */
    select?: SellerAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellerAccountCountOutputType without action
   */
  export type SellerAccountCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
  }

  /**
   * SellerAccountCountOutputType without action
   */
  export type SellerAccountCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    Review: number
    order: number
    WishList: number
    Queries: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Review?: boolean | ProductsCountOutputTypeCountReviewArgs
    order?: boolean | ProductsCountOutputTypeCountOrderArgs
    WishList?: boolean | ProductsCountOutputTypeCountWishListArgs
    Queries?: boolean | ProductsCountOutputTypeCountQueriesArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountWishListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishListWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQueryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    contact: number | null
  }

  export type UserSumAggregateOutputType = {
    contact: bigint | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    googlemail: string | null
    extra: string | null
    contact: bigint | null
    lastname: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    googlemail: string | null
    extra: string | null
    contact: bigint | null
    lastname: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    googlemail: number
    extra: number
    contact: number
    lastname: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    contact?: true
  }

  export type UserSumAggregateInputType = {
    contact?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    googlemail?: true
    extra?: true
    contact?: true
    lastname?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    googlemail?: true
    extra?: true
    contact?: true
    lastname?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    googlemail?: true
    extra?: true
    contact?: true
    lastname?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    googlemail: string | null
    extra: string | null
    contact: bigint | null
    lastname: string | null
    password: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    googlemail?: boolean
    extra?: boolean
    contact?: boolean
    lastname?: boolean
    password?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    Listing?: boolean | User$ListingArgs<ExtArgs>
    Selleraccount?: boolean | User$SelleraccountArgs<ExtArgs>
    Dealer?: boolean | User$DealerArgs<ExtArgs>
    JobProfle?: boolean | User$JobProfleArgs<ExtArgs>
    Review?: boolean | User$ReviewArgs<ExtArgs>
    WishList?: boolean | User$WishListArgs<ExtArgs>
    Member?: boolean | User$MemberArgs<ExtArgs>
    ProductQuery?: boolean | User$ProductQueryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    googlemail?: boolean
    extra?: boolean
    contact?: boolean
    lastname?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    googlemail?: boolean
    extra?: boolean
    contact?: boolean
    lastname?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    googlemail?: boolean
    extra?: boolean
    contact?: boolean
    lastname?: boolean
    password?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "googlemail" | "extra" | "contact" | "lastname" | "password", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    Listing?: boolean | User$ListingArgs<ExtArgs>
    Selleraccount?: boolean | User$SelleraccountArgs<ExtArgs>
    Dealer?: boolean | User$DealerArgs<ExtArgs>
    JobProfle?: boolean | User$JobProfleArgs<ExtArgs>
    Review?: boolean | User$ReviewArgs<ExtArgs>
    WishList?: boolean | User$WishListArgs<ExtArgs>
    Member?: boolean | User$MemberArgs<ExtArgs>
    ProductQuery?: boolean | User$ProductQueryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      team: Prisma.$TeamPayload<ExtArgs>[]
      Listing: Prisma.$ListingPayload<ExtArgs>[]
      Selleraccount: Prisma.$SellerAccountPayload<ExtArgs> | null
      Dealer: Prisma.$DealersPayload<ExtArgs>[]
      JobProfle: Prisma.$JobProfilePayload<ExtArgs> | null
      Review: Prisma.$ReviewPayload<ExtArgs>[]
      WishList: Prisma.$WishListPayload<ExtArgs>[]
      Member: Prisma.$MemberPayload<ExtArgs>[]
      ProductQuery: Prisma.$ProductQueryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      googlemail: string | null
      extra: string | null
      contact: bigint | null
      lastname: string | null
      password: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    team<T extends User$teamArgs<ExtArgs> = {}>(args?: Subset<T, User$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Listing<T extends User$ListingArgs<ExtArgs> = {}>(args?: Subset<T, User$ListingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Selleraccount<T extends User$SelleraccountArgs<ExtArgs> = {}>(args?: Subset<T, User$SelleraccountArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Dealer<T extends User$DealerArgs<ExtArgs> = {}>(args?: Subset<T, User$DealerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JobProfle<T extends User$JobProfleArgs<ExtArgs> = {}>(args?: Subset<T, User$JobProfleArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Review<T extends User$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$ReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishList<T extends User$WishListArgs<ExtArgs> = {}>(args?: Subset<T, User$WishListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Member<T extends User$MemberArgs<ExtArgs> = {}>(args?: Subset<T, User$MemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductQuery<T extends User$ProductQueryArgs<ExtArgs> = {}>(args?: Subset<T, User$ProductQueryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly googlemail: FieldRef<"User", 'String'>
    readonly extra: FieldRef<"User", 'String'>
    readonly contact: FieldRef<"User", 'BigInt'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.team
   */
  export type User$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.Listing
   */
  export type User$ListingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * User.Selleraccount
   */
  export type User$SelleraccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    where?: SellerAccountWhereInput
  }

  /**
   * User.Dealer
   */
  export type User$DealerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    where?: DealersWhereInput
    orderBy?: DealersOrderByWithRelationInput | DealersOrderByWithRelationInput[]
    cursor?: DealersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealersScalarFieldEnum | DealersScalarFieldEnum[]
  }

  /**
   * User.JobProfle
   */
  export type User$JobProfleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    where?: JobProfileWhereInput
  }

  /**
   * User.Review
   */
  export type User$ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.WishList
   */
  export type User$WishListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    where?: WishListWhereInput
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    cursor?: WishListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * User.Member
   */
  export type User$MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.ProductQuery
   */
  export type User$ProductQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    where?: ProductQueryWhereInput
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    cursor?: ProductQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductQueryScalarFieldEnum | ProductQueryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model JobProfile
   */

  export type AggregateJobProfile = {
    _count: JobProfileCountAggregateOutputType | null
    _avg: JobProfileAvgAggregateOutputType | null
    _sum: JobProfileSumAggregateOutputType | null
    _min: JobProfileMinAggregateOutputType | null
    _max: JobProfileMaxAggregateOutputType | null
  }

  export type JobProfileAvgAggregateOutputType = {
    rating: number | null
    workdone: number | null
  }

  export type JobProfileSumAggregateOutputType = {
    rating: number | null
    workdone: number | null
  }

  export type JobProfileMinAggregateOutputType = {
    id: string | null
    rating: number | null
    lastdisabled: Date | null
    createdAt: Date | null
    workdone: number | null
    status: boolean | null
    location: string | null
  }

  export type JobProfileMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    lastdisabled: Date | null
    createdAt: Date | null
    workdone: number | null
    status: boolean | null
    location: string | null
  }

  export type JobProfileCountAggregateOutputType = {
    id: number
    rating: number
    jobsapplied: number
    lastdisabled: number
    createdAt: number
    workdone: number
    status: number
    location: number
    _all: number
  }


  export type JobProfileAvgAggregateInputType = {
    rating?: true
    workdone?: true
  }

  export type JobProfileSumAggregateInputType = {
    rating?: true
    workdone?: true
  }

  export type JobProfileMinAggregateInputType = {
    id?: true
    rating?: true
    lastdisabled?: true
    createdAt?: true
    workdone?: true
    status?: true
    location?: true
  }

  export type JobProfileMaxAggregateInputType = {
    id?: true
    rating?: true
    lastdisabled?: true
    createdAt?: true
    workdone?: true
    status?: true
    location?: true
  }

  export type JobProfileCountAggregateInputType = {
    id?: true
    rating?: true
    jobsapplied?: true
    lastdisabled?: true
    createdAt?: true
    workdone?: true
    status?: true
    location?: true
    _all?: true
  }

  export type JobProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobProfile to aggregate.
     */
    where?: JobProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobProfiles to fetch.
     */
    orderBy?: JobProfileOrderByWithRelationInput | JobProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobProfiles
    **/
    _count?: true | JobProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobProfileMaxAggregateInputType
  }

  export type GetJobProfileAggregateType<T extends JobProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateJobProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobProfile[P]>
      : GetScalarType<T[P], AggregateJobProfile[P]>
  }




  export type JobProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobProfileWhereInput
    orderBy?: JobProfileOrderByWithAggregationInput | JobProfileOrderByWithAggregationInput[]
    by: JobProfileScalarFieldEnum[] | JobProfileScalarFieldEnum
    having?: JobProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobProfileCountAggregateInputType | true
    _avg?: JobProfileAvgAggregateInputType
    _sum?: JobProfileSumAggregateInputType
    _min?: JobProfileMinAggregateInputType
    _max?: JobProfileMaxAggregateInputType
  }

  export type JobProfileGroupByOutputType = {
    id: string
    rating: number | null
    jobsapplied: string[]
    lastdisabled: Date | null
    createdAt: Date
    workdone: number | null
    status: boolean
    location: string | null
    _count: JobProfileCountAggregateOutputType | null
    _avg: JobProfileAvgAggregateOutputType | null
    _sum: JobProfileSumAggregateOutputType | null
    _min: JobProfileMinAggregateOutputType | null
    _max: JobProfileMaxAggregateOutputType | null
  }

  type GetJobProfileGroupByPayload<T extends JobProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobProfileGroupByOutputType[P]>
            : GetScalarType<T[P], JobProfileGroupByOutputType[P]>
        }
      >
    >


  export type JobProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    jobsapplied?: boolean
    lastdisabled?: boolean
    createdAt?: boolean
    workdone?: boolean
    status?: boolean
    location?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobProfile"]>

  export type JobProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    jobsapplied?: boolean
    lastdisabled?: boolean
    createdAt?: boolean
    workdone?: boolean
    status?: boolean
    location?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobProfile"]>

  export type JobProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    jobsapplied?: boolean
    lastdisabled?: boolean
    createdAt?: boolean
    workdone?: boolean
    status?: boolean
    location?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobProfile"]>

  export type JobProfileSelectScalar = {
    id?: boolean
    rating?: boolean
    jobsapplied?: boolean
    lastdisabled?: boolean
    createdAt?: boolean
    workdone?: boolean
    status?: boolean
    location?: boolean
  }

  export type JobProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "jobsapplied" | "lastdisabled" | "createdAt" | "workdone" | "status" | "location", ExtArgs["result"]["jobProfile"]>
  export type JobProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JobProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobProfile"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number | null
      jobsapplied: string[]
      lastdisabled: Date | null
      createdAt: Date
      workdone: number | null
      status: boolean
      location: string | null
    }, ExtArgs["result"]["jobProfile"]>
    composites: {}
  }

  type JobProfileGetPayload<S extends boolean | null | undefined | JobProfileDefaultArgs> = $Result.GetResult<Prisma.$JobProfilePayload, S>

  type JobProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobProfileCountAggregateInputType | true
    }

  export interface JobProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobProfile'], meta: { name: 'JobProfile' } }
    /**
     * Find zero or one JobProfile that matches the filter.
     * @param {JobProfileFindUniqueArgs} args - Arguments to find a JobProfile
     * @example
     * // Get one JobProfile
     * const jobProfile = await prisma.jobProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobProfileFindUniqueArgs>(args: SelectSubset<T, JobProfileFindUniqueArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobProfileFindUniqueOrThrowArgs} args - Arguments to find a JobProfile
     * @example
     * // Get one JobProfile
     * const jobProfile = await prisma.jobProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, JobProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileFindFirstArgs} args - Arguments to find a JobProfile
     * @example
     * // Get one JobProfile
     * const jobProfile = await prisma.jobProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobProfileFindFirstArgs>(args?: SelectSubset<T, JobProfileFindFirstArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileFindFirstOrThrowArgs} args - Arguments to find a JobProfile
     * @example
     * // Get one JobProfile
     * const jobProfile = await prisma.jobProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, JobProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobProfiles
     * const jobProfiles = await prisma.jobProfile.findMany()
     * 
     * // Get first 10 JobProfiles
     * const jobProfiles = await prisma.jobProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobProfileWithIdOnly = await prisma.jobProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobProfileFindManyArgs>(args?: SelectSubset<T, JobProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobProfile.
     * @param {JobProfileCreateArgs} args - Arguments to create a JobProfile.
     * @example
     * // Create one JobProfile
     * const JobProfile = await prisma.jobProfile.create({
     *   data: {
     *     // ... data to create a JobProfile
     *   }
     * })
     * 
     */
    create<T extends JobProfileCreateArgs>(args: SelectSubset<T, JobProfileCreateArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobProfiles.
     * @param {JobProfileCreateManyArgs} args - Arguments to create many JobProfiles.
     * @example
     * // Create many JobProfiles
     * const jobProfile = await prisma.jobProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobProfileCreateManyArgs>(args?: SelectSubset<T, JobProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobProfiles and returns the data saved in the database.
     * @param {JobProfileCreateManyAndReturnArgs} args - Arguments to create many JobProfiles.
     * @example
     * // Create many JobProfiles
     * const jobProfile = await prisma.jobProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobProfiles and only return the `id`
     * const jobProfileWithIdOnly = await prisma.jobProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, JobProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobProfile.
     * @param {JobProfileDeleteArgs} args - Arguments to delete one JobProfile.
     * @example
     * // Delete one JobProfile
     * const JobProfile = await prisma.jobProfile.delete({
     *   where: {
     *     // ... filter to delete one JobProfile
     *   }
     * })
     * 
     */
    delete<T extends JobProfileDeleteArgs>(args: SelectSubset<T, JobProfileDeleteArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobProfile.
     * @param {JobProfileUpdateArgs} args - Arguments to update one JobProfile.
     * @example
     * // Update one JobProfile
     * const jobProfile = await prisma.jobProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobProfileUpdateArgs>(args: SelectSubset<T, JobProfileUpdateArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobProfiles.
     * @param {JobProfileDeleteManyArgs} args - Arguments to filter JobProfiles to delete.
     * @example
     * // Delete a few JobProfiles
     * const { count } = await prisma.jobProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobProfileDeleteManyArgs>(args?: SelectSubset<T, JobProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobProfiles
     * const jobProfile = await prisma.jobProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobProfileUpdateManyArgs>(args: SelectSubset<T, JobProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobProfiles and returns the data updated in the database.
     * @param {JobProfileUpdateManyAndReturnArgs} args - Arguments to update many JobProfiles.
     * @example
     * // Update many JobProfiles
     * const jobProfile = await prisma.jobProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobProfiles and only return the `id`
     * const jobProfileWithIdOnly = await prisma.jobProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, JobProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobProfile.
     * @param {JobProfileUpsertArgs} args - Arguments to update or create a JobProfile.
     * @example
     * // Update or create a JobProfile
     * const jobProfile = await prisma.jobProfile.upsert({
     *   create: {
     *     // ... data to create a JobProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobProfile we want to update
     *   }
     * })
     */
    upsert<T extends JobProfileUpsertArgs>(args: SelectSubset<T, JobProfileUpsertArgs<ExtArgs>>): Prisma__JobProfileClient<$Result.GetResult<Prisma.$JobProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileCountArgs} args - Arguments to filter JobProfiles to count.
     * @example
     * // Count the number of JobProfiles
     * const count = await prisma.jobProfile.count({
     *   where: {
     *     // ... the filter for the JobProfiles we want to count
     *   }
     * })
    **/
    count<T extends JobProfileCountArgs>(
      args?: Subset<T, JobProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobProfileAggregateArgs>(args: Subset<T, JobProfileAggregateArgs>): Prisma.PrismaPromise<GetJobProfileAggregateType<T>>

    /**
     * Group by JobProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobProfileGroupByArgs['orderBy'] }
        : { orderBy?: JobProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobProfile model
   */
  readonly fields: JobProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobProfile model
   */
  interface JobProfileFieldRefs {
    readonly id: FieldRef<"JobProfile", 'String'>
    readonly rating: FieldRef<"JobProfile", 'Int'>
    readonly jobsapplied: FieldRef<"JobProfile", 'String[]'>
    readonly lastdisabled: FieldRef<"JobProfile", 'DateTime'>
    readonly createdAt: FieldRef<"JobProfile", 'DateTime'>
    readonly workdone: FieldRef<"JobProfile", 'Int'>
    readonly status: FieldRef<"JobProfile", 'Boolean'>
    readonly location: FieldRef<"JobProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobProfile findUnique
   */
  export type JobProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter, which JobProfile to fetch.
     */
    where: JobProfileWhereUniqueInput
  }

  /**
   * JobProfile findUniqueOrThrow
   */
  export type JobProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter, which JobProfile to fetch.
     */
    where: JobProfileWhereUniqueInput
  }

  /**
   * JobProfile findFirst
   */
  export type JobProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter, which JobProfile to fetch.
     */
    where?: JobProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobProfiles to fetch.
     */
    orderBy?: JobProfileOrderByWithRelationInput | JobProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobProfiles.
     */
    cursor?: JobProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobProfiles.
     */
    distinct?: JobProfileScalarFieldEnum | JobProfileScalarFieldEnum[]
  }

  /**
   * JobProfile findFirstOrThrow
   */
  export type JobProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter, which JobProfile to fetch.
     */
    where?: JobProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobProfiles to fetch.
     */
    orderBy?: JobProfileOrderByWithRelationInput | JobProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobProfiles.
     */
    cursor?: JobProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobProfiles.
     */
    distinct?: JobProfileScalarFieldEnum | JobProfileScalarFieldEnum[]
  }

  /**
   * JobProfile findMany
   */
  export type JobProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter, which JobProfiles to fetch.
     */
    where?: JobProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobProfiles to fetch.
     */
    orderBy?: JobProfileOrderByWithRelationInput | JobProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobProfiles.
     */
    cursor?: JobProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobProfiles.
     */
    skip?: number
    distinct?: JobProfileScalarFieldEnum | JobProfileScalarFieldEnum[]
  }

  /**
   * JobProfile create
   */
  export type JobProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a JobProfile.
     */
    data: XOR<JobProfileCreateInput, JobProfileUncheckedCreateInput>
  }

  /**
   * JobProfile createMany
   */
  export type JobProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobProfiles.
     */
    data: JobProfileCreateManyInput | JobProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobProfile createManyAndReturn
   */
  export type JobProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * The data used to create many JobProfiles.
     */
    data: JobProfileCreateManyInput | JobProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobProfile update
   */
  export type JobProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a JobProfile.
     */
    data: XOR<JobProfileUpdateInput, JobProfileUncheckedUpdateInput>
    /**
     * Choose, which JobProfile to update.
     */
    where: JobProfileWhereUniqueInput
  }

  /**
   * JobProfile updateMany
   */
  export type JobProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobProfiles.
     */
    data: XOR<JobProfileUpdateManyMutationInput, JobProfileUncheckedUpdateManyInput>
    /**
     * Filter which JobProfiles to update
     */
    where?: JobProfileWhereInput
    /**
     * Limit how many JobProfiles to update.
     */
    limit?: number
  }

  /**
   * JobProfile updateManyAndReturn
   */
  export type JobProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * The data used to update JobProfiles.
     */
    data: XOR<JobProfileUpdateManyMutationInput, JobProfileUncheckedUpdateManyInput>
    /**
     * Filter which JobProfiles to update
     */
    where?: JobProfileWhereInput
    /**
     * Limit how many JobProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobProfile upsert
   */
  export type JobProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the JobProfile to update in case it exists.
     */
    where: JobProfileWhereUniqueInput
    /**
     * In case the JobProfile found by the `where` argument doesn't exist, create a new JobProfile with this data.
     */
    create: XOR<JobProfileCreateInput, JobProfileUncheckedCreateInput>
    /**
     * In case the JobProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobProfileUpdateInput, JobProfileUncheckedUpdateInput>
  }

  /**
   * JobProfile delete
   */
  export type JobProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
    /**
     * Filter which JobProfile to delete.
     */
    where: JobProfileWhereUniqueInput
  }

  /**
   * JobProfile deleteMany
   */
  export type JobProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobProfiles to delete
     */
    where?: JobProfileWhereInput
    /**
     * Limit how many JobProfiles to delete.
     */
    limit?: number
  }

  /**
   * JobProfile without action
   */
  export type JobProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobProfile
     */
    select?: JobProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobProfile
     */
    omit?: JobProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobProfileInclude<ExtArgs> | null
  }


  /**
   * Model Dealers
   */

  export type AggregateDealers = {
    _count: DealersCountAggregateOutputType | null
    _avg: DealersAvgAggregateOutputType | null
    _sum: DealersSumAggregateOutputType | null
    _min: DealersMinAggregateOutputType | null
    _max: DealersMaxAggregateOutputType | null
  }

  export type DealersAvgAggregateOutputType = {
    transactionWorth: number | null
  }

  export type DealersSumAggregateOutputType = {
    transactionWorth: number | null
  }

  export type DealersMinAggregateOutputType = {
    id: string | null
    idd: string | null
    name: string | null
    dealeremail: string | null
    dealerid: string | null
    email: string | null
    phonenum: string | null
    verified: boolean | null
    address: string | null
    category: string | null
    transactionWorth: number | null
    createdAt: Date | null
  }

  export type DealersMaxAggregateOutputType = {
    id: string | null
    idd: string | null
    name: string | null
    dealeremail: string | null
    dealerid: string | null
    email: string | null
    phonenum: string | null
    verified: boolean | null
    address: string | null
    category: string | null
    transactionWorth: number | null
    createdAt: Date | null
  }

  export type DealersCountAggregateOutputType = {
    id: number
    idd: number
    name: number
    dealeremail: number
    dealerid: number
    email: number
    phonenum: number
    verified: number
    address: number
    category: number
    transactionWorth: number
    createdAt: number
    _all: number
  }


  export type DealersAvgAggregateInputType = {
    transactionWorth?: true
  }

  export type DealersSumAggregateInputType = {
    transactionWorth?: true
  }

  export type DealersMinAggregateInputType = {
    id?: true
    idd?: true
    name?: true
    dealeremail?: true
    dealerid?: true
    email?: true
    phonenum?: true
    verified?: true
    address?: true
    category?: true
    transactionWorth?: true
    createdAt?: true
  }

  export type DealersMaxAggregateInputType = {
    id?: true
    idd?: true
    name?: true
    dealeremail?: true
    dealerid?: true
    email?: true
    phonenum?: true
    verified?: true
    address?: true
    category?: true
    transactionWorth?: true
    createdAt?: true
  }

  export type DealersCountAggregateInputType = {
    id?: true
    idd?: true
    name?: true
    dealeremail?: true
    dealerid?: true
    email?: true
    phonenum?: true
    verified?: true
    address?: true
    category?: true
    transactionWorth?: true
    createdAt?: true
    _all?: true
  }

  export type DealersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealers to aggregate.
     */
    where?: DealersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealersOrderByWithRelationInput | DealersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dealers
    **/
    _count?: true | DealersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealersMaxAggregateInputType
  }

  export type GetDealersAggregateType<T extends DealersAggregateArgs> = {
        [P in keyof T & keyof AggregateDealers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealers[P]>
      : GetScalarType<T[P], AggregateDealers[P]>
  }




  export type DealersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealersWhereInput
    orderBy?: DealersOrderByWithAggregationInput | DealersOrderByWithAggregationInput[]
    by: DealersScalarFieldEnum[] | DealersScalarFieldEnum
    having?: DealersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealersCountAggregateInputType | true
    _avg?: DealersAvgAggregateInputType
    _sum?: DealersSumAggregateInputType
    _min?: DealersMinAggregateInputType
    _max?: DealersMaxAggregateInputType
  }

  export type DealersGroupByOutputType = {
    id: string
    idd: string | null
    name: string | null
    dealeremail: string | null
    dealerid: string | null
    email: string | null
    phonenum: string | null
    verified: boolean | null
    address: string | null
    category: string | null
    transactionWorth: number | null
    createdAt: Date
    _count: DealersCountAggregateOutputType | null
    _avg: DealersAvgAggregateOutputType | null
    _sum: DealersSumAggregateOutputType | null
    _min: DealersMinAggregateOutputType | null
    _max: DealersMaxAggregateOutputType | null
  }

  type GetDealersGroupByPayload<T extends DealersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealersGroupByOutputType[P]>
            : GetScalarType<T[P], DealersGroupByOutputType[P]>
        }
      >
    >


  export type DealersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idd?: boolean
    name?: boolean
    dealeremail?: boolean
    dealerid?: boolean
    email?: boolean
    phonenum?: boolean
    verified?: boolean
    address?: boolean
    category?: boolean
    transactionWorth?: boolean
    createdAt?: boolean
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["dealers"]>

  export type DealersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idd?: boolean
    name?: boolean
    dealeremail?: boolean
    dealerid?: boolean
    email?: boolean
    phonenum?: boolean
    verified?: boolean
    address?: boolean
    category?: boolean
    transactionWorth?: boolean
    createdAt?: boolean
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["dealers"]>

  export type DealersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idd?: boolean
    name?: boolean
    dealeremail?: boolean
    dealerid?: boolean
    email?: boolean
    phonenum?: boolean
    verified?: boolean
    address?: boolean
    category?: boolean
    transactionWorth?: boolean
    createdAt?: boolean
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }, ExtArgs["result"]["dealers"]>

  export type DealersSelectScalar = {
    id?: boolean
    idd?: boolean
    name?: boolean
    dealeremail?: boolean
    dealerid?: boolean
    email?: boolean
    phonenum?: boolean
    verified?: boolean
    address?: boolean
    category?: boolean
    transactionWorth?: boolean
    createdAt?: boolean
  }

  export type DealersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idd" | "name" | "dealeremail" | "dealerid" | "email" | "phonenum" | "verified" | "address" | "category" | "transactionWorth" | "createdAt", ExtArgs["result"]["dealers"]>
  export type DealersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }
  export type DealersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }
  export type DealersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Dealers$UsersArgs<ExtArgs>
  }

  export type $DealersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dealers"
    objects: {
      Users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idd: string | null
      name: string | null
      dealeremail: string | null
      dealerid: string | null
      email: string | null
      phonenum: string | null
      verified: boolean | null
      address: string | null
      category: string | null
      transactionWorth: number | null
      createdAt: Date
    }, ExtArgs["result"]["dealers"]>
    composites: {}
  }

  type DealersGetPayload<S extends boolean | null | undefined | DealersDefaultArgs> = $Result.GetResult<Prisma.$DealersPayload, S>

  type DealersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealersCountAggregateInputType | true
    }

  export interface DealersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dealers'], meta: { name: 'Dealers' } }
    /**
     * Find zero or one Dealers that matches the filter.
     * @param {DealersFindUniqueArgs} args - Arguments to find a Dealers
     * @example
     * // Get one Dealers
     * const dealers = await prisma.dealers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealersFindUniqueArgs>(args: SelectSubset<T, DealersFindUniqueArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dealers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealersFindUniqueOrThrowArgs} args - Arguments to find a Dealers
     * @example
     * // Get one Dealers
     * const dealers = await prisma.dealers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealersFindUniqueOrThrowArgs>(args: SelectSubset<T, DealersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dealers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersFindFirstArgs} args - Arguments to find a Dealers
     * @example
     * // Get one Dealers
     * const dealers = await prisma.dealers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealersFindFirstArgs>(args?: SelectSubset<T, DealersFindFirstArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dealers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersFindFirstOrThrowArgs} args - Arguments to find a Dealers
     * @example
     * // Get one Dealers
     * const dealers = await prisma.dealers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealersFindFirstOrThrowArgs>(args?: SelectSubset<T, DealersFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dealers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dealers
     * const dealers = await prisma.dealers.findMany()
     * 
     * // Get first 10 Dealers
     * const dealers = await prisma.dealers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealersWithIdOnly = await prisma.dealers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealersFindManyArgs>(args?: SelectSubset<T, DealersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dealers.
     * @param {DealersCreateArgs} args - Arguments to create a Dealers.
     * @example
     * // Create one Dealers
     * const Dealers = await prisma.dealers.create({
     *   data: {
     *     // ... data to create a Dealers
     *   }
     * })
     * 
     */
    create<T extends DealersCreateArgs>(args: SelectSubset<T, DealersCreateArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dealers.
     * @param {DealersCreateManyArgs} args - Arguments to create many Dealers.
     * @example
     * // Create many Dealers
     * const dealers = await prisma.dealers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealersCreateManyArgs>(args?: SelectSubset<T, DealersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dealers and returns the data saved in the database.
     * @param {DealersCreateManyAndReturnArgs} args - Arguments to create many Dealers.
     * @example
     * // Create many Dealers
     * const dealers = await prisma.dealers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dealers and only return the `id`
     * const dealersWithIdOnly = await prisma.dealers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealersCreateManyAndReturnArgs>(args?: SelectSubset<T, DealersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dealers.
     * @param {DealersDeleteArgs} args - Arguments to delete one Dealers.
     * @example
     * // Delete one Dealers
     * const Dealers = await prisma.dealers.delete({
     *   where: {
     *     // ... filter to delete one Dealers
     *   }
     * })
     * 
     */
    delete<T extends DealersDeleteArgs>(args: SelectSubset<T, DealersDeleteArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dealers.
     * @param {DealersUpdateArgs} args - Arguments to update one Dealers.
     * @example
     * // Update one Dealers
     * const dealers = await prisma.dealers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealersUpdateArgs>(args: SelectSubset<T, DealersUpdateArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dealers.
     * @param {DealersDeleteManyArgs} args - Arguments to filter Dealers to delete.
     * @example
     * // Delete a few Dealers
     * const { count } = await prisma.dealers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealersDeleteManyArgs>(args?: SelectSubset<T, DealersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dealers
     * const dealers = await prisma.dealers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealersUpdateManyArgs>(args: SelectSubset<T, DealersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dealers and returns the data updated in the database.
     * @param {DealersUpdateManyAndReturnArgs} args - Arguments to update many Dealers.
     * @example
     * // Update many Dealers
     * const dealers = await prisma.dealers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dealers and only return the `id`
     * const dealersWithIdOnly = await prisma.dealers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealersUpdateManyAndReturnArgs>(args: SelectSubset<T, DealersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dealers.
     * @param {DealersUpsertArgs} args - Arguments to update or create a Dealers.
     * @example
     * // Update or create a Dealers
     * const dealers = await prisma.dealers.upsert({
     *   create: {
     *     // ... data to create a Dealers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dealers we want to update
     *   }
     * })
     */
    upsert<T extends DealersUpsertArgs>(args: SelectSubset<T, DealersUpsertArgs<ExtArgs>>): Prisma__DealersClient<$Result.GetResult<Prisma.$DealersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersCountArgs} args - Arguments to filter Dealers to count.
     * @example
     * // Count the number of Dealers
     * const count = await prisma.dealers.count({
     *   where: {
     *     // ... the filter for the Dealers we want to count
     *   }
     * })
    **/
    count<T extends DealersCountArgs>(
      args?: Subset<T, DealersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealersAggregateArgs>(args: Subset<T, DealersAggregateArgs>): Prisma.PrismaPromise<GetDealersAggregateType<T>>

    /**
     * Group by Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealersGroupByArgs['orderBy'] }
        : { orderBy?: DealersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dealers model
   */
  readonly fields: DealersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dealers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Dealers$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Dealers$UsersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dealers model
   */
  interface DealersFieldRefs {
    readonly id: FieldRef<"Dealers", 'String'>
    readonly idd: FieldRef<"Dealers", 'String'>
    readonly name: FieldRef<"Dealers", 'String'>
    readonly dealeremail: FieldRef<"Dealers", 'String'>
    readonly dealerid: FieldRef<"Dealers", 'String'>
    readonly email: FieldRef<"Dealers", 'String'>
    readonly phonenum: FieldRef<"Dealers", 'String'>
    readonly verified: FieldRef<"Dealers", 'Boolean'>
    readonly address: FieldRef<"Dealers", 'String'>
    readonly category: FieldRef<"Dealers", 'String'>
    readonly transactionWorth: FieldRef<"Dealers", 'Int'>
    readonly createdAt: FieldRef<"Dealers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dealers findUnique
   */
  export type DealersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where: DealersWhereUniqueInput
  }

  /**
   * Dealers findUniqueOrThrow
   */
  export type DealersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where: DealersWhereUniqueInput
  }

  /**
   * Dealers findFirst
   */
  export type DealersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where?: DealersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealersOrderByWithRelationInput | DealersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealers.
     */
    cursor?: DealersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealers.
     */
    distinct?: DealersScalarFieldEnum | DealersScalarFieldEnum[]
  }

  /**
   * Dealers findFirstOrThrow
   */
  export type DealersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where?: DealersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealersOrderByWithRelationInput | DealersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealers.
     */
    cursor?: DealersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealers.
     */
    distinct?: DealersScalarFieldEnum | DealersScalarFieldEnum[]
  }

  /**
   * Dealers findMany
   */
  export type DealersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where?: DealersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealersOrderByWithRelationInput | DealersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dealers.
     */
    cursor?: DealersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    distinct?: DealersScalarFieldEnum | DealersScalarFieldEnum[]
  }

  /**
   * Dealers create
   */
  export type DealersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * The data needed to create a Dealers.
     */
    data?: XOR<DealersCreateInput, DealersUncheckedCreateInput>
  }

  /**
   * Dealers createMany
   */
  export type DealersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dealers.
     */
    data: DealersCreateManyInput | DealersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dealers createManyAndReturn
   */
  export type DealersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * The data used to create many Dealers.
     */
    data: DealersCreateManyInput | DealersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dealers update
   */
  export type DealersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * The data needed to update a Dealers.
     */
    data: XOR<DealersUpdateInput, DealersUncheckedUpdateInput>
    /**
     * Choose, which Dealers to update.
     */
    where: DealersWhereUniqueInput
  }

  /**
   * Dealers updateMany
   */
  export type DealersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dealers.
     */
    data: XOR<DealersUpdateManyMutationInput, DealersUncheckedUpdateManyInput>
    /**
     * Filter which Dealers to update
     */
    where?: DealersWhereInput
    /**
     * Limit how many Dealers to update.
     */
    limit?: number
  }

  /**
   * Dealers updateManyAndReturn
   */
  export type DealersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * The data used to update Dealers.
     */
    data: XOR<DealersUpdateManyMutationInput, DealersUncheckedUpdateManyInput>
    /**
     * Filter which Dealers to update
     */
    where?: DealersWhereInput
    /**
     * Limit how many Dealers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dealers upsert
   */
  export type DealersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * The filter to search for the Dealers to update in case it exists.
     */
    where: DealersWhereUniqueInput
    /**
     * In case the Dealers found by the `where` argument doesn't exist, create a new Dealers with this data.
     */
    create: XOR<DealersCreateInput, DealersUncheckedCreateInput>
    /**
     * In case the Dealers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealersUpdateInput, DealersUncheckedUpdateInput>
  }

  /**
   * Dealers delete
   */
  export type DealersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
    /**
     * Filter which Dealers to delete.
     */
    where: DealersWhereUniqueInput
  }

  /**
   * Dealers deleteMany
   */
  export type DealersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealers to delete
     */
    where?: DealersWhereInput
    /**
     * Limit how many Dealers to delete.
     */
    limit?: number
  }

  /**
   * Dealers.Users
   */
  export type Dealers$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Dealers without action
   */
  export type DealersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealers
     */
    select?: DealersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dealers
     */
    omit?: DealersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealersInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderStatus: $Enums.OrderStatus | null
    sellerid: string | null
    buyerName: string | null
    buyerEmail: string | null
    buyerContact: string | null
    buyerId: string | null
    orders: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderStatus: $Enums.OrderStatus | null
    sellerid: string | null
    buyerName: string | null
    buyerEmail: string | null
    buyerContact: string | null
    buyerId: string | null
    orders: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderStatus: number
    sellerid: number
    buyerName: number
    buyerEmail: number
    buyerContact: number
    buyerId: number
    orders: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    orderStatus?: true
    sellerid?: true
    buyerName?: true
    buyerEmail?: true
    buyerContact?: true
    buyerId?: true
    orders?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderStatus?: true
    sellerid?: true
    buyerName?: true
    buyerEmail?: true
    buyerContact?: true
    buyerId?: true
    orders?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderStatus?: true
    sellerid?: true
    buyerName?: true
    buyerEmail?: true
    buyerContact?: true
    buyerId?: true
    orders?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderStatus: $Enums.OrderStatus | null
    sellerid: string | null
    buyerName: string
    buyerEmail: string
    buyerContact: string | null
    buyerId: string | null
    orders: string | null
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderStatus?: boolean
    sellerid?: boolean
    buyerName?: boolean
    buyerEmail?: boolean
    buyerContact?: boolean
    buyerId?: boolean
    orders?: boolean
    seller?: boolean | Order$sellerArgs<ExtArgs>
    product?: boolean | Order$productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderStatus?: boolean
    sellerid?: boolean
    buyerName?: boolean
    buyerEmail?: boolean
    buyerContact?: boolean
    buyerId?: boolean
    orders?: boolean
    seller?: boolean | Order$sellerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderStatus?: boolean
    sellerid?: boolean
    buyerName?: boolean
    buyerEmail?: boolean
    buyerContact?: boolean
    buyerId?: boolean
    orders?: boolean
    seller?: boolean | Order$sellerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderStatus?: boolean
    sellerid?: boolean
    buyerName?: boolean
    buyerEmail?: boolean
    buyerContact?: boolean
    buyerId?: boolean
    orders?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderStatus" | "sellerid" | "buyerName" | "buyerEmail" | "buyerContact" | "buyerId" | "orders", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | Order$sellerArgs<ExtArgs>
    product?: boolean | Order$productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | Order$sellerArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | Order$sellerArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      seller: Prisma.$SellerAccountPayload<ExtArgs> | null
      product: Prisma.$ProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderStatus: $Enums.OrderStatus | null
      sellerid: string | null
      buyerName: string
      buyerEmail: string
      buyerContact: string | null
      buyerId: string | null
      orders: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends Order$sellerArgs<ExtArgs> = {}>(args?: Subset<T, Order$sellerArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Order$productArgs<ExtArgs> = {}>(args?: Subset<T, Order$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderStatus: FieldRef<"Order", 'OrderStatus'>
    readonly sellerid: FieldRef<"Order", 'String'>
    readonly buyerName: FieldRef<"Order", 'String'>
    readonly buyerEmail: FieldRef<"Order", 'String'>
    readonly buyerContact: FieldRef<"Order", 'String'>
    readonly buyerId: FieldRef<"Order", 'String'>
    readonly orders: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.seller
   */
  export type Order$sellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    where?: SellerAccountWhereInput
  }

  /**
   * Order.product
   */
  export type Order$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    budget: number | null
  }

  export type ProjectSumAggregateOutputType = {
    budget: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.Category | null
    createdAt: Date | null
    userid: string | null
    coverimgUrl: string | null
    budget: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.Category | null
    createdAt: Date | null
    userid: string | null
    coverimgUrl: string | null
    budget: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    createdAt: number
    userid: number
    coverimgUrl: number
    budget: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    budget?: true
  }

  export type ProjectSumAggregateInputType = {
    budget?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    userid?: true
    coverimgUrl?: true
    budget?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    userid?: true
    coverimgUrl?: true
    budget?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    userid?: true
    coverimgUrl?: true
    budget?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string
    category: $Enums.Category
    createdAt: Date
    userid: string
    coverimgUrl: string | null
    budget: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    userid?: boolean
    coverimgUrl?: boolean
    budget?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    member?: boolean | Project$memberArgs<ExtArgs>
    Task?: boolean | Project$TaskArgs<ExtArgs>
    finance?: boolean | Project$financeArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    ScheduledMsg?: boolean | Project$ScheduledMsgArgs<ExtArgs>
    Inventory?: boolean | Project$InventoryArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    userid?: boolean
    coverimgUrl?: boolean
    budget?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    userid?: boolean
    coverimgUrl?: boolean
    budget?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    userid?: boolean
    coverimgUrl?: boolean
    budget?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "createdAt" | "userid" | "coverimgUrl" | "budget", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    member?: boolean | Project$memberArgs<ExtArgs>
    Task?: boolean | Project$TaskArgs<ExtArgs>
    finance?: boolean | Project$financeArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    ScheduledMsg?: boolean | Project$ScheduledMsgArgs<ExtArgs>
    Inventory?: boolean | Project$InventoryArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      member: Prisma.$MemberPayload<ExtArgs>[]
      Task: Prisma.$TaskPayload<ExtArgs>[]
      finance: Prisma.$FinancePayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      ScheduledMsg: Prisma.$ScheduleMsgPayload<ExtArgs>[]
      Inventory: Prisma.$InventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: $Enums.Category
      createdAt: Date
      userid: string
      coverimgUrl: string | null
      budget: number | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends Project$memberArgs<ExtArgs> = {}>(args?: Subset<T, Project$memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Task<T extends Project$TaskArgs<ExtArgs> = {}>(args?: Subset<T, Project$TaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finance<T extends Project$financeArgs<ExtArgs> = {}>(args?: Subset<T, Project$financeArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ScheduledMsg<T extends Project$ScheduledMsgArgs<ExtArgs> = {}>(args?: Subset<T, Project$ScheduledMsgArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inventory<T extends Project$InventoryArgs<ExtArgs> = {}>(args?: Subset<T, Project$InventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly category: FieldRef<"Project", 'Category'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly userid: FieldRef<"Project", 'String'>
    readonly coverimgUrl: FieldRef<"Project", 'String'>
    readonly budget: FieldRef<"Project", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.member
   */
  export type Project$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Project.Task
   */
  export type Project$TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.finance
   */
  export type Project$financeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    where?: FinanceWhereInput
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Project.ScheduledMsg
   */
  export type Project$ScheduledMsgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    where?: ScheduleMsgWhereInput
    orderBy?: ScheduleMsgOrderByWithRelationInput | ScheduleMsgOrderByWithRelationInput[]
    cursor?: ScheduleMsgWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleMsgScalarFieldEnum | ScheduleMsgScalarFieldEnum[]
  }

  /**
   * Project.Inventory
   */
  export type Project$InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    userid: string | null
    projectId: string | null
    name: string | null
    useremail: string | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    projectId: string | null
    name: string | null
    useremail: string | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    userid: number
    projectId: number
    name: number
    useremail: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    userid?: true
    projectId?: true
    name?: true
    useremail?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    userid?: true
    projectId?: true
    name?: true
    useremail?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    userid?: true
    projectId?: true
    name?: true
    useremail?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    userid: string | null
    projectId: string
    name: string | null
    useremail: string
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    projectId?: boolean
    name?: boolean
    useremail?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    projectId?: boolean
    name?: boolean
    useremail?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    projectId?: boolean
    name?: boolean
    useremail?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    userid?: boolean
    projectId?: boolean
    name?: boolean
    useremail?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "projectId" | "name" | "useremail", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      Project: Prisma.$ProjectPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string | null
      projectId: string
      name: string | null
      useremail: string
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly userid: FieldRef<"Member", 'String'>
    readonly projectId: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly useremail: FieldRef<"Member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    value: number | null
  }

  export type InventorySumAggregateOutputType = {
    value: bigint | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    available: boolean | null
    name: string | null
    description: string | null
    createdAt: Date | null
    value: bigint | null
    stock: string | null
    valueperpeice: string | null
    projectId: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    available: boolean | null
    name: string | null
    description: string | null
    createdAt: Date | null
    value: bigint | null
    stock: string | null
    valueperpeice: string | null
    projectId: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    available: number
    name: number
    description: number
    createdAt: number
    value: number
    stock: number
    valueperpeice: number
    projectId: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    value?: true
  }

  export type InventorySumAggregateInputType = {
    value?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    available?: true
    name?: true
    description?: true
    createdAt?: true
    value?: true
    stock?: true
    valueperpeice?: true
    projectId?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    available?: true
    name?: true
    description?: true
    createdAt?: true
    value?: true
    stock?: true
    valueperpeice?: true
    projectId?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    available?: true
    name?: true
    description?: true
    createdAt?: true
    value?: true
    stock?: true
    valueperpeice?: true
    projectId?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    available: boolean | null
    name: string
    description: string | null
    createdAt: Date
    value: bigint
    stock: string | null
    valueperpeice: string | null
    projectId: string
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    available?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    value?: boolean
    stock?: boolean
    valueperpeice?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    available?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    value?: boolean
    stock?: boolean
    valueperpeice?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    available?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    value?: boolean
    stock?: boolean
    valueperpeice?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    available?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    value?: boolean
    stock?: boolean
    valueperpeice?: boolean
    projectId?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "available" | "name" | "description" | "createdAt" | "value" | "stock" | "valueperpeice" | "projectId", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      Project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      available: boolean | null
      name: string
      description: string | null
      createdAt: Date
      value: bigint
      stock: string | null
      valueperpeice: string | null
      projectId: string
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly available: FieldRef<"Inventory", 'Boolean'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly value: FieldRef<"Inventory", 'BigInt'>
    readonly stock: FieldRef<"Inventory", 'String'>
    readonly valueperpeice: FieldRef<"Inventory", 'String'>
    readonly projectId: FieldRef<"Inventory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    phonenum: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    phonenum: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    verified: boolean | null
    phonenum: number | null
    useriid: string | null
    createdat: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    verified: boolean | null
    phonenum: number | null
    useriid: string | null
    createdat: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    email: number
    name: number
    verified: number
    phonenum: number
    useriid: number
    createdat: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    phonenum?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    phonenum?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    verified?: true
    phonenum?: true
    useriid?: true
    createdat?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    verified?: true
    phonenum?: true
    useriid?: true
    createdat?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    verified?: true
    phonenum?: true
    useriid?: true
    createdat?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    email: string
    name: string
    verified: boolean
    phonenum: number
    useriid: string | null
    createdat: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    verified?: boolean
    phonenum?: boolean
    useriid?: boolean
    createdat?: boolean
    User?: boolean | Team$UserArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    verified?: boolean
    phonenum?: boolean
    useriid?: boolean
    createdat?: boolean
    User?: boolean | Team$UserArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    verified?: boolean
    phonenum?: boolean
    useriid?: boolean
    createdat?: boolean
    User?: boolean | Team$UserArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    verified?: boolean
    phonenum?: boolean
    useriid?: boolean
    createdat?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "verified" | "phonenum" | "useriid" | "createdat", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Team$UserArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Team$UserArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Team$UserArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      verified: boolean
      phonenum: number
      useriid: string | null
      createdat: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Team$UserArgs<ExtArgs> = {}>(args?: Subset<T, Team$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly email: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly verified: FieldRef<"Team", 'Boolean'>
    readonly phonenum: FieldRef<"Team", 'Int'>
    readonly useriid: FieldRef<"Team", 'String'>
    readonly createdat: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.User
   */
  export type Team$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Listing
   */

  export type AggregateListing = {
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  export type ListingAvgAggregateOutputType = {
    rating: number | null
  }

  export type ListingSumAggregateOutputType = {
    rating: number | null
  }

  export type ListingMinAggregateOutputType = {
    id: string | null
    image: string | null
    rating: number | null
    address: string | null
    soldout: boolean | null
    description: string | null
    ownerId: string | null
  }

  export type ListingMaxAggregateOutputType = {
    id: string | null
    image: string | null
    rating: number | null
    address: string | null
    soldout: boolean | null
    description: string | null
    ownerId: string | null
  }

  export type ListingCountAggregateOutputType = {
    id: number
    image: number
    rating: number
    address: number
    soldout: number
    description: number
    ownerId: number
    _all: number
  }


  export type ListingAvgAggregateInputType = {
    rating?: true
  }

  export type ListingSumAggregateInputType = {
    rating?: true
  }

  export type ListingMinAggregateInputType = {
    id?: true
    image?: true
    rating?: true
    address?: true
    soldout?: true
    description?: true
    ownerId?: true
  }

  export type ListingMaxAggregateInputType = {
    id?: true
    image?: true
    rating?: true
    address?: true
    soldout?: true
    description?: true
    ownerId?: true
  }

  export type ListingCountAggregateInputType = {
    id?: true
    image?: true
    rating?: true
    address?: true
    soldout?: true
    description?: true
    ownerId?: true
    _all?: true
  }

  export type ListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listing to aggregate.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Listings
    **/
    _count?: true | ListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingMaxAggregateInputType
  }

  export type GetListingAggregateType<T extends ListingAggregateArgs> = {
        [P in keyof T & keyof AggregateListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing[P]>
      : GetScalarType<T[P], AggregateListing[P]>
  }




  export type ListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithAggregationInput | ListingOrderByWithAggregationInput[]
    by: ListingScalarFieldEnum[] | ListingScalarFieldEnum
    having?: ListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingCountAggregateInputType | true
    _avg?: ListingAvgAggregateInputType
    _sum?: ListingSumAggregateInputType
    _min?: ListingMinAggregateInputType
    _max?: ListingMaxAggregateInputType
  }

  export type ListingGroupByOutputType = {
    id: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description: string | null
    ownerId: string | null
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  type GetListingGroupByPayload<T extends ListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingGroupByOutputType[P]>
            : GetScalarType<T[P], ListingGroupByOutputType[P]>
        }
      >
    >


  export type ListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    rating?: boolean
    address?: boolean
    soldout?: boolean
    description?: boolean
    ownerId?: boolean
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    rating?: boolean
    address?: boolean
    soldout?: boolean
    description?: boolean
    ownerId?: boolean
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    rating?: boolean
    address?: boolean
    soldout?: boolean
    description?: boolean
    ownerId?: boolean
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectScalar = {
    id?: boolean
    image?: boolean
    rating?: boolean
    address?: boolean
    soldout?: boolean
    description?: boolean
    ownerId?: boolean
  }

  export type ListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "rating" | "address" | "soldout" | "description" | "ownerId", ExtArgs["result"]["listing"]>
  export type ListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }
  export type ListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }
  export type ListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Listing$ownerArgs<ExtArgs>
  }

  export type $ListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Listing"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      rating: number
      address: string
      soldout: boolean
      description: string | null
      ownerId: string | null
    }, ExtArgs["result"]["listing"]>
    composites: {}
  }

  type ListingGetPayload<S extends boolean | null | undefined | ListingDefaultArgs> = $Result.GetResult<Prisma.$ListingPayload, S>

  type ListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListingCountAggregateInputType | true
    }

  export interface ListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Listing'], meta: { name: 'Listing' } }
    /**
     * Find zero or one Listing that matches the filter.
     * @param {ListingFindUniqueArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListingFindUniqueArgs>(args: SelectSubset<T, ListingFindUniqueArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Listing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListingFindUniqueOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Listing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListingFindFirstArgs>(args?: SelectSubset<T, ListingFindFirstArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Listing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Listings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listings
     * const listings = await prisma.listing.findMany()
     * 
     * // Get first 10 Listings
     * const listings = await prisma.listing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingWithIdOnly = await prisma.listing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListingFindManyArgs>(args?: SelectSubset<T, ListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Listing.
     * @param {ListingCreateArgs} args - Arguments to create a Listing.
     * @example
     * // Create one Listing
     * const Listing = await prisma.listing.create({
     *   data: {
     *     // ... data to create a Listing
     *   }
     * })
     * 
     */
    create<T extends ListingCreateArgs>(args: SelectSubset<T, ListingCreateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Listings.
     * @param {ListingCreateManyArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListingCreateManyArgs>(args?: SelectSubset<T, ListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listings and returns the data saved in the database.
     * @param {ListingCreateManyAndReturnArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Listing.
     * @param {ListingDeleteArgs} args - Arguments to delete one Listing.
     * @example
     * // Delete one Listing
     * const Listing = await prisma.listing.delete({
     *   where: {
     *     // ... filter to delete one Listing
     *   }
     * })
     * 
     */
    delete<T extends ListingDeleteArgs>(args: SelectSubset<T, ListingDeleteArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Listing.
     * @param {ListingUpdateArgs} args - Arguments to update one Listing.
     * @example
     * // Update one Listing
     * const listing = await prisma.listing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListingUpdateArgs>(args: SelectSubset<T, ListingUpdateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Listings.
     * @param {ListingDeleteManyArgs} args - Arguments to filter Listings to delete.
     * @example
     * // Delete a few Listings
     * const { count } = await prisma.listing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListingDeleteManyArgs>(args?: SelectSubset<T, ListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListingUpdateManyArgs>(args: SelectSubset<T, ListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings and returns the data updated in the database.
     * @param {ListingUpdateManyAndReturnArgs} args - Arguments to update many Listings.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListingUpdateManyAndReturnArgs>(args: SelectSubset<T, ListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Listing.
     * @param {ListingUpsertArgs} args - Arguments to update or create a Listing.
     * @example
     * // Update or create a Listing
     * const listing = await prisma.listing.upsert({
     *   create: {
     *     // ... data to create a Listing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing we want to update
     *   }
     * })
     */
    upsert<T extends ListingUpsertArgs>(args: SelectSubset<T, ListingUpsertArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingCountArgs} args - Arguments to filter Listings to count.
     * @example
     * // Count the number of Listings
     * const count = await prisma.listing.count({
     *   where: {
     *     // ... the filter for the Listings we want to count
     *   }
     * })
    **/
    count<T extends ListingCountArgs>(
      args?: Subset<T, ListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingAggregateArgs>(args: Subset<T, ListingAggregateArgs>): Prisma.PrismaPromise<GetListingAggregateType<T>>

    /**
     * Group by Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingGroupByArgs['orderBy'] }
        : { orderBy?: ListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Listing model
   */
  readonly fields: ListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Listing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends Listing$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Listing$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Listing model
   */
  interface ListingFieldRefs {
    readonly id: FieldRef<"Listing", 'String'>
    readonly image: FieldRef<"Listing", 'String'>
    readonly rating: FieldRef<"Listing", 'Float'>
    readonly address: FieldRef<"Listing", 'String'>
    readonly soldout: FieldRef<"Listing", 'Boolean'>
    readonly description: FieldRef<"Listing", 'String'>
    readonly ownerId: FieldRef<"Listing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Listing findUnique
   */
  export type ListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findUniqueOrThrow
   */
  export type ListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findFirst
   */
  export type ListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findFirstOrThrow
   */
  export type ListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findMany
   */
  export type ListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listings to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing create
   */
  export type ListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to create a Listing.
     */
    data: XOR<ListingCreateInput, ListingUncheckedCreateInput>
  }

  /**
   * Listing createMany
   */
  export type ListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Listing createManyAndReturn
   */
  export type ListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing update
   */
  export type ListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to update a Listing.
     */
    data: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
    /**
     * Choose, which Listing to update.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing updateMany
   */
  export type ListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to update.
     */
    limit?: number
  }

  /**
   * Listing updateManyAndReturn
   */
  export type ListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing upsert
   */
  export type ListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The filter to search for the Listing to update in case it exists.
     */
    where: ListingWhereUniqueInput
    /**
     * In case the Listing found by the `where` argument doesn't exist, create a new Listing with this data.
     */
    create: XOR<ListingCreateInput, ListingUncheckedCreateInput>
    /**
     * In case the Listing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
  }

  /**
   * Listing delete
   */
  export type ListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter which Listing to delete.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing deleteMany
   */
  export type ListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listings to delete
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to delete.
     */
    limit?: number
  }

  /**
   * Listing.owner
   */
  export type Listing$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Listing without action
   */
  export type ListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    amount: number | null
  }

  export type TaskSumAggregateOutputType = {
    amount: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    task: string | null
    amount: number | null
    startdate: string | null
    deadline: string | null
    description: string | null
    teamlead: string | null
    priority: string | null
    status: boolean | null
    projectId: string | null
    createdAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    task: string | null
    amount: number | null
    startdate: string | null
    deadline: string | null
    description: string | null
    teamlead: string | null
    priority: string | null
    status: boolean | null
    projectId: string | null
    createdAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    task: number
    team: number
    amount: number
    startdate: number
    deadline: number
    description: number
    supplier: number
    subtasks: number
    inventories: number
    teamlead: number
    priority: number
    status: number
    projectId: number
    createdAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    amount?: true
  }

  export type TaskSumAggregateInputType = {
    amount?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    task?: true
    amount?: true
    startdate?: true
    deadline?: true
    description?: true
    teamlead?: true
    priority?: true
    status?: true
    projectId?: true
    createdAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    task?: true
    amount?: true
    startdate?: true
    deadline?: true
    description?: true
    teamlead?: true
    priority?: true
    status?: true
    projectId?: true
    createdAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    task?: true
    team?: true
    amount?: true
    startdate?: true
    deadline?: true
    description?: true
    supplier?: true
    subtasks?: true
    inventories?: true
    teamlead?: true
    priority?: true
    status?: true
    projectId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    task: string
    team: string[]
    amount: number | null
    startdate: string
    deadline: string
    description: string
    supplier: string[]
    subtasks: string[]
    inventories: string[]
    teamlead: string | null
    priority: string | null
    status: boolean | null
    projectId: string | null
    createdAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task?: boolean
    team?: boolean
    amount?: boolean
    startdate?: boolean
    deadline?: boolean
    description?: boolean
    supplier?: boolean
    subtasks?: boolean
    inventories?: boolean
    teamlead?: boolean
    priority?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task?: boolean
    team?: boolean
    amount?: boolean
    startdate?: boolean
    deadline?: boolean
    description?: boolean
    supplier?: boolean
    subtasks?: boolean
    inventories?: boolean
    teamlead?: boolean
    priority?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task?: boolean
    team?: boolean
    amount?: boolean
    startdate?: boolean
    deadline?: boolean
    description?: boolean
    supplier?: boolean
    subtasks?: boolean
    inventories?: boolean
    teamlead?: boolean
    priority?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    task?: boolean
    team?: boolean
    amount?: boolean
    startdate?: boolean
    deadline?: boolean
    description?: boolean
    supplier?: boolean
    subtasks?: boolean
    inventories?: boolean
    teamlead?: boolean
    priority?: boolean
    status?: boolean
    projectId?: boolean
    createdAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "task" | "team" | "amount" | "startdate" | "deadline" | "description" | "supplier" | "subtasks" | "inventories" | "teamlead" | "priority" | "status" | "projectId" | "createdAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | Task$ProjectArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      Project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      task: string
      team: string[]
      amount: number | null
      startdate: string
      deadline: string
      description: string
      supplier: string[]
      subtasks: string[]
      inventories: string[]
      teamlead: string | null
      priority: string | null
      status: boolean | null
      projectId: string | null
      createdAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Project<T extends Task$ProjectArgs<ExtArgs> = {}>(args?: Subset<T, Task$ProjectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly task: FieldRef<"Task", 'String'>
    readonly team: FieldRef<"Task", 'String[]'>
    readonly amount: FieldRef<"Task", 'Int'>
    readonly startdate: FieldRef<"Task", 'String'>
    readonly deadline: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly supplier: FieldRef<"Task", 'String[]'>
    readonly subtasks: FieldRef<"Task", 'String[]'>
    readonly inventories: FieldRef<"Task", 'String[]'>
    readonly teamlead: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'Boolean'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.Project
   */
  export type Task$ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    gstrate: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    gstrate: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    gstrate: number | null
    dealer: string | null
    status: $Enums.Status | null
    proof: string | null
    type: $Enums.Typetrans | null
    createdAt: Date | null
    financeId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    gstrate: number | null
    dealer: string | null
    status: $Enums.Status | null
    proof: string | null
    type: $Enums.Typetrans | null
    createdAt: Date | null
    financeId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    gstrate: number
    dealer: number
    status: number
    proof: number
    type: number
    createdAt: number
    financeId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    gstrate?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    gstrate?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    gstrate?: true
    dealer?: true
    status?: true
    proof?: true
    type?: true
    createdAt?: true
    financeId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    gstrate?: true
    dealer?: true
    status?: true
    proof?: true
    type?: true
    createdAt?: true
    financeId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    gstrate?: true
    dealer?: true
    status?: true
    proof?: true
    type?: true
    createdAt?: true
    financeId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    amount: number
    gstrate: number | null
    dealer: string
    status: $Enums.Status | null
    proof: string | null
    type: $Enums.Typetrans
    createdAt: Date
    financeId: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    gstrate?: boolean
    dealer?: boolean
    status?: boolean
    proof?: boolean
    type?: boolean
    createdAt?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    gstrate?: boolean
    dealer?: boolean
    status?: boolean
    proof?: boolean
    type?: boolean
    createdAt?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    gstrate?: boolean
    dealer?: boolean
    status?: boolean
    proof?: boolean
    type?: boolean
    createdAt?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    gstrate?: boolean
    dealer?: boolean
    status?: boolean
    proof?: boolean
    type?: boolean
    createdAt?: boolean
    financeId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "gstrate" | "dealer" | "status" | "proof" | "type" | "createdAt" | "financeId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      finance: Prisma.$FinancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      gstrate: number | null
      dealer: string
      status: $Enums.Status | null
      proof: string | null
      type: $Enums.Typetrans
      createdAt: Date
      financeId: string
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    finance<T extends FinanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinanceDefaultArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly gstrate: FieldRef<"Transaction", 'Int'>
    readonly dealer: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'Status'>
    readonly proof: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'Typetrans'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly financeId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Finance
   */

  export type AggregateFinance = {
    _count: FinanceCountAggregateOutputType | null
    _avg: FinanceAvgAggregateOutputType | null
    _sum: FinanceSumAggregateOutputType | null
    _min: FinanceMinAggregateOutputType | null
    _max: FinanceMaxAggregateOutputType | null
  }

  export type FinanceAvgAggregateOutputType = {
    income: number | null
    expenditure: number | null
    budget: number | null
    balance: number | null
  }

  export type FinanceSumAggregateOutputType = {
    income: number | null
    expenditure: number | null
    budget: number | null
    balance: number | null
  }

  export type FinanceMinAggregateOutputType = {
    id: string | null
    income: number | null
    expenditure: number | null
    budget: number | null
    balance: number | null
    MPIN: string | null
  }

  export type FinanceMaxAggregateOutputType = {
    id: string | null
    income: number | null
    expenditure: number | null
    budget: number | null
    balance: number | null
    MPIN: string | null
  }

  export type FinanceCountAggregateOutputType = {
    id: number
    income: number
    expenditure: number
    budget: number
    balance: number
    MPIN: number
    _all: number
  }


  export type FinanceAvgAggregateInputType = {
    income?: true
    expenditure?: true
    budget?: true
    balance?: true
  }

  export type FinanceSumAggregateInputType = {
    income?: true
    expenditure?: true
    budget?: true
    balance?: true
  }

  export type FinanceMinAggregateInputType = {
    id?: true
    income?: true
    expenditure?: true
    budget?: true
    balance?: true
    MPIN?: true
  }

  export type FinanceMaxAggregateInputType = {
    id?: true
    income?: true
    expenditure?: true
    budget?: true
    balance?: true
    MPIN?: true
  }

  export type FinanceCountAggregateInputType = {
    id?: true
    income?: true
    expenditure?: true
    budget?: true
    balance?: true
    MPIN?: true
    _all?: true
  }

  export type FinanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Finance to aggregate.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Finances
    **/
    _count?: true | FinanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinanceMaxAggregateInputType
  }

  export type GetFinanceAggregateType<T extends FinanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFinance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinance[P]>
      : GetScalarType<T[P], AggregateFinance[P]>
  }




  export type FinanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinanceWhereInput
    orderBy?: FinanceOrderByWithAggregationInput | FinanceOrderByWithAggregationInput[]
    by: FinanceScalarFieldEnum[] | FinanceScalarFieldEnum
    having?: FinanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinanceCountAggregateInputType | true
    _avg?: FinanceAvgAggregateInputType
    _sum?: FinanceSumAggregateInputType
    _min?: FinanceMinAggregateInputType
    _max?: FinanceMaxAggregateInputType
  }

  export type FinanceGroupByOutputType = {
    id: string
    income: number | null
    expenditure: number | null
    budget: number | null
    balance: number | null
    MPIN: string | null
    _count: FinanceCountAggregateOutputType | null
    _avg: FinanceAvgAggregateOutputType | null
    _sum: FinanceSumAggregateOutputType | null
    _min: FinanceMinAggregateOutputType | null
    _max: FinanceMaxAggregateOutputType | null
  }

  type GetFinanceGroupByPayload<T extends FinanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinanceGroupByOutputType[P]>
            : GetScalarType<T[P], FinanceGroupByOutputType[P]>
        }
      >
    >


  export type FinanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    income?: boolean
    expenditure?: boolean
    budget?: boolean
    balance?: boolean
    MPIN?: boolean
    transaction?: boolean | Finance$transactionArgs<ExtArgs>
    finance?: boolean | Finance$financeArgs<ExtArgs>
    notes?: boolean | Finance$notesArgs<ExtArgs>
    remainder?: boolean | Finance$remainderArgs<ExtArgs>
    _count?: boolean | FinanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    income?: boolean
    expenditure?: boolean
    budget?: boolean
    balance?: boolean
    MPIN?: boolean
    finance?: boolean | Finance$financeArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    income?: boolean
    expenditure?: boolean
    budget?: boolean
    balance?: boolean
    MPIN?: boolean
    finance?: boolean | Finance$financeArgs<ExtArgs>
  }, ExtArgs["result"]["finance"]>

  export type FinanceSelectScalar = {
    id?: boolean
    income?: boolean
    expenditure?: boolean
    budget?: boolean
    balance?: boolean
    MPIN?: boolean
  }

  export type FinanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "income" | "expenditure" | "budget" | "balance" | "MPIN", ExtArgs["result"]["finance"]>
  export type FinanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Finance$transactionArgs<ExtArgs>
    finance?: boolean | Finance$financeArgs<ExtArgs>
    notes?: boolean | Finance$notesArgs<ExtArgs>
    remainder?: boolean | Finance$remainderArgs<ExtArgs>
    _count?: boolean | FinanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | Finance$financeArgs<ExtArgs>
  }
  export type FinanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | Finance$financeArgs<ExtArgs>
  }

  export type $FinancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Finance"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
      finance: Prisma.$ProjectPayload<ExtArgs> | null
      notes: Prisma.$NotePayload<ExtArgs>[]
      remainder: Prisma.$RemaindersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      income: number | null
      expenditure: number | null
      budget: number | null
      balance: number | null
      MPIN: string | null
    }, ExtArgs["result"]["finance"]>
    composites: {}
  }

  type FinanceGetPayload<S extends boolean | null | undefined | FinanceDefaultArgs> = $Result.GetResult<Prisma.$FinancePayload, S>

  type FinanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinanceCountAggregateInputType | true
    }

  export interface FinanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Finance'], meta: { name: 'Finance' } }
    /**
     * Find zero or one Finance that matches the filter.
     * @param {FinanceFindUniqueArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinanceFindUniqueArgs>(args: SelectSubset<T, FinanceFindUniqueArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Finance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinanceFindUniqueOrThrowArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FinanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindFirstArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinanceFindFirstArgs>(args?: SelectSubset<T, FinanceFindFirstArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindFirstOrThrowArgs} args - Arguments to find a Finance
     * @example
     * // Get one Finance
     * const finance = await prisma.finance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FinanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Finances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Finances
     * const finances = await prisma.finance.findMany()
     * 
     * // Get first 10 Finances
     * const finances = await prisma.finance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financeWithIdOnly = await prisma.finance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinanceFindManyArgs>(args?: SelectSubset<T, FinanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Finance.
     * @param {FinanceCreateArgs} args - Arguments to create a Finance.
     * @example
     * // Create one Finance
     * const Finance = await prisma.finance.create({
     *   data: {
     *     // ... data to create a Finance
     *   }
     * })
     * 
     */
    create<T extends FinanceCreateArgs>(args: SelectSubset<T, FinanceCreateArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Finances.
     * @param {FinanceCreateManyArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finance = await prisma.finance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinanceCreateManyArgs>(args?: SelectSubset<T, FinanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Finances and returns the data saved in the database.
     * @param {FinanceCreateManyAndReturnArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finance = await prisma.finance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Finances and only return the `id`
     * const financeWithIdOnly = await prisma.finance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinanceCreateManyAndReturnArgs>(args?: SelectSubset<T, FinanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Finance.
     * @param {FinanceDeleteArgs} args - Arguments to delete one Finance.
     * @example
     * // Delete one Finance
     * const Finance = await prisma.finance.delete({
     *   where: {
     *     // ... filter to delete one Finance
     *   }
     * })
     * 
     */
    delete<T extends FinanceDeleteArgs>(args: SelectSubset<T, FinanceDeleteArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Finance.
     * @param {FinanceUpdateArgs} args - Arguments to update one Finance.
     * @example
     * // Update one Finance
     * const finance = await prisma.finance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinanceUpdateArgs>(args: SelectSubset<T, FinanceUpdateArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Finances.
     * @param {FinanceDeleteManyArgs} args - Arguments to filter Finances to delete.
     * @example
     * // Delete a few Finances
     * const { count } = await prisma.finance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinanceDeleteManyArgs>(args?: SelectSubset<T, FinanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Finances
     * const finance = await prisma.finance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinanceUpdateManyArgs>(args: SelectSubset<T, FinanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances and returns the data updated in the database.
     * @param {FinanceUpdateManyAndReturnArgs} args - Arguments to update many Finances.
     * @example
     * // Update many Finances
     * const finance = await prisma.finance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Finances and only return the `id`
     * const financeWithIdOnly = await prisma.finance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinanceUpdateManyAndReturnArgs>(args: SelectSubset<T, FinanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Finance.
     * @param {FinanceUpsertArgs} args - Arguments to update or create a Finance.
     * @example
     * // Update or create a Finance
     * const finance = await prisma.finance.upsert({
     *   create: {
     *     // ... data to create a Finance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Finance we want to update
     *   }
     * })
     */
    upsert<T extends FinanceUpsertArgs>(args: SelectSubset<T, FinanceUpsertArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceCountArgs} args - Arguments to filter Finances to count.
     * @example
     * // Count the number of Finances
     * const count = await prisma.finance.count({
     *   where: {
     *     // ... the filter for the Finances we want to count
     *   }
     * })
    **/
    count<T extends FinanceCountArgs>(
      args?: Subset<T, FinanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Finance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinanceAggregateArgs>(args: Subset<T, FinanceAggregateArgs>): Prisma.PrismaPromise<GetFinanceAggregateType<T>>

    /**
     * Group by Finance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinanceGroupByArgs['orderBy'] }
        : { orderBy?: FinanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Finance model
   */
  readonly fields: FinanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Finance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends Finance$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Finance$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finance<T extends Finance$financeArgs<ExtArgs> = {}>(args?: Subset<T, Finance$financeArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notes<T extends Finance$notesArgs<ExtArgs> = {}>(args?: Subset<T, Finance$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    remainder<T extends Finance$remainderArgs<ExtArgs> = {}>(args?: Subset<T, Finance$remainderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Finance model
   */
  interface FinanceFieldRefs {
    readonly id: FieldRef<"Finance", 'String'>
    readonly income: FieldRef<"Finance", 'Int'>
    readonly expenditure: FieldRef<"Finance", 'Int'>
    readonly budget: FieldRef<"Finance", 'Int'>
    readonly balance: FieldRef<"Finance", 'Int'>
    readonly MPIN: FieldRef<"Finance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Finance findUnique
   */
  export type FinanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance findUniqueOrThrow
   */
  export type FinanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance findFirst
   */
  export type FinanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Finances.
     */
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance findFirstOrThrow
   */
  export type FinanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finance to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Finances.
     */
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance findMany
   */
  export type FinanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter, which Finances to fetch.
     */
    where?: FinanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Finances to fetch.
     */
    orderBy?: FinanceOrderByWithRelationInput | FinanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Finances.
     */
    cursor?: FinanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Finances.
     */
    skip?: number
    distinct?: FinanceScalarFieldEnum | FinanceScalarFieldEnum[]
  }

  /**
   * Finance create
   */
  export type FinanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Finance.
     */
    data?: XOR<FinanceCreateInput, FinanceUncheckedCreateInput>
  }

  /**
   * Finance createMany
   */
  export type FinanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Finances.
     */
    data: FinanceCreateManyInput | FinanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Finance createManyAndReturn
   */
  export type FinanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * The data used to create many Finances.
     */
    data: FinanceCreateManyInput | FinanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finance update
   */
  export type FinanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Finance.
     */
    data: XOR<FinanceUpdateInput, FinanceUncheckedUpdateInput>
    /**
     * Choose, which Finance to update.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance updateMany
   */
  export type FinanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Finances.
     */
    data: XOR<FinanceUpdateManyMutationInput, FinanceUncheckedUpdateManyInput>
    /**
     * Filter which Finances to update
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to update.
     */
    limit?: number
  }

  /**
   * Finance updateManyAndReturn
   */
  export type FinanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * The data used to update Finances.
     */
    data: XOR<FinanceUpdateManyMutationInput, FinanceUncheckedUpdateManyInput>
    /**
     * Filter which Finances to update
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finance upsert
   */
  export type FinanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Finance to update in case it exists.
     */
    where: FinanceWhereUniqueInput
    /**
     * In case the Finance found by the `where` argument doesn't exist, create a new Finance with this data.
     */
    create: XOR<FinanceCreateInput, FinanceUncheckedCreateInput>
    /**
     * In case the Finance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinanceUpdateInput, FinanceUncheckedUpdateInput>
  }

  /**
   * Finance delete
   */
  export type FinanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
    /**
     * Filter which Finance to delete.
     */
    where: FinanceWhereUniqueInput
  }

  /**
   * Finance deleteMany
   */
  export type FinanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Finances to delete
     */
    where?: FinanceWhereInput
    /**
     * Limit how many Finances to delete.
     */
    limit?: number
  }

  /**
   * Finance.transaction
   */
  export type Finance$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Finance.finance
   */
  export type Finance$financeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Finance.notes
   */
  export type Finance$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Finance.remainder
   */
  export type Finance$remainderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    where?: RemaindersWhereInput
    orderBy?: RemaindersOrderByWithRelationInput | RemaindersOrderByWithRelationInput[]
    cursor?: RemaindersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemaindersScalarFieldEnum | RemaindersScalarFieldEnum[]
  }

  /**
   * Finance without action
   */
  export type FinanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finance
     */
    select?: FinanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finance
     */
    omit?: FinanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinanceInclude<ExtArgs> | null
  }


  /**
   * Model Remainders
   */

  export type AggregateRemainders = {
    _count: RemaindersCountAggregateOutputType | null
    _avg: RemaindersAvgAggregateOutputType | null
    _sum: RemaindersSumAggregateOutputType | null
    _min: RemaindersMinAggregateOutputType | null
    _max: RemaindersMaxAggregateOutputType | null
  }

  export type RemaindersAvgAggregateOutputType = {
    amount: number | null
  }

  export type RemaindersSumAggregateOutputType = {
    amount: number | null
  }

  export type RemaindersMinAggregateOutputType = {
    id: string | null
    amount: number | null
    dealer: string | null
    date: Date | null
    financeId: string | null
  }

  export type RemaindersMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    dealer: string | null
    date: Date | null
    financeId: string | null
  }

  export type RemaindersCountAggregateOutputType = {
    id: number
    amount: number
    dealer: number
    date: number
    financeId: number
    _all: number
  }


  export type RemaindersAvgAggregateInputType = {
    amount?: true
  }

  export type RemaindersSumAggregateInputType = {
    amount?: true
  }

  export type RemaindersMinAggregateInputType = {
    id?: true
    amount?: true
    dealer?: true
    date?: true
    financeId?: true
  }

  export type RemaindersMaxAggregateInputType = {
    id?: true
    amount?: true
    dealer?: true
    date?: true
    financeId?: true
  }

  export type RemaindersCountAggregateInputType = {
    id?: true
    amount?: true
    dealer?: true
    date?: true
    financeId?: true
    _all?: true
  }

  export type RemaindersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Remainders to aggregate.
     */
    where?: RemaindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Remainders to fetch.
     */
    orderBy?: RemaindersOrderByWithRelationInput | RemaindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemaindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Remainders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Remainders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Remainders
    **/
    _count?: true | RemaindersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemaindersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemaindersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemaindersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemaindersMaxAggregateInputType
  }

  export type GetRemaindersAggregateType<T extends RemaindersAggregateArgs> = {
        [P in keyof T & keyof AggregateRemainders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemainders[P]>
      : GetScalarType<T[P], AggregateRemainders[P]>
  }




  export type RemaindersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemaindersWhereInput
    orderBy?: RemaindersOrderByWithAggregationInput | RemaindersOrderByWithAggregationInput[]
    by: RemaindersScalarFieldEnum[] | RemaindersScalarFieldEnum
    having?: RemaindersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemaindersCountAggregateInputType | true
    _avg?: RemaindersAvgAggregateInputType
    _sum?: RemaindersSumAggregateInputType
    _min?: RemaindersMinAggregateInputType
    _max?: RemaindersMaxAggregateInputType
  }

  export type RemaindersGroupByOutputType = {
    id: string
    amount: number
    dealer: string
    date: Date
    financeId: string
    _count: RemaindersCountAggregateOutputType | null
    _avg: RemaindersAvgAggregateOutputType | null
    _sum: RemaindersSumAggregateOutputType | null
    _min: RemaindersMinAggregateOutputType | null
    _max: RemaindersMaxAggregateOutputType | null
  }

  type GetRemaindersGroupByPayload<T extends RemaindersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemaindersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemaindersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemaindersGroupByOutputType[P]>
            : GetScalarType<T[P], RemaindersGroupByOutputType[P]>
        }
      >
    >


  export type RemaindersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    dealer?: boolean
    date?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainders"]>

  export type RemaindersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    dealer?: boolean
    date?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainders"]>

  export type RemaindersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    dealer?: boolean
    date?: boolean
    financeId?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remainders"]>

  export type RemaindersSelectScalar = {
    id?: boolean
    amount?: boolean
    dealer?: boolean
    date?: boolean
    financeId?: boolean
  }

  export type RemaindersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "dealer" | "date" | "financeId", ExtArgs["result"]["remainders"]>
  export type RemaindersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type RemaindersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type RemaindersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }

  export type $RemaindersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Remainders"
    objects: {
      finance: Prisma.$FinancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      dealer: string
      date: Date
      financeId: string
    }, ExtArgs["result"]["remainders"]>
    composites: {}
  }

  type RemaindersGetPayload<S extends boolean | null | undefined | RemaindersDefaultArgs> = $Result.GetResult<Prisma.$RemaindersPayload, S>

  type RemaindersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemaindersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemaindersCountAggregateInputType | true
    }

  export interface RemaindersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Remainders'], meta: { name: 'Remainders' } }
    /**
     * Find zero or one Remainders that matches the filter.
     * @param {RemaindersFindUniqueArgs} args - Arguments to find a Remainders
     * @example
     * // Get one Remainders
     * const remainders = await prisma.remainders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemaindersFindUniqueArgs>(args: SelectSubset<T, RemaindersFindUniqueArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Remainders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemaindersFindUniqueOrThrowArgs} args - Arguments to find a Remainders
     * @example
     * // Get one Remainders
     * const remainders = await prisma.remainders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemaindersFindUniqueOrThrowArgs>(args: SelectSubset<T, RemaindersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Remainders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersFindFirstArgs} args - Arguments to find a Remainders
     * @example
     * // Get one Remainders
     * const remainders = await prisma.remainders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemaindersFindFirstArgs>(args?: SelectSubset<T, RemaindersFindFirstArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Remainders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersFindFirstOrThrowArgs} args - Arguments to find a Remainders
     * @example
     * // Get one Remainders
     * const remainders = await prisma.remainders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemaindersFindFirstOrThrowArgs>(args?: SelectSubset<T, RemaindersFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Remainders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Remainders
     * const remainders = await prisma.remainders.findMany()
     * 
     * // Get first 10 Remainders
     * const remainders = await prisma.remainders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remaindersWithIdOnly = await prisma.remainders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemaindersFindManyArgs>(args?: SelectSubset<T, RemaindersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Remainders.
     * @param {RemaindersCreateArgs} args - Arguments to create a Remainders.
     * @example
     * // Create one Remainders
     * const Remainders = await prisma.remainders.create({
     *   data: {
     *     // ... data to create a Remainders
     *   }
     * })
     * 
     */
    create<T extends RemaindersCreateArgs>(args: SelectSubset<T, RemaindersCreateArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Remainders.
     * @param {RemaindersCreateManyArgs} args - Arguments to create many Remainders.
     * @example
     * // Create many Remainders
     * const remainders = await prisma.remainders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemaindersCreateManyArgs>(args?: SelectSubset<T, RemaindersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Remainders and returns the data saved in the database.
     * @param {RemaindersCreateManyAndReturnArgs} args - Arguments to create many Remainders.
     * @example
     * // Create many Remainders
     * const remainders = await prisma.remainders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Remainders and only return the `id`
     * const remaindersWithIdOnly = await prisma.remainders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemaindersCreateManyAndReturnArgs>(args?: SelectSubset<T, RemaindersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Remainders.
     * @param {RemaindersDeleteArgs} args - Arguments to delete one Remainders.
     * @example
     * // Delete one Remainders
     * const Remainders = await prisma.remainders.delete({
     *   where: {
     *     // ... filter to delete one Remainders
     *   }
     * })
     * 
     */
    delete<T extends RemaindersDeleteArgs>(args: SelectSubset<T, RemaindersDeleteArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Remainders.
     * @param {RemaindersUpdateArgs} args - Arguments to update one Remainders.
     * @example
     * // Update one Remainders
     * const remainders = await prisma.remainders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemaindersUpdateArgs>(args: SelectSubset<T, RemaindersUpdateArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Remainders.
     * @param {RemaindersDeleteManyArgs} args - Arguments to filter Remainders to delete.
     * @example
     * // Delete a few Remainders
     * const { count } = await prisma.remainders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemaindersDeleteManyArgs>(args?: SelectSubset<T, RemaindersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Remainders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Remainders
     * const remainders = await prisma.remainders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemaindersUpdateManyArgs>(args: SelectSubset<T, RemaindersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Remainders and returns the data updated in the database.
     * @param {RemaindersUpdateManyAndReturnArgs} args - Arguments to update many Remainders.
     * @example
     * // Update many Remainders
     * const remainders = await prisma.remainders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Remainders and only return the `id`
     * const remaindersWithIdOnly = await prisma.remainders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RemaindersUpdateManyAndReturnArgs>(args: SelectSubset<T, RemaindersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Remainders.
     * @param {RemaindersUpsertArgs} args - Arguments to update or create a Remainders.
     * @example
     * // Update or create a Remainders
     * const remainders = await prisma.remainders.upsert({
     *   create: {
     *     // ... data to create a Remainders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Remainders we want to update
     *   }
     * })
     */
    upsert<T extends RemaindersUpsertArgs>(args: SelectSubset<T, RemaindersUpsertArgs<ExtArgs>>): Prisma__RemaindersClient<$Result.GetResult<Prisma.$RemaindersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Remainders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersCountArgs} args - Arguments to filter Remainders to count.
     * @example
     * // Count the number of Remainders
     * const count = await prisma.remainders.count({
     *   where: {
     *     // ... the filter for the Remainders we want to count
     *   }
     * })
    **/
    count<T extends RemaindersCountArgs>(
      args?: Subset<T, RemaindersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemaindersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Remainders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemaindersAggregateArgs>(args: Subset<T, RemaindersAggregateArgs>): Prisma.PrismaPromise<GetRemaindersAggregateType<T>>

    /**
     * Group by Remainders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemaindersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemaindersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemaindersGroupByArgs['orderBy'] }
        : { orderBy?: RemaindersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemaindersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemaindersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Remainders model
   */
  readonly fields: RemaindersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Remainders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemaindersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    finance<T extends FinanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinanceDefaultArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Remainders model
   */
  interface RemaindersFieldRefs {
    readonly id: FieldRef<"Remainders", 'String'>
    readonly amount: FieldRef<"Remainders", 'Int'>
    readonly dealer: FieldRef<"Remainders", 'String'>
    readonly date: FieldRef<"Remainders", 'DateTime'>
    readonly financeId: FieldRef<"Remainders", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Remainders findUnique
   */
  export type RemaindersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter, which Remainders to fetch.
     */
    where: RemaindersWhereUniqueInput
  }

  /**
   * Remainders findUniqueOrThrow
   */
  export type RemaindersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter, which Remainders to fetch.
     */
    where: RemaindersWhereUniqueInput
  }

  /**
   * Remainders findFirst
   */
  export type RemaindersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter, which Remainders to fetch.
     */
    where?: RemaindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Remainders to fetch.
     */
    orderBy?: RemaindersOrderByWithRelationInput | RemaindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Remainders.
     */
    cursor?: RemaindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Remainders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Remainders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Remainders.
     */
    distinct?: RemaindersScalarFieldEnum | RemaindersScalarFieldEnum[]
  }

  /**
   * Remainders findFirstOrThrow
   */
  export type RemaindersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter, which Remainders to fetch.
     */
    where?: RemaindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Remainders to fetch.
     */
    orderBy?: RemaindersOrderByWithRelationInput | RemaindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Remainders.
     */
    cursor?: RemaindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Remainders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Remainders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Remainders.
     */
    distinct?: RemaindersScalarFieldEnum | RemaindersScalarFieldEnum[]
  }

  /**
   * Remainders findMany
   */
  export type RemaindersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter, which Remainders to fetch.
     */
    where?: RemaindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Remainders to fetch.
     */
    orderBy?: RemaindersOrderByWithRelationInput | RemaindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Remainders.
     */
    cursor?: RemaindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Remainders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Remainders.
     */
    skip?: number
    distinct?: RemaindersScalarFieldEnum | RemaindersScalarFieldEnum[]
  }

  /**
   * Remainders create
   */
  export type RemaindersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * The data needed to create a Remainders.
     */
    data: XOR<RemaindersCreateInput, RemaindersUncheckedCreateInput>
  }

  /**
   * Remainders createMany
   */
  export type RemaindersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Remainders.
     */
    data: RemaindersCreateManyInput | RemaindersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Remainders createManyAndReturn
   */
  export type RemaindersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * The data used to create many Remainders.
     */
    data: RemaindersCreateManyInput | RemaindersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Remainders update
   */
  export type RemaindersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * The data needed to update a Remainders.
     */
    data: XOR<RemaindersUpdateInput, RemaindersUncheckedUpdateInput>
    /**
     * Choose, which Remainders to update.
     */
    where: RemaindersWhereUniqueInput
  }

  /**
   * Remainders updateMany
   */
  export type RemaindersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Remainders.
     */
    data: XOR<RemaindersUpdateManyMutationInput, RemaindersUncheckedUpdateManyInput>
    /**
     * Filter which Remainders to update
     */
    where?: RemaindersWhereInput
    /**
     * Limit how many Remainders to update.
     */
    limit?: number
  }

  /**
   * Remainders updateManyAndReturn
   */
  export type RemaindersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * The data used to update Remainders.
     */
    data: XOR<RemaindersUpdateManyMutationInput, RemaindersUncheckedUpdateManyInput>
    /**
     * Filter which Remainders to update
     */
    where?: RemaindersWhereInput
    /**
     * Limit how many Remainders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Remainders upsert
   */
  export type RemaindersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * The filter to search for the Remainders to update in case it exists.
     */
    where: RemaindersWhereUniqueInput
    /**
     * In case the Remainders found by the `where` argument doesn't exist, create a new Remainders with this data.
     */
    create: XOR<RemaindersCreateInput, RemaindersUncheckedCreateInput>
    /**
     * In case the Remainders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemaindersUpdateInput, RemaindersUncheckedUpdateInput>
  }

  /**
   * Remainders delete
   */
  export type RemaindersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
    /**
     * Filter which Remainders to delete.
     */
    where: RemaindersWhereUniqueInput
  }

  /**
   * Remainders deleteMany
   */
  export type RemaindersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Remainders to delete
     */
    where?: RemaindersWhereInput
    /**
     * Limit how many Remainders to delete.
     */
    limit?: number
  }

  /**
   * Remainders without action
   */
  export type RemaindersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Remainders
     */
    select?: RemaindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Remainders
     */
    omit?: RemaindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemaindersInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    financeId: string | null
    type: $Enums.NoteType | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    financeId: string | null
    type: $Enums.NoteType | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    financeId: number
    type: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    financeId?: true
    type?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    financeId?: true
    type?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    financeId?: true
    type?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    title: string | null
    content: string
    createdAt: Date
    financeId: string
    type: $Enums.NoteType | null
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    financeId?: boolean
    type?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    financeId?: boolean
    type?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    financeId?: boolean
    type?: boolean
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    financeId?: boolean
    type?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "createdAt" | "financeId" | "type", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }
  export type NoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    finance?: boolean | FinanceDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      finance: Prisma.$FinancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      content: string
      createdAt: Date
      financeId: string
      type: $Enums.NoteType | null
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NoteUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    finance<T extends FinanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FinanceDefaultArgs<ExtArgs>>): Prisma__FinanceClient<$Result.GetResult<Prisma.$FinancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly title: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly financeId: FieldRef<"Note", 'String'>
    readonly type: FieldRef<"Note", 'NoteType'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note updateManyAndReturn
   */
  export type NoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleMsg
   */

  export type AggregateScheduleMsg = {
    _count: ScheduleMsgCountAggregateOutputType | null
    _min: ScheduleMsgMinAggregateOutputType | null
    _max: ScheduleMsgMaxAggregateOutputType | null
  }

  export type ScheduleMsgMinAggregateOutputType = {
    id: string | null
    email: string | null
    phonenum: string | null
    Datetime: string | null
    type: $Enums.Msgtype | null
    text: string | null
    status: $Enums.ScheduleMsgStatus | null
    createdAt: Date | null
    projectId: string | null
  }

  export type ScheduleMsgMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phonenum: string | null
    Datetime: string | null
    type: $Enums.Msgtype | null
    text: string | null
    status: $Enums.ScheduleMsgStatus | null
    createdAt: Date | null
    projectId: string | null
  }

  export type ScheduleMsgCountAggregateOutputType = {
    id: number
    email: number
    phonenum: number
    Datetime: number
    type: number
    text: number
    status: number
    createdAt: number
    projectId: number
    _all: number
  }


  export type ScheduleMsgMinAggregateInputType = {
    id?: true
    email?: true
    phonenum?: true
    Datetime?: true
    type?: true
    text?: true
    status?: true
    createdAt?: true
    projectId?: true
  }

  export type ScheduleMsgMaxAggregateInputType = {
    id?: true
    email?: true
    phonenum?: true
    Datetime?: true
    type?: true
    text?: true
    status?: true
    createdAt?: true
    projectId?: true
  }

  export type ScheduleMsgCountAggregateInputType = {
    id?: true
    email?: true
    phonenum?: true
    Datetime?: true
    type?: true
    text?: true
    status?: true
    createdAt?: true
    projectId?: true
    _all?: true
  }

  export type ScheduleMsgAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleMsg to aggregate.
     */
    where?: ScheduleMsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleMsgs to fetch.
     */
    orderBy?: ScheduleMsgOrderByWithRelationInput | ScheduleMsgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleMsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleMsgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleMsgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleMsgs
    **/
    _count?: true | ScheduleMsgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMsgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMsgMaxAggregateInputType
  }

  export type GetScheduleMsgAggregateType<T extends ScheduleMsgAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleMsg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleMsg[P]>
      : GetScalarType<T[P], AggregateScheduleMsg[P]>
  }




  export type ScheduleMsgGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleMsgWhereInput
    orderBy?: ScheduleMsgOrderByWithAggregationInput | ScheduleMsgOrderByWithAggregationInput[]
    by: ScheduleMsgScalarFieldEnum[] | ScheduleMsgScalarFieldEnum
    having?: ScheduleMsgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleMsgCountAggregateInputType | true
    _min?: ScheduleMsgMinAggregateInputType
    _max?: ScheduleMsgMaxAggregateInputType
  }

  export type ScheduleMsgGroupByOutputType = {
    id: string
    email: string | null
    phonenum: string | null
    Datetime: string | null
    type: $Enums.Msgtype | null
    text: string | null
    status: $Enums.ScheduleMsgStatus | null
    createdAt: Date
    projectId: string
    _count: ScheduleMsgCountAggregateOutputType | null
    _min: ScheduleMsgMinAggregateOutputType | null
    _max: ScheduleMsgMaxAggregateOutputType | null
  }

  type GetScheduleMsgGroupByPayload<T extends ScheduleMsgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleMsgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleMsgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleMsgGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleMsgGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleMsgSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phonenum?: boolean
    Datetime?: boolean
    type?: boolean
    text?: boolean
    status?: boolean
    createdAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleMsg"]>

  export type ScheduleMsgSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phonenum?: boolean
    Datetime?: boolean
    type?: boolean
    text?: boolean
    status?: boolean
    createdAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleMsg"]>

  export type ScheduleMsgSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phonenum?: boolean
    Datetime?: boolean
    type?: boolean
    text?: boolean
    status?: boolean
    createdAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleMsg"]>

  export type ScheduleMsgSelectScalar = {
    id?: boolean
    email?: boolean
    phonenum?: boolean
    Datetime?: boolean
    type?: boolean
    text?: boolean
    status?: boolean
    createdAt?: boolean
    projectId?: boolean
  }

  export type ScheduleMsgOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phonenum" | "Datetime" | "type" | "text" | "status" | "createdAt" | "projectId", ExtArgs["result"]["scheduleMsg"]>
  export type ScheduleMsgInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ScheduleMsgIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ScheduleMsgIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ScheduleMsgPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleMsg"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phonenum: string | null
      Datetime: string | null
      type: $Enums.Msgtype | null
      text: string | null
      status: $Enums.ScheduleMsgStatus | null
      createdAt: Date
      projectId: string
    }, ExtArgs["result"]["scheduleMsg"]>
    composites: {}
  }

  type ScheduleMsgGetPayload<S extends boolean | null | undefined | ScheduleMsgDefaultArgs> = $Result.GetResult<Prisma.$ScheduleMsgPayload, S>

  type ScheduleMsgCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleMsgFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleMsgCountAggregateInputType | true
    }

  export interface ScheduleMsgDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleMsg'], meta: { name: 'ScheduleMsg' } }
    /**
     * Find zero or one ScheduleMsg that matches the filter.
     * @param {ScheduleMsgFindUniqueArgs} args - Arguments to find a ScheduleMsg
     * @example
     * // Get one ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleMsgFindUniqueArgs>(args: SelectSubset<T, ScheduleMsgFindUniqueArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleMsg that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleMsgFindUniqueOrThrowArgs} args - Arguments to find a ScheduleMsg
     * @example
     * // Get one ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleMsgFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleMsgFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleMsg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgFindFirstArgs} args - Arguments to find a ScheduleMsg
     * @example
     * // Get one ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleMsgFindFirstArgs>(args?: SelectSubset<T, ScheduleMsgFindFirstArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleMsg that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgFindFirstOrThrowArgs} args - Arguments to find a ScheduleMsg
     * @example
     * // Get one ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleMsgFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleMsgFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleMsgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleMsgs
     * const scheduleMsgs = await prisma.scheduleMsg.findMany()
     * 
     * // Get first 10 ScheduleMsgs
     * const scheduleMsgs = await prisma.scheduleMsg.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleMsgWithIdOnly = await prisma.scheduleMsg.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleMsgFindManyArgs>(args?: SelectSubset<T, ScheduleMsgFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleMsg.
     * @param {ScheduleMsgCreateArgs} args - Arguments to create a ScheduleMsg.
     * @example
     * // Create one ScheduleMsg
     * const ScheduleMsg = await prisma.scheduleMsg.create({
     *   data: {
     *     // ... data to create a ScheduleMsg
     *   }
     * })
     * 
     */
    create<T extends ScheduleMsgCreateArgs>(args: SelectSubset<T, ScheduleMsgCreateArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleMsgs.
     * @param {ScheduleMsgCreateManyArgs} args - Arguments to create many ScheduleMsgs.
     * @example
     * // Create many ScheduleMsgs
     * const scheduleMsg = await prisma.scheduleMsg.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleMsgCreateManyArgs>(args?: SelectSubset<T, ScheduleMsgCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleMsgs and returns the data saved in the database.
     * @param {ScheduleMsgCreateManyAndReturnArgs} args - Arguments to create many ScheduleMsgs.
     * @example
     * // Create many ScheduleMsgs
     * const scheduleMsg = await prisma.scheduleMsg.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleMsgs and only return the `id`
     * const scheduleMsgWithIdOnly = await prisma.scheduleMsg.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleMsgCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleMsgCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleMsg.
     * @param {ScheduleMsgDeleteArgs} args - Arguments to delete one ScheduleMsg.
     * @example
     * // Delete one ScheduleMsg
     * const ScheduleMsg = await prisma.scheduleMsg.delete({
     *   where: {
     *     // ... filter to delete one ScheduleMsg
     *   }
     * })
     * 
     */
    delete<T extends ScheduleMsgDeleteArgs>(args: SelectSubset<T, ScheduleMsgDeleteArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleMsg.
     * @param {ScheduleMsgUpdateArgs} args - Arguments to update one ScheduleMsg.
     * @example
     * // Update one ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleMsgUpdateArgs>(args: SelectSubset<T, ScheduleMsgUpdateArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleMsgs.
     * @param {ScheduleMsgDeleteManyArgs} args - Arguments to filter ScheduleMsgs to delete.
     * @example
     * // Delete a few ScheduleMsgs
     * const { count } = await prisma.scheduleMsg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleMsgDeleteManyArgs>(args?: SelectSubset<T, ScheduleMsgDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleMsgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleMsgs
     * const scheduleMsg = await prisma.scheduleMsg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleMsgUpdateManyArgs>(args: SelectSubset<T, ScheduleMsgUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleMsgs and returns the data updated in the database.
     * @param {ScheduleMsgUpdateManyAndReturnArgs} args - Arguments to update many ScheduleMsgs.
     * @example
     * // Update many ScheduleMsgs
     * const scheduleMsg = await prisma.scheduleMsg.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleMsgs and only return the `id`
     * const scheduleMsgWithIdOnly = await prisma.scheduleMsg.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleMsgUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleMsgUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleMsg.
     * @param {ScheduleMsgUpsertArgs} args - Arguments to update or create a ScheduleMsg.
     * @example
     * // Update or create a ScheduleMsg
     * const scheduleMsg = await prisma.scheduleMsg.upsert({
     *   create: {
     *     // ... data to create a ScheduleMsg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleMsg we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleMsgUpsertArgs>(args: SelectSubset<T, ScheduleMsgUpsertArgs<ExtArgs>>): Prisma__ScheduleMsgClient<$Result.GetResult<Prisma.$ScheduleMsgPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleMsgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgCountArgs} args - Arguments to filter ScheduleMsgs to count.
     * @example
     * // Count the number of ScheduleMsgs
     * const count = await prisma.scheduleMsg.count({
     *   where: {
     *     // ... the filter for the ScheduleMsgs we want to count
     *   }
     * })
    **/
    count<T extends ScheduleMsgCountArgs>(
      args?: Subset<T, ScheduleMsgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleMsgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleMsg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleMsgAggregateArgs>(args: Subset<T, ScheduleMsgAggregateArgs>): Prisma.PrismaPromise<GetScheduleMsgAggregateType<T>>

    /**
     * Group by ScheduleMsg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleMsgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleMsgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleMsgGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleMsgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleMsgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleMsgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleMsg model
   */
  readonly fields: ScheduleMsgFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleMsg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleMsgClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleMsg model
   */
  interface ScheduleMsgFieldRefs {
    readonly id: FieldRef<"ScheduleMsg", 'String'>
    readonly email: FieldRef<"ScheduleMsg", 'String'>
    readonly phonenum: FieldRef<"ScheduleMsg", 'String'>
    readonly Datetime: FieldRef<"ScheduleMsg", 'String'>
    readonly type: FieldRef<"ScheduleMsg", 'Msgtype'>
    readonly text: FieldRef<"ScheduleMsg", 'String'>
    readonly status: FieldRef<"ScheduleMsg", 'ScheduleMsgStatus'>
    readonly createdAt: FieldRef<"ScheduleMsg", 'DateTime'>
    readonly projectId: FieldRef<"ScheduleMsg", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleMsg findUnique
   */
  export type ScheduleMsgFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleMsg to fetch.
     */
    where: ScheduleMsgWhereUniqueInput
  }

  /**
   * ScheduleMsg findUniqueOrThrow
   */
  export type ScheduleMsgFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleMsg to fetch.
     */
    where: ScheduleMsgWhereUniqueInput
  }

  /**
   * ScheduleMsg findFirst
   */
  export type ScheduleMsgFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleMsg to fetch.
     */
    where?: ScheduleMsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleMsgs to fetch.
     */
    orderBy?: ScheduleMsgOrderByWithRelationInput | ScheduleMsgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleMsgs.
     */
    cursor?: ScheduleMsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleMsgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleMsgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleMsgs.
     */
    distinct?: ScheduleMsgScalarFieldEnum | ScheduleMsgScalarFieldEnum[]
  }

  /**
   * ScheduleMsg findFirstOrThrow
   */
  export type ScheduleMsgFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleMsg to fetch.
     */
    where?: ScheduleMsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleMsgs to fetch.
     */
    orderBy?: ScheduleMsgOrderByWithRelationInput | ScheduleMsgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleMsgs.
     */
    cursor?: ScheduleMsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleMsgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleMsgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleMsgs.
     */
    distinct?: ScheduleMsgScalarFieldEnum | ScheduleMsgScalarFieldEnum[]
  }

  /**
   * ScheduleMsg findMany
   */
  export type ScheduleMsgFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleMsgs to fetch.
     */
    where?: ScheduleMsgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleMsgs to fetch.
     */
    orderBy?: ScheduleMsgOrderByWithRelationInput | ScheduleMsgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleMsgs.
     */
    cursor?: ScheduleMsgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleMsgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleMsgs.
     */
    skip?: number
    distinct?: ScheduleMsgScalarFieldEnum | ScheduleMsgScalarFieldEnum[]
  }

  /**
   * ScheduleMsg create
   */
  export type ScheduleMsgCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleMsg.
     */
    data: XOR<ScheduleMsgCreateInput, ScheduleMsgUncheckedCreateInput>
  }

  /**
   * ScheduleMsg createMany
   */
  export type ScheduleMsgCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleMsgs.
     */
    data: ScheduleMsgCreateManyInput | ScheduleMsgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleMsg createManyAndReturn
   */
  export type ScheduleMsgCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleMsgs.
     */
    data: ScheduleMsgCreateManyInput | ScheduleMsgCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleMsg update
   */
  export type ScheduleMsgUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleMsg.
     */
    data: XOR<ScheduleMsgUpdateInput, ScheduleMsgUncheckedUpdateInput>
    /**
     * Choose, which ScheduleMsg to update.
     */
    where: ScheduleMsgWhereUniqueInput
  }

  /**
   * ScheduleMsg updateMany
   */
  export type ScheduleMsgUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleMsgs.
     */
    data: XOR<ScheduleMsgUpdateManyMutationInput, ScheduleMsgUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleMsgs to update
     */
    where?: ScheduleMsgWhereInput
    /**
     * Limit how many ScheduleMsgs to update.
     */
    limit?: number
  }

  /**
   * ScheduleMsg updateManyAndReturn
   */
  export type ScheduleMsgUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleMsgs.
     */
    data: XOR<ScheduleMsgUpdateManyMutationInput, ScheduleMsgUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleMsgs to update
     */
    where?: ScheduleMsgWhereInput
    /**
     * Limit how many ScheduleMsgs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleMsg upsert
   */
  export type ScheduleMsgUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleMsg to update in case it exists.
     */
    where: ScheduleMsgWhereUniqueInput
    /**
     * In case the ScheduleMsg found by the `where` argument doesn't exist, create a new ScheduleMsg with this data.
     */
    create: XOR<ScheduleMsgCreateInput, ScheduleMsgUncheckedCreateInput>
    /**
     * In case the ScheduleMsg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleMsgUpdateInput, ScheduleMsgUncheckedUpdateInput>
  }

  /**
   * ScheduleMsg delete
   */
  export type ScheduleMsgDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
    /**
     * Filter which ScheduleMsg to delete.
     */
    where: ScheduleMsgWhereUniqueInput
  }

  /**
   * ScheduleMsg deleteMany
   */
  export type ScheduleMsgDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleMsgs to delete
     */
    where?: ScheduleMsgWhereInput
    /**
     * Limit how many ScheduleMsgs to delete.
     */
    limit?: number
  }

  /**
   * ScheduleMsg without action
   */
  export type ScheduleMsgDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleMsg
     */
    select?: ScheduleMsgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleMsg
     */
    omit?: ScheduleMsgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleMsgInclude<ExtArgs> | null
  }


  /**
   * Model SellerAccount
   */

  export type AggregateSellerAccount = {
    _count: SellerAccountCountAggregateOutputType | null
    _min: SellerAccountMinAggregateOutputType | null
    _max: SellerAccountMaxAggregateOutputType | null
  }

  export type SellerAccountMinAggregateOutputType = {
    id: string | null
    sales: string | null
  }

  export type SellerAccountMaxAggregateOutputType = {
    id: string | null
    sales: string | null
  }

  export type SellerAccountCountAggregateOutputType = {
    id: number
    sales: number
    _all: number
  }


  export type SellerAccountMinAggregateInputType = {
    id?: true
    sales?: true
  }

  export type SellerAccountMaxAggregateInputType = {
    id?: true
    sales?: true
  }

  export type SellerAccountCountAggregateInputType = {
    id?: true
    sales?: true
    _all?: true
  }

  export type SellerAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerAccount to aggregate.
     */
    where?: SellerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerAccounts to fetch.
     */
    orderBy?: SellerAccountOrderByWithRelationInput | SellerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerAccounts
    **/
    _count?: true | SellerAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerAccountMaxAggregateInputType
  }

  export type GetSellerAccountAggregateType<T extends SellerAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerAccount[P]>
      : GetScalarType<T[P], AggregateSellerAccount[P]>
  }




  export type SellerAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerAccountWhereInput
    orderBy?: SellerAccountOrderByWithAggregationInput | SellerAccountOrderByWithAggregationInput[]
    by: SellerAccountScalarFieldEnum[] | SellerAccountScalarFieldEnum
    having?: SellerAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerAccountCountAggregateInputType | true
    _min?: SellerAccountMinAggregateInputType
    _max?: SellerAccountMaxAggregateInputType
  }

  export type SellerAccountGroupByOutputType = {
    id: string
    sales: string | null
    _count: SellerAccountCountAggregateOutputType | null
    _min: SellerAccountMinAggregateOutputType | null
    _max: SellerAccountMaxAggregateOutputType | null
  }

  type GetSellerAccountGroupByPayload<T extends SellerAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SellerAccountGroupByOutputType[P]>
        }
      >
    >


  export type SellerAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales?: boolean
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
    Product?: boolean | SellerAccount$ProductArgs<ExtArgs>
    Order?: boolean | SellerAccount$OrderArgs<ExtArgs>
    _count?: boolean | SellerAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellerAccount"]>

  export type SellerAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales?: boolean
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
  }, ExtArgs["result"]["sellerAccount"]>

  export type SellerAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales?: boolean
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
  }, ExtArgs["result"]["sellerAccount"]>

  export type SellerAccountSelectScalar = {
    id?: boolean
    sales?: boolean
  }

  export type SellerAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sales", ExtArgs["result"]["sellerAccount"]>
  export type SellerAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
    Product?: boolean | SellerAccount$ProductArgs<ExtArgs>
    Order?: boolean | SellerAccount$OrderArgs<ExtArgs>
    _count?: boolean | SellerAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SellerAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
  }
  export type SellerAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | SellerAccount$UserArgs<ExtArgs>
  }

  export type $SellerAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerAccount"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      Product: Prisma.$ProductsPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sales: string | null
    }, ExtArgs["result"]["sellerAccount"]>
    composites: {}
  }

  type SellerAccountGetPayload<S extends boolean | null | undefined | SellerAccountDefaultArgs> = $Result.GetResult<Prisma.$SellerAccountPayload, S>

  type SellerAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerAccountCountAggregateInputType | true
    }

  export interface SellerAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerAccount'], meta: { name: 'SellerAccount' } }
    /**
     * Find zero or one SellerAccount that matches the filter.
     * @param {SellerAccountFindUniqueArgs} args - Arguments to find a SellerAccount
     * @example
     * // Get one SellerAccount
     * const sellerAccount = await prisma.sellerAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerAccountFindUniqueArgs>(args: SelectSubset<T, SellerAccountFindUniqueArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerAccountFindUniqueOrThrowArgs} args - Arguments to find a SellerAccount
     * @example
     * // Get one SellerAccount
     * const sellerAccount = await prisma.sellerAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountFindFirstArgs} args - Arguments to find a SellerAccount
     * @example
     * // Get one SellerAccount
     * const sellerAccount = await prisma.sellerAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerAccountFindFirstArgs>(args?: SelectSubset<T, SellerAccountFindFirstArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountFindFirstOrThrowArgs} args - Arguments to find a SellerAccount
     * @example
     * // Get one SellerAccount
     * const sellerAccount = await prisma.sellerAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerAccounts
     * const sellerAccounts = await prisma.sellerAccount.findMany()
     * 
     * // Get first 10 SellerAccounts
     * const sellerAccounts = await prisma.sellerAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerAccountWithIdOnly = await prisma.sellerAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerAccountFindManyArgs>(args?: SelectSubset<T, SellerAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerAccount.
     * @param {SellerAccountCreateArgs} args - Arguments to create a SellerAccount.
     * @example
     * // Create one SellerAccount
     * const SellerAccount = await prisma.sellerAccount.create({
     *   data: {
     *     // ... data to create a SellerAccount
     *   }
     * })
     * 
     */
    create<T extends SellerAccountCreateArgs>(args: SelectSubset<T, SellerAccountCreateArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerAccounts.
     * @param {SellerAccountCreateManyArgs} args - Arguments to create many SellerAccounts.
     * @example
     * // Create many SellerAccounts
     * const sellerAccount = await prisma.sellerAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerAccountCreateManyArgs>(args?: SelectSubset<T, SellerAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellerAccounts and returns the data saved in the database.
     * @param {SellerAccountCreateManyAndReturnArgs} args - Arguments to create many SellerAccounts.
     * @example
     * // Create many SellerAccounts
     * const sellerAccount = await prisma.sellerAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellerAccounts and only return the `id`
     * const sellerAccountWithIdOnly = await prisma.sellerAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellerAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SellerAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SellerAccount.
     * @param {SellerAccountDeleteArgs} args - Arguments to delete one SellerAccount.
     * @example
     * // Delete one SellerAccount
     * const SellerAccount = await prisma.sellerAccount.delete({
     *   where: {
     *     // ... filter to delete one SellerAccount
     *   }
     * })
     * 
     */
    delete<T extends SellerAccountDeleteArgs>(args: SelectSubset<T, SellerAccountDeleteArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerAccount.
     * @param {SellerAccountUpdateArgs} args - Arguments to update one SellerAccount.
     * @example
     * // Update one SellerAccount
     * const sellerAccount = await prisma.sellerAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerAccountUpdateArgs>(args: SelectSubset<T, SellerAccountUpdateArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerAccounts.
     * @param {SellerAccountDeleteManyArgs} args - Arguments to filter SellerAccounts to delete.
     * @example
     * // Delete a few SellerAccounts
     * const { count } = await prisma.sellerAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerAccountDeleteManyArgs>(args?: SelectSubset<T, SellerAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerAccounts
     * const sellerAccount = await prisma.sellerAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerAccountUpdateManyArgs>(args: SelectSubset<T, SellerAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerAccounts and returns the data updated in the database.
     * @param {SellerAccountUpdateManyAndReturnArgs} args - Arguments to update many SellerAccounts.
     * @example
     * // Update many SellerAccounts
     * const sellerAccount = await prisma.sellerAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SellerAccounts and only return the `id`
     * const sellerAccountWithIdOnly = await prisma.sellerAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SellerAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SellerAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SellerAccount.
     * @param {SellerAccountUpsertArgs} args - Arguments to update or create a SellerAccount.
     * @example
     * // Update or create a SellerAccount
     * const sellerAccount = await prisma.sellerAccount.upsert({
     *   create: {
     *     // ... data to create a SellerAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerAccount we want to update
     *   }
     * })
     */
    upsert<T extends SellerAccountUpsertArgs>(args: SelectSubset<T, SellerAccountUpsertArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SellerAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountCountArgs} args - Arguments to filter SellerAccounts to count.
     * @example
     * // Count the number of SellerAccounts
     * const count = await prisma.sellerAccount.count({
     *   where: {
     *     // ... the filter for the SellerAccounts we want to count
     *   }
     * })
    **/
    count<T extends SellerAccountCountArgs>(
      args?: Subset<T, SellerAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerAccountAggregateArgs>(args: Subset<T, SellerAccountAggregateArgs>): Prisma.PrismaPromise<GetSellerAccountAggregateType<T>>

    /**
     * Group by SellerAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerAccountGroupByArgs['orderBy'] }
        : { orderBy?: SellerAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerAccount model
   */
  readonly fields: SellerAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends SellerAccount$UserArgs<ExtArgs> = {}>(args?: Subset<T, SellerAccount$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends SellerAccount$ProductArgs<ExtArgs> = {}>(args?: Subset<T, SellerAccount$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Order<T extends SellerAccount$OrderArgs<ExtArgs> = {}>(args?: Subset<T, SellerAccount$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerAccount model
   */
  interface SellerAccountFieldRefs {
    readonly id: FieldRef<"SellerAccount", 'String'>
    readonly sales: FieldRef<"SellerAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SellerAccount findUnique
   */
  export type SellerAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter, which SellerAccount to fetch.
     */
    where: SellerAccountWhereUniqueInput
  }

  /**
   * SellerAccount findUniqueOrThrow
   */
  export type SellerAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter, which SellerAccount to fetch.
     */
    where: SellerAccountWhereUniqueInput
  }

  /**
   * SellerAccount findFirst
   */
  export type SellerAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter, which SellerAccount to fetch.
     */
    where?: SellerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerAccounts to fetch.
     */
    orderBy?: SellerAccountOrderByWithRelationInput | SellerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerAccounts.
     */
    cursor?: SellerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerAccounts.
     */
    distinct?: SellerAccountScalarFieldEnum | SellerAccountScalarFieldEnum[]
  }

  /**
   * SellerAccount findFirstOrThrow
   */
  export type SellerAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter, which SellerAccount to fetch.
     */
    where?: SellerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerAccounts to fetch.
     */
    orderBy?: SellerAccountOrderByWithRelationInput | SellerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerAccounts.
     */
    cursor?: SellerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerAccounts.
     */
    distinct?: SellerAccountScalarFieldEnum | SellerAccountScalarFieldEnum[]
  }

  /**
   * SellerAccount findMany
   */
  export type SellerAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter, which SellerAccounts to fetch.
     */
    where?: SellerAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerAccounts to fetch.
     */
    orderBy?: SellerAccountOrderByWithRelationInput | SellerAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerAccounts.
     */
    cursor?: SellerAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerAccounts.
     */
    skip?: number
    distinct?: SellerAccountScalarFieldEnum | SellerAccountScalarFieldEnum[]
  }

  /**
   * SellerAccount create
   */
  export type SellerAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SellerAccount.
     */
    data: XOR<SellerAccountCreateInput, SellerAccountUncheckedCreateInput>
  }

  /**
   * SellerAccount createMany
   */
  export type SellerAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerAccounts.
     */
    data: SellerAccountCreateManyInput | SellerAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellerAccount createManyAndReturn
   */
  export type SellerAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SellerAccounts.
     */
    data: SellerAccountCreateManyInput | SellerAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerAccount update
   */
  export type SellerAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SellerAccount.
     */
    data: XOR<SellerAccountUpdateInput, SellerAccountUncheckedUpdateInput>
    /**
     * Choose, which SellerAccount to update.
     */
    where: SellerAccountWhereUniqueInput
  }

  /**
   * SellerAccount updateMany
   */
  export type SellerAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerAccounts.
     */
    data: XOR<SellerAccountUpdateManyMutationInput, SellerAccountUncheckedUpdateManyInput>
    /**
     * Filter which SellerAccounts to update
     */
    where?: SellerAccountWhereInput
    /**
     * Limit how many SellerAccounts to update.
     */
    limit?: number
  }

  /**
   * SellerAccount updateManyAndReturn
   */
  export type SellerAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * The data used to update SellerAccounts.
     */
    data: XOR<SellerAccountUpdateManyMutationInput, SellerAccountUncheckedUpdateManyInput>
    /**
     * Filter which SellerAccounts to update
     */
    where?: SellerAccountWhereInput
    /**
     * Limit how many SellerAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellerAccount upsert
   */
  export type SellerAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SellerAccount to update in case it exists.
     */
    where: SellerAccountWhereUniqueInput
    /**
     * In case the SellerAccount found by the `where` argument doesn't exist, create a new SellerAccount with this data.
     */
    create: XOR<SellerAccountCreateInput, SellerAccountUncheckedCreateInput>
    /**
     * In case the SellerAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerAccountUpdateInput, SellerAccountUncheckedUpdateInput>
  }

  /**
   * SellerAccount delete
   */
  export type SellerAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
    /**
     * Filter which SellerAccount to delete.
     */
    where: SellerAccountWhereUniqueInput
  }

  /**
   * SellerAccount deleteMany
   */
  export type SellerAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerAccounts to delete
     */
    where?: SellerAccountWhereInput
    /**
     * Limit how many SellerAccounts to delete.
     */
    limit?: number
  }

  /**
   * SellerAccount.User
   */
  export type SellerAccount$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SellerAccount.Product
   */
  export type SellerAccount$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    cursor?: ProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * SellerAccount.Order
   */
  export type SellerAccount$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * SellerAccount without action
   */
  export type SellerAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerAccount
     */
    select?: SellerAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerAccount
     */
    omit?: SellerAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerAccountInclude<ExtArgs> | null
  }


  /**
   * Model Products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    rating: string | null
    imageurl: string | null
    quantity: string | null
    sellerName: string | null
    expirydate: string | null
    category: $Enums.Categories | null
    specialmsg: string | null
    stock: string | null
    contact: string | null
    mode: $Enums.Mode | null
    type: $Enums.Type | null
    offers: string | null
    sellerid: string | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    description: string | null
    rating: string | null
    imageurl: string | null
    quantity: string | null
    sellerName: string | null
    expirydate: string | null
    category: $Enums.Categories | null
    specialmsg: string | null
    stock: string | null
    contact: string | null
    mode: $Enums.Mode | null
    type: $Enums.Type | null
    offers: string | null
    sellerid: string | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    name: number
    price: number
    description: number
    rating: number
    imageurl: number
    quantity: number
    sellerName: number
    expirydate: number
    category: number
    specialmsg: number
    stock: number
    contact: number
    questions: number
    mode: number
    type: number
    offers: number
    sellerid: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    rating?: true
    imageurl?: true
    quantity?: true
    sellerName?: true
    expirydate?: true
    category?: true
    specialmsg?: true
    stock?: true
    contact?: true
    mode?: true
    type?: true
    offers?: true
    sellerid?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    rating?: true
    imageurl?: true
    quantity?: true
    sellerName?: true
    expirydate?: true
    category?: true
    specialmsg?: true
    stock?: true
    contact?: true
    mode?: true
    type?: true
    offers?: true
    sellerid?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    rating?: true
    imageurl?: true
    quantity?: true
    sellerName?: true
    expirydate?: true
    category?: true
    specialmsg?: true
    stock?: true
    contact?: true
    questions?: true
    mode?: true
    type?: true
    offers?: true
    sellerid?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to aggregate.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type ProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductsWhereInput
    orderBy?: ProductsOrderByWithAggregationInput | ProductsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: ProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: string
    name: string
    price: string | null
    description: string | null
    rating: string | null
    imageurl: string | null
    quantity: string | null
    sellerName: string
    expirydate: string | null
    category: $Enums.Categories
    specialmsg: string | null
    stock: string | null
    contact: string | null
    questions: string[]
    mode: $Enums.Mode | null
    type: $Enums.Type
    offers: string | null
    sellerid: string
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends ProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type ProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    rating?: boolean
    imageurl?: boolean
    quantity?: boolean
    sellerName?: boolean
    expirydate?: boolean
    category?: boolean
    specialmsg?: boolean
    stock?: boolean
    contact?: boolean
    questions?: boolean
    mode?: boolean
    type?: boolean
    offers?: boolean
    sellerid?: boolean
    Review?: boolean | Products$ReviewArgs<ExtArgs>
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
    order?: boolean | Products$orderArgs<ExtArgs>
    WishList?: boolean | Products$WishListArgs<ExtArgs>
    Queries?: boolean | Products$QueriesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    rating?: boolean
    imageurl?: boolean
    quantity?: boolean
    sellerName?: boolean
    expirydate?: boolean
    category?: boolean
    specialmsg?: boolean
    stock?: boolean
    contact?: boolean
    questions?: boolean
    mode?: boolean
    type?: boolean
    offers?: boolean
    sellerid?: boolean
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    rating?: boolean
    imageurl?: boolean
    quantity?: boolean
    sellerName?: boolean
    expirydate?: boolean
    category?: boolean
    specialmsg?: boolean
    stock?: boolean
    contact?: boolean
    questions?: boolean
    mode?: boolean
    type?: boolean
    offers?: boolean
    sellerid?: boolean
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type ProductsSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    rating?: boolean
    imageurl?: boolean
    quantity?: boolean
    sellerName?: boolean
    expirydate?: boolean
    category?: boolean
    specialmsg?: boolean
    stock?: boolean
    contact?: boolean
    questions?: boolean
    mode?: boolean
    type?: boolean
    offers?: boolean
    sellerid?: boolean
  }

  export type ProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "description" | "rating" | "imageurl" | "quantity" | "sellerName" | "expirydate" | "category" | "specialmsg" | "stock" | "contact" | "questions" | "mode" | "type" | "offers" | "sellerid", ExtArgs["result"]["products"]>
  export type ProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Review?: boolean | Products$ReviewArgs<ExtArgs>
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
    order?: boolean | Products$orderArgs<ExtArgs>
    WishList?: boolean | Products$WishListArgs<ExtArgs>
    Queries?: boolean | Products$QueriesArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
  }
  export type ProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Seller?: boolean | SellerAccountDefaultArgs<ExtArgs>
  }

  export type $ProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Products"
    objects: {
      Review: Prisma.$ReviewPayload<ExtArgs>[]
      Seller: Prisma.$SellerAccountPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>[]
      WishList: Prisma.$WishListPayload<ExtArgs>[]
      Queries: Prisma.$ProductQueryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string | null
      description: string | null
      rating: string | null
      imageurl: string | null
      quantity: string | null
      sellerName: string
      expirydate: string | null
      category: $Enums.Categories
      specialmsg: string | null
      stock: string | null
      contact: string | null
      questions: string[]
      mode: $Enums.Mode | null
      type: $Enums.Type
      offers: string | null
      sellerid: string
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type ProductsGetPayload<S extends boolean | null | undefined | ProductsDefaultArgs> = $Result.GetResult<Prisma.$ProductsPayload, S>

  type ProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface ProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Products'], meta: { name: 'Products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {ProductsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductsFindUniqueArgs>(args: SelectSubset<T, ProductsFindUniqueArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductsFindFirstArgs>(args?: SelectSubset<T, ProductsFindFirstArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductsFindManyArgs>(args?: SelectSubset<T, ProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {ProductsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends ProductsCreateArgs>(args: SelectSubset<T, ProductsCreateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductsCreateManyArgs>(args?: SelectSubset<T, ProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {ProductsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends ProductsDeleteArgs>(args: SelectSubset<T, ProductsDeleteArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {ProductsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductsUpdateArgs>(args: SelectSubset<T, ProductsUpdateArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductsDeleteManyArgs>(args?: SelectSubset<T, ProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductsUpdateManyArgs>(args: SelectSubset<T, ProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {ProductsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends ProductsUpsertArgs>(args: SelectSubset<T, ProductsUpsertArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductsCountArgs>(
      args?: Subset<T, ProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductsGroupByArgs['orderBy'] }
        : { orderBy?: ProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Products model
   */
  readonly fields: ProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Review<T extends Products$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, Products$ReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Seller<T extends SellerAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellerAccountDefaultArgs<ExtArgs>>): Prisma__SellerAccountClient<$Result.GetResult<Prisma.$SellerAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Products$orderArgs<ExtArgs> = {}>(args?: Subset<T, Products$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishList<T extends Products$WishListArgs<ExtArgs> = {}>(args?: Subset<T, Products$WishListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Queries<T extends Products$QueriesArgs<ExtArgs> = {}>(args?: Subset<T, Products$QueriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Products model
   */
  interface ProductsFieldRefs {
    readonly id: FieldRef<"Products", 'String'>
    readonly name: FieldRef<"Products", 'String'>
    readonly price: FieldRef<"Products", 'String'>
    readonly description: FieldRef<"Products", 'String'>
    readonly rating: FieldRef<"Products", 'String'>
    readonly imageurl: FieldRef<"Products", 'String'>
    readonly quantity: FieldRef<"Products", 'String'>
    readonly sellerName: FieldRef<"Products", 'String'>
    readonly expirydate: FieldRef<"Products", 'String'>
    readonly category: FieldRef<"Products", 'Categories'>
    readonly specialmsg: FieldRef<"Products", 'String'>
    readonly stock: FieldRef<"Products", 'String'>
    readonly contact: FieldRef<"Products", 'String'>
    readonly questions: FieldRef<"Products", 'String[]'>
    readonly mode: FieldRef<"Products", 'Mode'>
    readonly type: FieldRef<"Products", 'Type'>
    readonly offers: FieldRef<"Products", 'String'>
    readonly sellerid: FieldRef<"Products", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Products findUnique
   */
  export type ProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findUniqueOrThrow
   */
  export type ProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products findFirst
   */
  export type ProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findFirstOrThrow
   */
  export type ProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products findMany
   */
  export type ProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductsOrderByWithRelationInput | ProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * Products create
   */
  export type ProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a Products.
     */
    data: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
  }

  /**
   * Products createMany
   */
  export type ProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Products createManyAndReturn
   */
  export type ProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductsCreateManyInput | ProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products update
   */
  export type ProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a Products.
     */
    data: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
    /**
     * Choose, which Products to update.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products updateMany
   */
  export type ProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Products updateManyAndReturn
   */
  export type ProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Products upsert
   */
  export type ProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the Products to update in case it exists.
     */
    where: ProductsWhereUniqueInput
    /**
     * In case the Products found by the `where` argument doesn't exist, create a new Products with this data.
     */
    create: XOR<ProductsCreateInput, ProductsUncheckedCreateInput>
    /**
     * In case the Products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductsUpdateInput, ProductsUncheckedUpdateInput>
  }

  /**
   * Products delete
   */
  export type ProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    /**
     * Filter which Products to delete.
     */
    where: ProductsWhereUniqueInput
  }

  /**
   * Products deleteMany
   */
  export type ProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductsWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Products.Review
   */
  export type Products$ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Products.order
   */
  export type Products$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Products.WishList
   */
  export type Products$WishListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    where?: WishListWhereInput
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    cursor?: WishListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * Products.Queries
   */
  export type Products$QueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    where?: ProductQueryWhereInput
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    cursor?: ProductQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductQueryScalarFieldEnum | ProductQueryScalarFieldEnum[]
  }

  /**
   * Products without action
   */
  export type ProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
  }


  /**
   * Model ProductQuery
   */

  export type AggregateProductQuery = {
    _count: ProductQueryCountAggregateOutputType | null
    _avg: ProductQueryAvgAggregateOutputType | null
    _sum: ProductQuerySumAggregateOutputType | null
    _min: ProductQueryMinAggregateOutputType | null
    _max: ProductQueryMaxAggregateOutputType | null
  }

  export type ProductQueryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductQuerySumAggregateOutputType = {
    id: number | null
  }

  export type ProductQueryMinAggregateOutputType = {
    id: number | null
    username: string | null
    userid: string | null
    name: string | null
    contact: string | null
    additionalQueies: string | null
    productId: string | null
  }

  export type ProductQueryMaxAggregateOutputType = {
    id: number | null
    username: string | null
    userid: string | null
    name: string | null
    contact: string | null
    additionalQueies: string | null
    productId: string | null
  }

  export type ProductQueryCountAggregateOutputType = {
    id: number
    username: number
    userid: number
    name: number
    contact: number
    additionalQueies: number
    question: number
    answers: number
    productId: number
    _all: number
  }


  export type ProductQueryAvgAggregateInputType = {
    id?: true
  }

  export type ProductQuerySumAggregateInputType = {
    id?: true
  }

  export type ProductQueryMinAggregateInputType = {
    id?: true
    username?: true
    userid?: true
    name?: true
    contact?: true
    additionalQueies?: true
    productId?: true
  }

  export type ProductQueryMaxAggregateInputType = {
    id?: true
    username?: true
    userid?: true
    name?: true
    contact?: true
    additionalQueies?: true
    productId?: true
  }

  export type ProductQueryCountAggregateInputType = {
    id?: true
    username?: true
    userid?: true
    name?: true
    contact?: true
    additionalQueies?: true
    question?: true
    answers?: true
    productId?: true
    _all?: true
  }

  export type ProductQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQuery to aggregate.
     */
    where?: ProductQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQueries to fetch.
     */
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductQueries
    **/
    _count?: true | ProductQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductQueryMaxAggregateInputType
  }

  export type GetProductQueryAggregateType<T extends ProductQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductQuery[P]>
      : GetScalarType<T[P], AggregateProductQuery[P]>
  }




  export type ProductQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductQueryWhereInput
    orderBy?: ProductQueryOrderByWithAggregationInput | ProductQueryOrderByWithAggregationInput[]
    by: ProductQueryScalarFieldEnum[] | ProductQueryScalarFieldEnum
    having?: ProductQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductQueryCountAggregateInputType | true
    _avg?: ProductQueryAvgAggregateInputType
    _sum?: ProductQuerySumAggregateInputType
    _min?: ProductQueryMinAggregateInputType
    _max?: ProductQueryMaxAggregateInputType
  }

  export type ProductQueryGroupByOutputType = {
    id: number
    username: string | null
    userid: string
    name: string | null
    contact: string | null
    additionalQueies: string | null
    question: string[]
    answers: string[]
    productId: string | null
    _count: ProductQueryCountAggregateOutputType | null
    _avg: ProductQueryAvgAggregateOutputType | null
    _sum: ProductQuerySumAggregateOutputType | null
    _min: ProductQueryMinAggregateOutputType | null
    _max: ProductQueryMaxAggregateOutputType | null
  }

  type GetProductQueryGroupByPayload<T extends ProductQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductQueryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductQueryGroupByOutputType[P]>
        }
      >
    >


  export type ProductQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    userid?: boolean
    name?: boolean
    contact?: boolean
    additionalQueies?: boolean
    question?: boolean
    answers?: boolean
    productId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["productQuery"]>

  export type ProductQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    userid?: boolean
    name?: boolean
    contact?: boolean
    additionalQueies?: boolean
    question?: boolean
    answers?: boolean
    productId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["productQuery"]>

  export type ProductQuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    userid?: boolean
    name?: boolean
    contact?: boolean
    additionalQueies?: boolean
    question?: boolean
    answers?: boolean
    productId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["productQuery"]>

  export type ProductQuerySelectScalar = {
    id?: boolean
    username?: boolean
    userid?: boolean
    name?: boolean
    contact?: boolean
    additionalQueies?: boolean
    question?: boolean
    answers?: boolean
    productId?: boolean
  }

  export type ProductQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "userid" | "name" | "contact" | "additionalQueies" | "question" | "answers" | "productId", ExtArgs["result"]["productQuery"]>
  export type ProductQueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }
  export type ProductQueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }
  export type ProductQueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductQuery$ProductArgs<ExtArgs>
  }

  export type $ProductQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductQuery"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Product: Prisma.$ProductsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      userid: string
      name: string | null
      contact: string | null
      additionalQueies: string | null
      question: string[]
      answers: string[]
      productId: string | null
    }, ExtArgs["result"]["productQuery"]>
    composites: {}
  }

  type ProductQueryGetPayload<S extends boolean | null | undefined | ProductQueryDefaultArgs> = $Result.GetResult<Prisma.$ProductQueryPayload, S>

  type ProductQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductQueryCountAggregateInputType | true
    }

  export interface ProductQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductQuery'], meta: { name: 'ProductQuery' } }
    /**
     * Find zero or one ProductQuery that matches the filter.
     * @param {ProductQueryFindUniqueArgs} args - Arguments to find a ProductQuery
     * @example
     * // Get one ProductQuery
     * const productQuery = await prisma.productQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductQueryFindUniqueArgs>(args: SelectSubset<T, ProductQueryFindUniqueArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductQueryFindUniqueOrThrowArgs} args - Arguments to find a ProductQuery
     * @example
     * // Get one ProductQuery
     * const productQuery = await prisma.productQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryFindFirstArgs} args - Arguments to find a ProductQuery
     * @example
     * // Get one ProductQuery
     * const productQuery = await prisma.productQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductQueryFindFirstArgs>(args?: SelectSubset<T, ProductQueryFindFirstArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryFindFirstOrThrowArgs} args - Arguments to find a ProductQuery
     * @example
     * // Get one ProductQuery
     * const productQuery = await prisma.productQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductQueries
     * const productQueries = await prisma.productQuery.findMany()
     * 
     * // Get first 10 ProductQueries
     * const productQueries = await prisma.productQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productQueryWithIdOnly = await prisma.productQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductQueryFindManyArgs>(args?: SelectSubset<T, ProductQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductQuery.
     * @param {ProductQueryCreateArgs} args - Arguments to create a ProductQuery.
     * @example
     * // Create one ProductQuery
     * const ProductQuery = await prisma.productQuery.create({
     *   data: {
     *     // ... data to create a ProductQuery
     *   }
     * })
     * 
     */
    create<T extends ProductQueryCreateArgs>(args: SelectSubset<T, ProductQueryCreateArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductQueries.
     * @param {ProductQueryCreateManyArgs} args - Arguments to create many ProductQueries.
     * @example
     * // Create many ProductQueries
     * const productQuery = await prisma.productQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductQueryCreateManyArgs>(args?: SelectSubset<T, ProductQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductQueries and returns the data saved in the database.
     * @param {ProductQueryCreateManyAndReturnArgs} args - Arguments to create many ProductQueries.
     * @example
     * // Create many ProductQueries
     * const productQuery = await prisma.productQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductQueries and only return the `id`
     * const productQueryWithIdOnly = await prisma.productQuery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductQuery.
     * @param {ProductQueryDeleteArgs} args - Arguments to delete one ProductQuery.
     * @example
     * // Delete one ProductQuery
     * const ProductQuery = await prisma.productQuery.delete({
     *   where: {
     *     // ... filter to delete one ProductQuery
     *   }
     * })
     * 
     */
    delete<T extends ProductQueryDeleteArgs>(args: SelectSubset<T, ProductQueryDeleteArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductQuery.
     * @param {ProductQueryUpdateArgs} args - Arguments to update one ProductQuery.
     * @example
     * // Update one ProductQuery
     * const productQuery = await prisma.productQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductQueryUpdateArgs>(args: SelectSubset<T, ProductQueryUpdateArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductQueries.
     * @param {ProductQueryDeleteManyArgs} args - Arguments to filter ProductQueries to delete.
     * @example
     * // Delete a few ProductQueries
     * const { count } = await prisma.productQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductQueryDeleteManyArgs>(args?: SelectSubset<T, ProductQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductQueries
     * const productQuery = await prisma.productQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductQueryUpdateManyArgs>(args: SelectSubset<T, ProductQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductQueries and returns the data updated in the database.
     * @param {ProductQueryUpdateManyAndReturnArgs} args - Arguments to update many ProductQueries.
     * @example
     * // Update many ProductQueries
     * const productQuery = await prisma.productQuery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductQueries and only return the `id`
     * const productQueryWithIdOnly = await prisma.productQuery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductQueryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductQueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductQuery.
     * @param {ProductQueryUpsertArgs} args - Arguments to update or create a ProductQuery.
     * @example
     * // Update or create a ProductQuery
     * const productQuery = await prisma.productQuery.upsert({
     *   create: {
     *     // ... data to create a ProductQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductQuery we want to update
     *   }
     * })
     */
    upsert<T extends ProductQueryUpsertArgs>(args: SelectSubset<T, ProductQueryUpsertArgs<ExtArgs>>): Prisma__ProductQueryClient<$Result.GetResult<Prisma.$ProductQueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryCountArgs} args - Arguments to filter ProductQueries to count.
     * @example
     * // Count the number of ProductQueries
     * const count = await prisma.productQuery.count({
     *   where: {
     *     // ... the filter for the ProductQueries we want to count
     *   }
     * })
    **/
    count<T extends ProductQueryCountArgs>(
      args?: Subset<T, ProductQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductQueryAggregateArgs>(args: Subset<T, ProductQueryAggregateArgs>): Prisma.PrismaPromise<GetProductQueryAggregateType<T>>

    /**
     * Group by ProductQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductQueryGroupByArgs['orderBy'] }
        : { orderBy?: ProductQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductQuery model
   */
  readonly fields: ProductQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductQuery$ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductQuery$ProductArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductQuery model
   */
  interface ProductQueryFieldRefs {
    readonly id: FieldRef<"ProductQuery", 'Int'>
    readonly username: FieldRef<"ProductQuery", 'String'>
    readonly userid: FieldRef<"ProductQuery", 'String'>
    readonly name: FieldRef<"ProductQuery", 'String'>
    readonly contact: FieldRef<"ProductQuery", 'String'>
    readonly additionalQueies: FieldRef<"ProductQuery", 'String'>
    readonly question: FieldRef<"ProductQuery", 'String[]'>
    readonly answers: FieldRef<"ProductQuery", 'String[]'>
    readonly productId: FieldRef<"ProductQuery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductQuery findUnique
   */
  export type ProductQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuery to fetch.
     */
    where: ProductQueryWhereUniqueInput
  }

  /**
   * ProductQuery findUniqueOrThrow
   */
  export type ProductQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuery to fetch.
     */
    where: ProductQueryWhereUniqueInput
  }

  /**
   * ProductQuery findFirst
   */
  export type ProductQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuery to fetch.
     */
    where?: ProductQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQueries to fetch.
     */
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQueries.
     */
    cursor?: ProductQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQueries.
     */
    distinct?: ProductQueryScalarFieldEnum | ProductQueryScalarFieldEnum[]
  }

  /**
   * ProductQuery findFirstOrThrow
   */
  export type ProductQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter, which ProductQuery to fetch.
     */
    where?: ProductQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQueries to fetch.
     */
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductQueries.
     */
    cursor?: ProductQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductQueries.
     */
    distinct?: ProductQueryScalarFieldEnum | ProductQueryScalarFieldEnum[]
  }

  /**
   * ProductQuery findMany
   */
  export type ProductQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter, which ProductQueries to fetch.
     */
    where?: ProductQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductQueries to fetch.
     */
    orderBy?: ProductQueryOrderByWithRelationInput | ProductQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductQueries.
     */
    cursor?: ProductQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductQueries.
     */
    skip?: number
    distinct?: ProductQueryScalarFieldEnum | ProductQueryScalarFieldEnum[]
  }

  /**
   * ProductQuery create
   */
  export type ProductQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductQuery.
     */
    data: XOR<ProductQueryCreateInput, ProductQueryUncheckedCreateInput>
  }

  /**
   * ProductQuery createMany
   */
  export type ProductQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductQueries.
     */
    data: ProductQueryCreateManyInput | ProductQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductQuery createManyAndReturn
   */
  export type ProductQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductQueries.
     */
    data: ProductQueryCreateManyInput | ProductQueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductQuery update
   */
  export type ProductQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductQuery.
     */
    data: XOR<ProductQueryUpdateInput, ProductQueryUncheckedUpdateInput>
    /**
     * Choose, which ProductQuery to update.
     */
    where: ProductQueryWhereUniqueInput
  }

  /**
   * ProductQuery updateMany
   */
  export type ProductQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductQueries.
     */
    data: XOR<ProductQueryUpdateManyMutationInput, ProductQueryUncheckedUpdateManyInput>
    /**
     * Filter which ProductQueries to update
     */
    where?: ProductQueryWhereInput
    /**
     * Limit how many ProductQueries to update.
     */
    limit?: number
  }

  /**
   * ProductQuery updateManyAndReturn
   */
  export type ProductQueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * The data used to update ProductQueries.
     */
    data: XOR<ProductQueryUpdateManyMutationInput, ProductQueryUncheckedUpdateManyInput>
    /**
     * Filter which ProductQueries to update
     */
    where?: ProductQueryWhereInput
    /**
     * Limit how many ProductQueries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductQuery upsert
   */
  export type ProductQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductQuery to update in case it exists.
     */
    where: ProductQueryWhereUniqueInput
    /**
     * In case the ProductQuery found by the `where` argument doesn't exist, create a new ProductQuery with this data.
     */
    create: XOR<ProductQueryCreateInput, ProductQueryUncheckedCreateInput>
    /**
     * In case the ProductQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductQueryUpdateInput, ProductQueryUncheckedUpdateInput>
  }

  /**
   * ProductQuery delete
   */
  export type ProductQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
    /**
     * Filter which ProductQuery to delete.
     */
    where: ProductQueryWhereUniqueInput
  }

  /**
   * ProductQuery deleteMany
   */
  export type ProductQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductQueries to delete
     */
    where?: ProductQueryWhereInput
    /**
     * Limit how many ProductQueries to delete.
     */
    limit?: number
  }

  /**
   * ProductQuery.Product
   */
  export type ProductQuery$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * ProductQuery without action
   */
  export type ProductQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductQuery
     */
    select?: ProductQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductQuery
     */
    omit?: ProductQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductQueryInclude<ExtArgs> | null
  }


  /**
   * Model WishList
   */

  export type AggregateWishList = {
    _count: WishListCountAggregateOutputType | null
    _min: WishListMinAggregateOutputType | null
    _max: WishListMaxAggregateOutputType | null
  }

  export type WishListMinAggregateOutputType = {
    id: string | null
    userid: string | null
    productid: string | null
  }

  export type WishListMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    productid: string | null
  }

  export type WishListCountAggregateOutputType = {
    id: number
    userid: number
    productid: number
    _all: number
  }


  export type WishListMinAggregateInputType = {
    id?: true
    userid?: true
    productid?: true
  }

  export type WishListMaxAggregateInputType = {
    id?: true
    userid?: true
    productid?: true
  }

  export type WishListCountAggregateInputType = {
    id?: true
    userid?: true
    productid?: true
    _all?: true
  }

  export type WishListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishList to aggregate.
     */
    where?: WishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishLists to fetch.
     */
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishLists
    **/
    _count?: true | WishListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishListMaxAggregateInputType
  }

  export type GetWishListAggregateType<T extends WishListAggregateArgs> = {
        [P in keyof T & keyof AggregateWishList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishList[P]>
      : GetScalarType<T[P], AggregateWishList[P]>
  }




  export type WishListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishListWhereInput
    orderBy?: WishListOrderByWithAggregationInput | WishListOrderByWithAggregationInput[]
    by: WishListScalarFieldEnum[] | WishListScalarFieldEnum
    having?: WishListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishListCountAggregateInputType | true
    _min?: WishListMinAggregateInputType
    _max?: WishListMaxAggregateInputType
  }

  export type WishListGroupByOutputType = {
    id: string
    userid: string | null
    productid: string | null
    _count: WishListCountAggregateOutputType | null
    _min: WishListMinAggregateOutputType | null
    _max: WishListMaxAggregateOutputType | null
  }

  type GetWishListGroupByPayload<T extends WishListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishListGroupByOutputType[P]>
            : GetScalarType<T[P], WishListGroupByOutputType[P]>
        }
      >
    >


  export type WishListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    productid?: boolean
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["wishList"]>

  export type WishListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    productid?: boolean
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["wishList"]>

  export type WishListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    productid?: boolean
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["wishList"]>

  export type WishListSelectScalar = {
    id?: boolean
    userid?: boolean
    productid?: boolean
  }

  export type WishListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "productid", ExtArgs["result"]["wishList"]>
  export type WishListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }
  export type WishListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }
  export type WishListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | WishList$UserArgs<ExtArgs>
    Product?: boolean | WishList$ProductArgs<ExtArgs>
  }

  export type $WishListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishList"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      Product: Prisma.$ProductsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string | null
      productid: string | null
    }, ExtArgs["result"]["wishList"]>
    composites: {}
  }

  type WishListGetPayload<S extends boolean | null | undefined | WishListDefaultArgs> = $Result.GetResult<Prisma.$WishListPayload, S>

  type WishListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishListCountAggregateInputType | true
    }

  export interface WishListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishList'], meta: { name: 'WishList' } }
    /**
     * Find zero or one WishList that matches the filter.
     * @param {WishListFindUniqueArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishListFindUniqueArgs>(args: SelectSubset<T, WishListFindUniqueArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishListFindUniqueOrThrowArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishListFindUniqueOrThrowArgs>(args: SelectSubset<T, WishListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListFindFirstArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishListFindFirstArgs>(args?: SelectSubset<T, WishListFindFirstArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListFindFirstOrThrowArgs} args - Arguments to find a WishList
     * @example
     * // Get one WishList
     * const wishList = await prisma.wishList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishListFindFirstOrThrowArgs>(args?: SelectSubset<T, WishListFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishLists
     * const wishLists = await prisma.wishList.findMany()
     * 
     * // Get first 10 WishLists
     * const wishLists = await prisma.wishList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishListWithIdOnly = await prisma.wishList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishListFindManyArgs>(args?: SelectSubset<T, WishListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishList.
     * @param {WishListCreateArgs} args - Arguments to create a WishList.
     * @example
     * // Create one WishList
     * const WishList = await prisma.wishList.create({
     *   data: {
     *     // ... data to create a WishList
     *   }
     * })
     * 
     */
    create<T extends WishListCreateArgs>(args: SelectSubset<T, WishListCreateArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishLists.
     * @param {WishListCreateManyArgs} args - Arguments to create many WishLists.
     * @example
     * // Create many WishLists
     * const wishList = await prisma.wishList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishListCreateManyArgs>(args?: SelectSubset<T, WishListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WishLists and returns the data saved in the database.
     * @param {WishListCreateManyAndReturnArgs} args - Arguments to create many WishLists.
     * @example
     * // Create many WishLists
     * const wishList = await prisma.wishList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WishLists and only return the `id`
     * const wishListWithIdOnly = await prisma.wishList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WishListCreateManyAndReturnArgs>(args?: SelectSubset<T, WishListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WishList.
     * @param {WishListDeleteArgs} args - Arguments to delete one WishList.
     * @example
     * // Delete one WishList
     * const WishList = await prisma.wishList.delete({
     *   where: {
     *     // ... filter to delete one WishList
     *   }
     * })
     * 
     */
    delete<T extends WishListDeleteArgs>(args: SelectSubset<T, WishListDeleteArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishList.
     * @param {WishListUpdateArgs} args - Arguments to update one WishList.
     * @example
     * // Update one WishList
     * const wishList = await prisma.wishList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishListUpdateArgs>(args: SelectSubset<T, WishListUpdateArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishLists.
     * @param {WishListDeleteManyArgs} args - Arguments to filter WishLists to delete.
     * @example
     * // Delete a few WishLists
     * const { count } = await prisma.wishList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishListDeleteManyArgs>(args?: SelectSubset<T, WishListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishLists
     * const wishList = await prisma.wishList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishListUpdateManyArgs>(args: SelectSubset<T, WishListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishLists and returns the data updated in the database.
     * @param {WishListUpdateManyAndReturnArgs} args - Arguments to update many WishLists.
     * @example
     * // Update many WishLists
     * const wishList = await prisma.wishList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WishLists and only return the `id`
     * const wishListWithIdOnly = await prisma.wishList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WishListUpdateManyAndReturnArgs>(args: SelectSubset<T, WishListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WishList.
     * @param {WishListUpsertArgs} args - Arguments to update or create a WishList.
     * @example
     * // Update or create a WishList
     * const wishList = await prisma.wishList.upsert({
     *   create: {
     *     // ... data to create a WishList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishList we want to update
     *   }
     * })
     */
    upsert<T extends WishListUpsertArgs>(args: SelectSubset<T, WishListUpsertArgs<ExtArgs>>): Prisma__WishListClient<$Result.GetResult<Prisma.$WishListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListCountArgs} args - Arguments to filter WishLists to count.
     * @example
     * // Count the number of WishLists
     * const count = await prisma.wishList.count({
     *   where: {
     *     // ... the filter for the WishLists we want to count
     *   }
     * })
    **/
    count<T extends WishListCountArgs>(
      args?: Subset<T, WishListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishListAggregateArgs>(args: Subset<T, WishListAggregateArgs>): Prisma.PrismaPromise<GetWishListAggregateType<T>>

    /**
     * Group by WishList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishListGroupByArgs['orderBy'] }
        : { orderBy?: WishListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishList model
   */
  readonly fields: WishListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends WishList$UserArgs<ExtArgs> = {}>(args?: Subset<T, WishList$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends WishList$ProductArgs<ExtArgs> = {}>(args?: Subset<T, WishList$ProductArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishList model
   */
  interface WishListFieldRefs {
    readonly id: FieldRef<"WishList", 'String'>
    readonly userid: FieldRef<"WishList", 'String'>
    readonly productid: FieldRef<"WishList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WishList findUnique
   */
  export type WishListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter, which WishList to fetch.
     */
    where: WishListWhereUniqueInput
  }

  /**
   * WishList findUniqueOrThrow
   */
  export type WishListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter, which WishList to fetch.
     */
    where: WishListWhereUniqueInput
  }

  /**
   * WishList findFirst
   */
  export type WishListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter, which WishList to fetch.
     */
    where?: WishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishLists to fetch.
     */
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishLists.
     */
    cursor?: WishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishLists.
     */
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * WishList findFirstOrThrow
   */
  export type WishListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter, which WishList to fetch.
     */
    where?: WishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishLists to fetch.
     */
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishLists.
     */
    cursor?: WishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishLists.
     */
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * WishList findMany
   */
  export type WishListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter, which WishLists to fetch.
     */
    where?: WishListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishLists to fetch.
     */
    orderBy?: WishListOrderByWithRelationInput | WishListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishLists.
     */
    cursor?: WishListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishLists.
     */
    skip?: number
    distinct?: WishListScalarFieldEnum | WishListScalarFieldEnum[]
  }

  /**
   * WishList create
   */
  export type WishListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * The data needed to create a WishList.
     */
    data?: XOR<WishListCreateInput, WishListUncheckedCreateInput>
  }

  /**
   * WishList createMany
   */
  export type WishListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishLists.
     */
    data: WishListCreateManyInput | WishListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishList createManyAndReturn
   */
  export type WishListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * The data used to create many WishLists.
     */
    data: WishListCreateManyInput | WishListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishList update
   */
  export type WishListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * The data needed to update a WishList.
     */
    data: XOR<WishListUpdateInput, WishListUncheckedUpdateInput>
    /**
     * Choose, which WishList to update.
     */
    where: WishListWhereUniqueInput
  }

  /**
   * WishList updateMany
   */
  export type WishListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishLists.
     */
    data: XOR<WishListUpdateManyMutationInput, WishListUncheckedUpdateManyInput>
    /**
     * Filter which WishLists to update
     */
    where?: WishListWhereInput
    /**
     * Limit how many WishLists to update.
     */
    limit?: number
  }

  /**
   * WishList updateManyAndReturn
   */
  export type WishListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * The data used to update WishLists.
     */
    data: XOR<WishListUpdateManyMutationInput, WishListUncheckedUpdateManyInput>
    /**
     * Filter which WishLists to update
     */
    where?: WishListWhereInput
    /**
     * Limit how many WishLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WishList upsert
   */
  export type WishListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * The filter to search for the WishList to update in case it exists.
     */
    where: WishListWhereUniqueInput
    /**
     * In case the WishList found by the `where` argument doesn't exist, create a new WishList with this data.
     */
    create: XOR<WishListCreateInput, WishListUncheckedCreateInput>
    /**
     * In case the WishList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishListUpdateInput, WishListUncheckedUpdateInput>
  }

  /**
   * WishList delete
   */
  export type WishListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
    /**
     * Filter which WishList to delete.
     */
    where: WishListWhereUniqueInput
  }

  /**
   * WishList deleteMany
   */
  export type WishListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishLists to delete
     */
    where?: WishListWhereInput
    /**
     * Limit how many WishLists to delete.
     */
    limit?: number
  }

  /**
   * WishList.User
   */
  export type WishList$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WishList.Product
   */
  export type WishList$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * WishList without action
   */
  export type WishListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishList
     */
    select?: WishListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishList
     */
    omit?: WishListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishListInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    userid: string | null
    username: string | null
    productId: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    userid: string | null
    username: string | null
    productId: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    review: number
    userid: number
    username: number
    productId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userid?: true
    username?: true
    productId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userid?: true
    username?: true
    productId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userid?: true
    username?: true
    productId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    rating: number | null
    review: string | null
    userid: string | null
    username: string | null
    productId: string | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userid?: boolean
    username?: boolean
    productId?: boolean
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userid?: boolean
    username?: boolean
    productId?: boolean
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userid?: boolean
    username?: boolean
    productId?: boolean
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    review?: boolean
    userid?: boolean
    username?: boolean
    productId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "review" | "userid" | "username" | "productId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Review$UserArgs<ExtArgs>
    Product?: boolean | Review$ProductArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      Product: Prisma.$ProductsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number | null
      review: string | null
      userid: string | null
      username: string | null
      productId: string | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Review$UserArgs<ExtArgs> = {}>(args?: Subset<T, Review$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends Review$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Review$ProductArgs<ExtArgs>>): Prisma__ProductsClient<$Result.GetResult<Prisma.$ProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Float'>
    readonly review: FieldRef<"Review", 'String'>
    readonly userid: FieldRef<"Review", 'String'>
    readonly username: FieldRef<"Review", 'String'>
    readonly productId: FieldRef<"Review", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data?: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.User
   */
  export type Review$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Review.Product
   */
  export type Review$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Products
     */
    select?: ProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Products
     */
    omit?: ProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductsInclude<ExtArgs> | null
    where?: ProductsWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    originalName: string | null
    title: string | null
    storageUrl: string | null
    uploadDate: Date | null
    isEncrypted: boolean | null
    notes: string | null
    projectId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    originalName: string | null
    title: string | null
    storageUrl: string | null
    uploadDate: Date | null
    isEncrypted: boolean | null
    notes: string | null
    projectId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    originalName: number
    title: number
    storageUrl: number
    uploadDate: number
    isEncrypted: number
    notes: number
    projectId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    originalName?: true
    title?: true
    storageUrl?: true
    uploadDate?: true
    isEncrypted?: true
    notes?: true
    projectId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    originalName?: true
    title?: true
    storageUrl?: true
    uploadDate?: true
    isEncrypted?: true
    notes?: true
    projectId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    originalName?: true
    title?: true
    storageUrl?: true
    uploadDate?: true
    isEncrypted?: true
    notes?: true
    projectId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string | null
    originalName: string | null
    title: string
    storageUrl: string | null
    uploadDate: Date
    isEncrypted: boolean
    notes: string | null
    projectId: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originalName?: boolean
    title?: boolean
    storageUrl?: boolean
    uploadDate?: boolean
    isEncrypted?: boolean
    notes?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originalName?: boolean
    title?: boolean
    storageUrl?: boolean
    uploadDate?: boolean
    isEncrypted?: boolean
    notes?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originalName?: boolean
    title?: boolean
    storageUrl?: boolean
    uploadDate?: boolean
    isEncrypted?: boolean
    notes?: boolean
    projectId?: boolean
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    originalName?: boolean
    title?: boolean
    storageUrl?: boolean
    uploadDate?: boolean
    isEncrypted?: boolean
    notes?: boolean
    projectId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "originalName" | "title" | "storageUrl" | "uploadDate" | "isEncrypted" | "notes" | "projectId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      Project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      originalName: string | null
      title: string
      storageUrl: string | null
      uploadDate: Date
      isEncrypted: boolean
      notes: string | null
      projectId: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly originalName: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly storageUrl: FieldRef<"Document", 'String'>
    readonly uploadDate: FieldRef<"Document", 'DateTime'>
    readonly isEncrypted: FieldRef<"Document", 'Boolean'>
    readonly notes: FieldRef<"Document", 'String'>
    readonly projectId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    googlemail: 'googlemail',
    extra: 'extra',
    contact: 'contact',
    lastname: 'lastname',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const JobProfileScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    jobsapplied: 'jobsapplied',
    lastdisabled: 'lastdisabled',
    createdAt: 'createdAt',
    workdone: 'workdone',
    status: 'status',
    location: 'location'
  };

  export type JobProfileScalarFieldEnum = (typeof JobProfileScalarFieldEnum)[keyof typeof JobProfileScalarFieldEnum]


  export const DealersScalarFieldEnum: {
    id: 'id',
    idd: 'idd',
    name: 'name',
    dealeremail: 'dealeremail',
    dealerid: 'dealerid',
    email: 'email',
    phonenum: 'phonenum',
    verified: 'verified',
    address: 'address',
    category: 'category',
    transactionWorth: 'transactionWorth',
    createdAt: 'createdAt'
  };

  export type DealersScalarFieldEnum = (typeof DealersScalarFieldEnum)[keyof typeof DealersScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderStatus: 'orderStatus',
    sellerid: 'sellerid',
    buyerName: 'buyerName',
    buyerEmail: 'buyerEmail',
    buyerContact: 'buyerContact',
    buyerId: 'buyerId',
    orders: 'orders'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    userid: 'userid',
    coverimgUrl: 'coverimgUrl',
    budget: 'budget'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    projectId: 'projectId',
    name: 'name',
    useremail: 'useremail'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    available: 'available',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    value: 'value',
    stock: 'stock',
    valueperpeice: 'valueperpeice',
    projectId: 'projectId'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    verified: 'verified',
    phonenum: 'phonenum',
    useriid: 'useriid',
    createdat: 'createdat'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const ListingScalarFieldEnum: {
    id: 'id',
    image: 'image',
    rating: 'rating',
    address: 'address',
    soldout: 'soldout',
    description: 'description',
    ownerId: 'ownerId'
  };

  export type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    task: 'task',
    team: 'team',
    amount: 'amount',
    startdate: 'startdate',
    deadline: 'deadline',
    description: 'description',
    supplier: 'supplier',
    subtasks: 'subtasks',
    inventories: 'inventories',
    teamlead: 'teamlead',
    priority: 'priority',
    status: 'status',
    projectId: 'projectId',
    createdAt: 'createdAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    gstrate: 'gstrate',
    dealer: 'dealer',
    status: 'status',
    proof: 'proof',
    type: 'type',
    createdAt: 'createdAt',
    financeId: 'financeId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const FinanceScalarFieldEnum: {
    id: 'id',
    income: 'income',
    expenditure: 'expenditure',
    budget: 'budget',
    balance: 'balance',
    MPIN: 'MPIN'
  };

  export type FinanceScalarFieldEnum = (typeof FinanceScalarFieldEnum)[keyof typeof FinanceScalarFieldEnum]


  export const RemaindersScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    dealer: 'dealer',
    date: 'date',
    financeId: 'financeId'
  };

  export type RemaindersScalarFieldEnum = (typeof RemaindersScalarFieldEnum)[keyof typeof RemaindersScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    financeId: 'financeId',
    type: 'type'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const ScheduleMsgScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phonenum: 'phonenum',
    Datetime: 'Datetime',
    type: 'type',
    text: 'text',
    status: 'status',
    createdAt: 'createdAt',
    projectId: 'projectId'
  };

  export type ScheduleMsgScalarFieldEnum = (typeof ScheduleMsgScalarFieldEnum)[keyof typeof ScheduleMsgScalarFieldEnum]


  export const SellerAccountScalarFieldEnum: {
    id: 'id',
    sales: 'sales'
  };

  export type SellerAccountScalarFieldEnum = (typeof SellerAccountScalarFieldEnum)[keyof typeof SellerAccountScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    description: 'description',
    rating: 'rating',
    imageurl: 'imageurl',
    quantity: 'quantity',
    sellerName: 'sellerName',
    expirydate: 'expirydate',
    category: 'category',
    specialmsg: 'specialmsg',
    stock: 'stock',
    contact: 'contact',
    questions: 'questions',
    mode: 'mode',
    type: 'type',
    offers: 'offers',
    sellerid: 'sellerid'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const ProductQueryScalarFieldEnum: {
    id: 'id',
    username: 'username',
    userid: 'userid',
    name: 'name',
    contact: 'contact',
    additionalQueies: 'additionalQueies',
    question: 'question',
    answers: 'answers',
    productId: 'productId'
  };

  export type ProductQueryScalarFieldEnum = (typeof ProductQueryScalarFieldEnum)[keyof typeof ProductQueryScalarFieldEnum]


  export const WishListScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    productid: 'productid'
  };

  export type WishListScalarFieldEnum = (typeof WishListScalarFieldEnum)[keyof typeof WishListScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    review: 'review',
    userid: 'userid',
    username: 'username',
    productId: 'productId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    originalName: 'originalName',
    title: 'title',
    storageUrl: 'storageUrl',
    uploadDate: 'uploadDate',
    isEncrypted: 'isEncrypted',
    notes: 'notes',
    projectId: 'projectId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Typetrans'
   */
  export type EnumTypetransFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Typetrans'>
    


  /**
   * Reference to a field of type 'Typetrans[]'
   */
  export type ListEnumTypetransFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Typetrans[]'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'NoteType[]'
   */
  export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


  /**
   * Reference to a field of type 'Msgtype'
   */
  export type EnumMsgtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Msgtype'>
    


  /**
   * Reference to a field of type 'Msgtype[]'
   */
  export type ListEnumMsgtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Msgtype[]'>
    


  /**
   * Reference to a field of type 'ScheduleMsgStatus'
   */
  export type EnumScheduleMsgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleMsgStatus'>
    


  /**
   * Reference to a field of type 'ScheduleMsgStatus[]'
   */
  export type ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleMsgStatus[]'>
    


  /**
   * Reference to a field of type 'Categories'
   */
  export type EnumCategoriesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Categories'>
    


  /**
   * Reference to a field of type 'Categories[]'
   */
  export type ListEnumCategoriesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Categories[]'>
    


  /**
   * Reference to a field of type 'Mode'
   */
  export type EnumModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mode'>
    


  /**
   * Reference to a field of type 'Mode[]'
   */
  export type ListEnumModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mode[]'>
    


  /**
   * Reference to a field of type 'Type'
   */
  export type EnumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Type'>
    


  /**
   * Reference to a field of type 'Type[]'
   */
  export type ListEnumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Type[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    googlemail?: StringNullableFilter<"User"> | string | null
    extra?: StringNullableFilter<"User"> | string | null
    contact?: BigIntNullableFilter<"User"> | bigint | number | null
    lastname?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    projects?: ProjectListRelationFilter
    team?: TeamListRelationFilter
    Listing?: ListingListRelationFilter
    Selleraccount?: XOR<SellerAccountNullableScalarRelationFilter, SellerAccountWhereInput> | null
    Dealer?: DealersListRelationFilter
    JobProfle?: XOR<JobProfileNullableScalarRelationFilter, JobProfileWhereInput> | null
    Review?: ReviewListRelationFilter
    WishList?: WishListListRelationFilter
    Member?: MemberListRelationFilter
    ProductQuery?: ProductQueryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    googlemail?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    team?: TeamOrderByRelationAggregateInput
    Listing?: ListingOrderByRelationAggregateInput
    Selleraccount?: SellerAccountOrderByWithRelationInput
    Dealer?: DealersOrderByRelationAggregateInput
    JobProfle?: JobProfileOrderByWithRelationInput
    Review?: ReviewOrderByRelationAggregateInput
    WishList?: WishListOrderByRelationAggregateInput
    Member?: MemberOrderByRelationAggregateInput
    ProductQuery?: ProductQueryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    googlemail?: StringNullableFilter<"User"> | string | null
    extra?: StringNullableFilter<"User"> | string | null
    contact?: BigIntNullableFilter<"User"> | bigint | number | null
    lastname?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    projects?: ProjectListRelationFilter
    team?: TeamListRelationFilter
    Listing?: ListingListRelationFilter
    Selleraccount?: XOR<SellerAccountNullableScalarRelationFilter, SellerAccountWhereInput> | null
    Dealer?: DealersListRelationFilter
    JobProfle?: XOR<JobProfileNullableScalarRelationFilter, JobProfileWhereInput> | null
    Review?: ReviewListRelationFilter
    WishList?: WishListListRelationFilter
    Member?: MemberListRelationFilter
    ProductQuery?: ProductQueryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    googlemail?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    googlemail?: StringNullableWithAggregatesFilter<"User"> | string | null
    extra?: StringNullableWithAggregatesFilter<"User"> | string | null
    contact?: BigIntNullableWithAggregatesFilter<"User"> | bigint | number | null
    lastname?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type JobProfileWhereInput = {
    AND?: JobProfileWhereInput | JobProfileWhereInput[]
    OR?: JobProfileWhereInput[]
    NOT?: JobProfileWhereInput | JobProfileWhereInput[]
    id?: StringFilter<"JobProfile"> | string
    rating?: IntNullableFilter<"JobProfile"> | number | null
    jobsapplied?: StringNullableListFilter<"JobProfile">
    lastdisabled?: DateTimeNullableFilter<"JobProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"JobProfile"> | Date | string
    workdone?: IntNullableFilter<"JobProfile"> | number | null
    status?: BoolFilter<"JobProfile"> | boolean
    location?: StringNullableFilter<"JobProfile"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JobProfileOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrderInput | SortOrder
    jobsapplied?: SortOrder
    lastdisabled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workdone?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type JobProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobProfileWhereInput | JobProfileWhereInput[]
    OR?: JobProfileWhereInput[]
    NOT?: JobProfileWhereInput | JobProfileWhereInput[]
    rating?: IntNullableFilter<"JobProfile"> | number | null
    jobsapplied?: StringNullableListFilter<"JobProfile">
    lastdisabled?: DateTimeNullableFilter<"JobProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"JobProfile"> | Date | string
    workdone?: IntNullableFilter<"JobProfile"> | number | null
    status?: BoolFilter<"JobProfile"> | boolean
    location?: StringNullableFilter<"JobProfile"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JobProfileOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrderInput | SortOrder
    jobsapplied?: SortOrder
    lastdisabled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workdone?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    _count?: JobProfileCountOrderByAggregateInput
    _avg?: JobProfileAvgOrderByAggregateInput
    _max?: JobProfileMaxOrderByAggregateInput
    _min?: JobProfileMinOrderByAggregateInput
    _sum?: JobProfileSumOrderByAggregateInput
  }

  export type JobProfileScalarWhereWithAggregatesInput = {
    AND?: JobProfileScalarWhereWithAggregatesInput | JobProfileScalarWhereWithAggregatesInput[]
    OR?: JobProfileScalarWhereWithAggregatesInput[]
    NOT?: JobProfileScalarWhereWithAggregatesInput | JobProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobProfile"> | string
    rating?: IntNullableWithAggregatesFilter<"JobProfile"> | number | null
    jobsapplied?: StringNullableListFilter<"JobProfile">
    lastdisabled?: DateTimeNullableWithAggregatesFilter<"JobProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobProfile"> | Date | string
    workdone?: IntNullableWithAggregatesFilter<"JobProfile"> | number | null
    status?: BoolWithAggregatesFilter<"JobProfile"> | boolean
    location?: StringNullableWithAggregatesFilter<"JobProfile"> | string | null
  }

  export type DealersWhereInput = {
    AND?: DealersWhereInput | DealersWhereInput[]
    OR?: DealersWhereInput[]
    NOT?: DealersWhereInput | DealersWhereInput[]
    id?: StringFilter<"Dealers"> | string
    idd?: StringNullableFilter<"Dealers"> | string | null
    name?: StringNullableFilter<"Dealers"> | string | null
    dealeremail?: StringNullableFilter<"Dealers"> | string | null
    dealerid?: StringNullableFilter<"Dealers"> | string | null
    email?: StringNullableFilter<"Dealers"> | string | null
    phonenum?: StringNullableFilter<"Dealers"> | string | null
    verified?: BoolNullableFilter<"Dealers"> | boolean | null
    address?: StringNullableFilter<"Dealers"> | string | null
    category?: StringNullableFilter<"Dealers"> | string | null
    transactionWorth?: IntNullableFilter<"Dealers"> | number | null
    createdAt?: DateTimeFilter<"Dealers"> | Date | string
    Users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DealersOrderByWithRelationInput = {
    id?: SortOrder
    idd?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    dealeremail?: SortOrderInput | SortOrder
    dealerid?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    verified?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    transactionWorth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Users?: UserOrderByWithRelationInput
  }

  export type DealersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealersWhereInput | DealersWhereInput[]
    OR?: DealersWhereInput[]
    NOT?: DealersWhereInput | DealersWhereInput[]
    idd?: StringNullableFilter<"Dealers"> | string | null
    name?: StringNullableFilter<"Dealers"> | string | null
    dealeremail?: StringNullableFilter<"Dealers"> | string | null
    dealerid?: StringNullableFilter<"Dealers"> | string | null
    email?: StringNullableFilter<"Dealers"> | string | null
    phonenum?: StringNullableFilter<"Dealers"> | string | null
    verified?: BoolNullableFilter<"Dealers"> | boolean | null
    address?: StringNullableFilter<"Dealers"> | string | null
    category?: StringNullableFilter<"Dealers"> | string | null
    transactionWorth?: IntNullableFilter<"Dealers"> | number | null
    createdAt?: DateTimeFilter<"Dealers"> | Date | string
    Users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DealersOrderByWithAggregationInput = {
    id?: SortOrder
    idd?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    dealeremail?: SortOrderInput | SortOrder
    dealerid?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    verified?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    transactionWorth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DealersCountOrderByAggregateInput
    _avg?: DealersAvgOrderByAggregateInput
    _max?: DealersMaxOrderByAggregateInput
    _min?: DealersMinOrderByAggregateInput
    _sum?: DealersSumOrderByAggregateInput
  }

  export type DealersScalarWhereWithAggregatesInput = {
    AND?: DealersScalarWhereWithAggregatesInput | DealersScalarWhereWithAggregatesInput[]
    OR?: DealersScalarWhereWithAggregatesInput[]
    NOT?: DealersScalarWhereWithAggregatesInput | DealersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dealers"> | string
    idd?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    name?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    dealeremail?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    dealerid?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    email?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    phonenum?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    verified?: BoolNullableWithAggregatesFilter<"Dealers"> | boolean | null
    address?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    category?: StringNullableWithAggregatesFilter<"Dealers"> | string | null
    transactionWorth?: IntNullableWithAggregatesFilter<"Dealers"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Dealers"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderStatus?: EnumOrderStatusNullableFilter<"Order"> | $Enums.OrderStatus | null
    sellerid?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringFilter<"Order"> | string
    buyerEmail?: StringFilter<"Order"> | string
    buyerContact?: StringNullableFilter<"Order"> | string | null
    buyerId?: StringNullableFilter<"Order"> | string | null
    orders?: StringNullableFilter<"Order"> | string | null
    seller?: XOR<SellerAccountNullableScalarRelationFilter, SellerAccountWhereInput> | null
    product?: ProductsListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderStatus?: SortOrderInput | SortOrder
    sellerid?: SortOrderInput | SortOrder
    buyerName?: SortOrder
    buyerEmail?: SortOrder
    buyerContact?: SortOrderInput | SortOrder
    buyerId?: SortOrderInput | SortOrder
    orders?: SortOrderInput | SortOrder
    seller?: SellerAccountOrderByWithRelationInput
    product?: ProductsOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    orderStatus?: EnumOrderStatusNullableFilter<"Order"> | $Enums.OrderStatus | null
    sellerid?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringFilter<"Order"> | string
    buyerEmail?: StringFilter<"Order"> | string
    buyerContact?: StringNullableFilter<"Order"> | string | null
    buyerId?: StringNullableFilter<"Order"> | string | null
    orders?: StringNullableFilter<"Order"> | string | null
    seller?: XOR<SellerAccountNullableScalarRelationFilter, SellerAccountWhereInput> | null
    product?: ProductsListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderStatus?: SortOrderInput | SortOrder
    sellerid?: SortOrderInput | SortOrder
    buyerName?: SortOrder
    buyerEmail?: SortOrder
    buyerContact?: SortOrderInput | SortOrder
    buyerId?: SortOrderInput | SortOrder
    orders?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderStatus?: EnumOrderStatusNullableWithAggregatesFilter<"Order"> | $Enums.OrderStatus | null
    sellerid?: StringNullableWithAggregatesFilter<"Order"> | string | null
    buyerName?: StringWithAggregatesFilter<"Order"> | string
    buyerEmail?: StringWithAggregatesFilter<"Order"> | string
    buyerContact?: StringNullableWithAggregatesFilter<"Order"> | string | null
    buyerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    orders?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    category?: EnumCategoryFilter<"Project"> | $Enums.Category
    createdAt?: DateTimeFilter<"Project"> | Date | string
    userid?: StringFilter<"Project"> | string
    coverimgUrl?: StringNullableFilter<"Project"> | string | null
    budget?: IntNullableFilter<"Project"> | number | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    member?: MemberListRelationFilter
    Task?: TaskListRelationFilter
    finance?: XOR<FinanceNullableScalarRelationFilter, FinanceWhereInput> | null
    documents?: DocumentListRelationFilter
    ScheduledMsg?: ScheduleMsgListRelationFilter
    Inventory?: InventoryListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    userid?: SortOrder
    coverimgUrl?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    member?: MemberOrderByRelationAggregateInput
    Task?: TaskOrderByRelationAggregateInput
    finance?: FinanceOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    ScheduledMsg?: ScheduleMsgOrderByRelationAggregateInput
    Inventory?: InventoryOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    category?: EnumCategoryFilter<"Project"> | $Enums.Category
    createdAt?: DateTimeFilter<"Project"> | Date | string
    userid?: StringFilter<"Project"> | string
    coverimgUrl?: StringNullableFilter<"Project"> | string | null
    budget?: IntNullableFilter<"Project"> | number | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    member?: MemberListRelationFilter
    Task?: TaskListRelationFilter
    finance?: XOR<FinanceNullableScalarRelationFilter, FinanceWhereInput> | null
    documents?: DocumentListRelationFilter
    ScheduledMsg?: ScheduleMsgListRelationFilter
    Inventory?: InventoryListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    userid?: SortOrder
    coverimgUrl?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    category?: EnumCategoryWithAggregatesFilter<"Project"> | $Enums.Category
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    userid?: StringWithAggregatesFilter<"Project"> | string
    coverimgUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    budget?: IntNullableWithAggregatesFilter<"Project"> | number | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    userid?: StringNullableFilter<"Member"> | string | null
    projectId?: StringFilter<"Member"> | string
    name?: StringNullableFilter<"Member"> | string | null
    useremail?: StringFilter<"Member"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    projectId?: SortOrder
    name?: SortOrderInput | SortOrder
    useremail?: SortOrder
    Project?: ProjectOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    userid?: StringNullableFilter<"Member"> | string | null
    projectId?: StringFilter<"Member"> | string
    name?: StringNullableFilter<"Member"> | string | null
    useremail?: StringFilter<"Member"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    projectId?: SortOrder
    name?: SortOrderInput | SortOrder
    useremail?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    userid?: StringNullableWithAggregatesFilter<"Member"> | string | null
    projectId?: StringWithAggregatesFilter<"Member"> | string
    name?: StringNullableWithAggregatesFilter<"Member"> | string | null
    useremail?: StringWithAggregatesFilter<"Member"> | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    available?: BoolNullableFilter<"Inventory"> | boolean | null
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    value?: BigIntFilter<"Inventory"> | bigint | number
    stock?: StringNullableFilter<"Inventory"> | string | null
    valueperpeice?: StringNullableFilter<"Inventory"> | string | null
    projectId?: StringFilter<"Inventory"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    available?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    stock?: SortOrderInput | SortOrder
    valueperpeice?: SortOrderInput | SortOrder
    projectId?: SortOrder
    Project?: ProjectOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    available?: BoolNullableFilter<"Inventory"> | boolean | null
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    value?: BigIntFilter<"Inventory"> | bigint | number
    stock?: StringNullableFilter<"Inventory"> | string | null
    valueperpeice?: StringNullableFilter<"Inventory"> | string | null
    projectId?: StringFilter<"Inventory"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    available?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    stock?: SortOrderInput | SortOrder
    valueperpeice?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    available?: BoolNullableWithAggregatesFilter<"Inventory"> | boolean | null
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    value?: BigIntWithAggregatesFilter<"Inventory"> | bigint | number
    stock?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    valueperpeice?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    projectId?: StringWithAggregatesFilter<"Inventory"> | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    email?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    verified?: BoolFilter<"Team"> | boolean
    phonenum?: IntFilter<"Team"> | number
    useriid?: StringNullableFilter<"Team"> | string | null
    createdat?: DateTimeFilter<"Team"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    verified?: SortOrder
    phonenum?: SortOrder
    useriid?: SortOrderInput | SortOrder
    createdat?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    email?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    verified?: BoolFilter<"Team"> | boolean
    phonenum?: IntFilter<"Team"> | number
    useriid?: StringNullableFilter<"Team"> | string | null
    createdat?: DateTimeFilter<"Team"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    verified?: SortOrder
    phonenum?: SortOrder
    useriid?: SortOrderInput | SortOrder
    createdat?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    email?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    verified?: BoolWithAggregatesFilter<"Team"> | boolean
    phonenum?: IntWithAggregatesFilter<"Team"> | number
    useriid?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdat?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type ListingWhereInput = {
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    id?: StringFilter<"Listing"> | string
    image?: StringFilter<"Listing"> | string
    rating?: FloatFilter<"Listing"> | number
    address?: StringFilter<"Listing"> | string
    soldout?: BoolFilter<"Listing"> | boolean
    description?: StringNullableFilter<"Listing"> | string | null
    ownerId?: StringNullableFilter<"Listing"> | string | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ListingOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    address?: SortOrder
    soldout?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
  }

  export type ListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    image?: StringFilter<"Listing"> | string
    rating?: FloatFilter<"Listing"> | number
    address?: StringFilter<"Listing"> | string
    soldout?: BoolFilter<"Listing"> | boolean
    description?: StringNullableFilter<"Listing"> | string | null
    ownerId?: StringNullableFilter<"Listing"> | string | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ListingOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    address?: SortOrder
    soldout?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    _count?: ListingCountOrderByAggregateInput
    _avg?: ListingAvgOrderByAggregateInput
    _max?: ListingMaxOrderByAggregateInput
    _min?: ListingMinOrderByAggregateInput
    _sum?: ListingSumOrderByAggregateInput
  }

  export type ListingScalarWhereWithAggregatesInput = {
    AND?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    OR?: ListingScalarWhereWithAggregatesInput[]
    NOT?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Listing"> | string
    image?: StringWithAggregatesFilter<"Listing"> | string
    rating?: FloatWithAggregatesFilter<"Listing"> | number
    address?: StringWithAggregatesFilter<"Listing"> | string
    soldout?: BoolWithAggregatesFilter<"Listing"> | boolean
    description?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    task?: StringFilter<"Task"> | string
    team?: StringNullableListFilter<"Task">
    amount?: IntNullableFilter<"Task"> | number | null
    startdate?: StringFilter<"Task"> | string
    deadline?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    supplier?: StringNullableListFilter<"Task">
    subtasks?: StringNullableListFilter<"Task">
    inventories?: StringNullableListFilter<"Task">
    teamlead?: StringNullableFilter<"Task"> | string | null
    priority?: StringNullableFilter<"Task"> | string | null
    status?: BoolNullableFilter<"Task"> | boolean | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    Project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    team?: SortOrder
    amount?: SortOrderInput | SortOrder
    startdate?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    supplier?: SortOrder
    subtasks?: SortOrder
    inventories?: SortOrder
    teamlead?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Project?: ProjectOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    task?: StringFilter<"Task"> | string
    team?: StringNullableListFilter<"Task">
    amount?: IntNullableFilter<"Task"> | number | null
    startdate?: StringFilter<"Task"> | string
    deadline?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    supplier?: StringNullableListFilter<"Task">
    subtasks?: StringNullableListFilter<"Task">
    inventories?: StringNullableListFilter<"Task">
    teamlead?: StringNullableFilter<"Task"> | string | null
    priority?: StringNullableFilter<"Task"> | string | null
    status?: BoolNullableFilter<"Task"> | boolean | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    Project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    team?: SortOrder
    amount?: SortOrderInput | SortOrder
    startdate?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    supplier?: SortOrder
    subtasks?: SortOrder
    inventories?: SortOrder
    teamlead?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    task?: StringWithAggregatesFilter<"Task"> | string
    team?: StringNullableListFilter<"Task">
    amount?: IntNullableWithAggregatesFilter<"Task"> | number | null
    startdate?: StringWithAggregatesFilter<"Task"> | string
    deadline?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    supplier?: StringNullableListFilter<"Task">
    subtasks?: StringNullableListFilter<"Task">
    inventories?: StringNullableListFilter<"Task">
    teamlead?: StringNullableWithAggregatesFilter<"Task"> | string | null
    priority?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: BoolNullableWithAggregatesFilter<"Task"> | boolean | null
    projectId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    gstrate?: IntNullableFilter<"Transaction"> | number | null
    dealer?: StringFilter<"Transaction"> | string
    status?: EnumStatusNullableFilter<"Transaction"> | $Enums.Status | null
    proof?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTypetransFilter<"Transaction"> | $Enums.Typetrans
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    financeId?: StringFilter<"Transaction"> | string
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    gstrate?: SortOrderInput | SortOrder
    dealer?: SortOrder
    status?: SortOrderInput | SortOrder
    proof?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    finance?: FinanceOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: IntFilter<"Transaction"> | number
    gstrate?: IntNullableFilter<"Transaction"> | number | null
    dealer?: StringFilter<"Transaction"> | string
    status?: EnumStatusNullableFilter<"Transaction"> | $Enums.Status | null
    proof?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTypetransFilter<"Transaction"> | $Enums.Typetrans
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    financeId?: StringFilter<"Transaction"> | string
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    gstrate?: SortOrderInput | SortOrder
    dealer?: SortOrder
    status?: SortOrderInput | SortOrder
    proof?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    gstrate?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    dealer?: StringWithAggregatesFilter<"Transaction"> | string
    status?: EnumStatusNullableWithAggregatesFilter<"Transaction"> | $Enums.Status | null
    proof?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTypetransWithAggregatesFilter<"Transaction"> | $Enums.Typetrans
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    financeId?: StringWithAggregatesFilter<"Transaction"> | string
  }

  export type FinanceWhereInput = {
    AND?: FinanceWhereInput | FinanceWhereInput[]
    OR?: FinanceWhereInput[]
    NOT?: FinanceWhereInput | FinanceWhereInput[]
    id?: StringFilter<"Finance"> | string
    income?: IntNullableFilter<"Finance"> | number | null
    expenditure?: IntNullableFilter<"Finance"> | number | null
    budget?: IntNullableFilter<"Finance"> | number | null
    balance?: IntNullableFilter<"Finance"> | number | null
    MPIN?: StringNullableFilter<"Finance"> | string | null
    transaction?: TransactionListRelationFilter
    finance?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    notes?: NoteListRelationFilter
    remainder?: RemaindersListRelationFilter
  }

  export type FinanceOrderByWithRelationInput = {
    id?: SortOrder
    income?: SortOrderInput | SortOrder
    expenditure?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    MPIN?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByRelationAggregateInput
    finance?: ProjectOrderByWithRelationInput
    notes?: NoteOrderByRelationAggregateInput
    remainder?: RemaindersOrderByRelationAggregateInput
  }

  export type FinanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinanceWhereInput | FinanceWhereInput[]
    OR?: FinanceWhereInput[]
    NOT?: FinanceWhereInput | FinanceWhereInput[]
    income?: IntNullableFilter<"Finance"> | number | null
    expenditure?: IntNullableFilter<"Finance"> | number | null
    budget?: IntNullableFilter<"Finance"> | number | null
    balance?: IntNullableFilter<"Finance"> | number | null
    MPIN?: StringNullableFilter<"Finance"> | string | null
    transaction?: TransactionListRelationFilter
    finance?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    notes?: NoteListRelationFilter
    remainder?: RemaindersListRelationFilter
  }, "id">

  export type FinanceOrderByWithAggregationInput = {
    id?: SortOrder
    income?: SortOrderInput | SortOrder
    expenditure?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    MPIN?: SortOrderInput | SortOrder
    _count?: FinanceCountOrderByAggregateInput
    _avg?: FinanceAvgOrderByAggregateInput
    _max?: FinanceMaxOrderByAggregateInput
    _min?: FinanceMinOrderByAggregateInput
    _sum?: FinanceSumOrderByAggregateInput
  }

  export type FinanceScalarWhereWithAggregatesInput = {
    AND?: FinanceScalarWhereWithAggregatesInput | FinanceScalarWhereWithAggregatesInput[]
    OR?: FinanceScalarWhereWithAggregatesInput[]
    NOT?: FinanceScalarWhereWithAggregatesInput | FinanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Finance"> | string
    income?: IntNullableWithAggregatesFilter<"Finance"> | number | null
    expenditure?: IntNullableWithAggregatesFilter<"Finance"> | number | null
    budget?: IntNullableWithAggregatesFilter<"Finance"> | number | null
    balance?: IntNullableWithAggregatesFilter<"Finance"> | number | null
    MPIN?: StringNullableWithAggregatesFilter<"Finance"> | string | null
  }

  export type RemaindersWhereInput = {
    AND?: RemaindersWhereInput | RemaindersWhereInput[]
    OR?: RemaindersWhereInput[]
    NOT?: RemaindersWhereInput | RemaindersWhereInput[]
    id?: StringFilter<"Remainders"> | string
    amount?: IntFilter<"Remainders"> | number
    dealer?: StringFilter<"Remainders"> | string
    date?: DateTimeFilter<"Remainders"> | Date | string
    financeId?: StringFilter<"Remainders"> | string
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }

  export type RemaindersOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    dealer?: SortOrder
    date?: SortOrder
    financeId?: SortOrder
    finance?: FinanceOrderByWithRelationInput
  }

  export type RemaindersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RemaindersWhereInput | RemaindersWhereInput[]
    OR?: RemaindersWhereInput[]
    NOT?: RemaindersWhereInput | RemaindersWhereInput[]
    amount?: IntFilter<"Remainders"> | number
    dealer?: StringFilter<"Remainders"> | string
    date?: DateTimeFilter<"Remainders"> | Date | string
    financeId?: StringFilter<"Remainders"> | string
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }, "id">

  export type RemaindersOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    dealer?: SortOrder
    date?: SortOrder
    financeId?: SortOrder
    _count?: RemaindersCountOrderByAggregateInput
    _avg?: RemaindersAvgOrderByAggregateInput
    _max?: RemaindersMaxOrderByAggregateInput
    _min?: RemaindersMinOrderByAggregateInput
    _sum?: RemaindersSumOrderByAggregateInput
  }

  export type RemaindersScalarWhereWithAggregatesInput = {
    AND?: RemaindersScalarWhereWithAggregatesInput | RemaindersScalarWhereWithAggregatesInput[]
    OR?: RemaindersScalarWhereWithAggregatesInput[]
    NOT?: RemaindersScalarWhereWithAggregatesInput | RemaindersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Remainders"> | string
    amount?: IntWithAggregatesFilter<"Remainders"> | number
    dealer?: StringWithAggregatesFilter<"Remainders"> | string
    date?: DateTimeWithAggregatesFilter<"Remainders"> | Date | string
    financeId?: StringWithAggregatesFilter<"Remainders"> | string
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    title?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    financeId?: StringFilter<"Note"> | string
    type?: EnumNoteTypeNullableFilter<"Note"> | $Enums.NoteType | null
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    type?: SortOrderInput | SortOrder
    finance?: FinanceOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    title?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    financeId?: StringFilter<"Note"> | string
    type?: EnumNoteTypeNullableFilter<"Note"> | $Enums.NoteType | null
    finance?: XOR<FinanceScalarRelationFilter, FinanceWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    type?: SortOrderInput | SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    title?: StringNullableWithAggregatesFilter<"Note"> | string | null
    content?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    financeId?: StringWithAggregatesFilter<"Note"> | string
    type?: EnumNoteTypeNullableWithAggregatesFilter<"Note"> | $Enums.NoteType | null
  }

  export type ScheduleMsgWhereInput = {
    AND?: ScheduleMsgWhereInput | ScheduleMsgWhereInput[]
    OR?: ScheduleMsgWhereInput[]
    NOT?: ScheduleMsgWhereInput | ScheduleMsgWhereInput[]
    id?: StringFilter<"ScheduleMsg"> | string
    email?: StringNullableFilter<"ScheduleMsg"> | string | null
    phonenum?: StringNullableFilter<"ScheduleMsg"> | string | null
    Datetime?: StringNullableFilter<"ScheduleMsg"> | string | null
    type?: EnumMsgtypeNullableFilter<"ScheduleMsg"> | $Enums.Msgtype | null
    text?: StringNullableFilter<"ScheduleMsg"> | string | null
    status?: EnumScheduleMsgStatusNullableFilter<"ScheduleMsg"> | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFilter<"ScheduleMsg"> | Date | string
    projectId?: StringFilter<"ScheduleMsg"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ScheduleMsgOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    Datetime?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ScheduleMsgWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleMsgWhereInput | ScheduleMsgWhereInput[]
    OR?: ScheduleMsgWhereInput[]
    NOT?: ScheduleMsgWhereInput | ScheduleMsgWhereInput[]
    email?: StringNullableFilter<"ScheduleMsg"> | string | null
    phonenum?: StringNullableFilter<"ScheduleMsg"> | string | null
    Datetime?: StringNullableFilter<"ScheduleMsg"> | string | null
    type?: EnumMsgtypeNullableFilter<"ScheduleMsg"> | $Enums.Msgtype | null
    text?: StringNullableFilter<"ScheduleMsg"> | string | null
    status?: EnumScheduleMsgStatusNullableFilter<"ScheduleMsg"> | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFilter<"ScheduleMsg"> | Date | string
    projectId?: StringFilter<"ScheduleMsg"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ScheduleMsgOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phonenum?: SortOrderInput | SortOrder
    Datetime?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    _count?: ScheduleMsgCountOrderByAggregateInput
    _max?: ScheduleMsgMaxOrderByAggregateInput
    _min?: ScheduleMsgMinOrderByAggregateInput
  }

  export type ScheduleMsgScalarWhereWithAggregatesInput = {
    AND?: ScheduleMsgScalarWhereWithAggregatesInput | ScheduleMsgScalarWhereWithAggregatesInput[]
    OR?: ScheduleMsgScalarWhereWithAggregatesInput[]
    NOT?: ScheduleMsgScalarWhereWithAggregatesInput | ScheduleMsgScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleMsg"> | string
    email?: StringNullableWithAggregatesFilter<"ScheduleMsg"> | string | null
    phonenum?: StringNullableWithAggregatesFilter<"ScheduleMsg"> | string | null
    Datetime?: StringNullableWithAggregatesFilter<"ScheduleMsg"> | string | null
    type?: EnumMsgtypeNullableWithAggregatesFilter<"ScheduleMsg"> | $Enums.Msgtype | null
    text?: StringNullableWithAggregatesFilter<"ScheduleMsg"> | string | null
    status?: EnumScheduleMsgStatusNullableWithAggregatesFilter<"ScheduleMsg"> | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleMsg"> | Date | string
    projectId?: StringWithAggregatesFilter<"ScheduleMsg"> | string
  }

  export type SellerAccountWhereInput = {
    AND?: SellerAccountWhereInput | SellerAccountWhereInput[]
    OR?: SellerAccountWhereInput[]
    NOT?: SellerAccountWhereInput | SellerAccountWhereInput[]
    id?: StringFilter<"SellerAccount"> | string
    sales?: StringNullableFilter<"SellerAccount"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: ProductsListRelationFilter
    Order?: OrderListRelationFilter
  }

  export type SellerAccountOrderByWithRelationInput = {
    id?: SortOrder
    sales?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Product?: ProductsOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
  }

  export type SellerAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellerAccountWhereInput | SellerAccountWhereInput[]
    OR?: SellerAccountWhereInput[]
    NOT?: SellerAccountWhereInput | SellerAccountWhereInput[]
    sales?: StringNullableFilter<"SellerAccount"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: ProductsListRelationFilter
    Order?: OrderListRelationFilter
  }, "id">

  export type SellerAccountOrderByWithAggregationInput = {
    id?: SortOrder
    sales?: SortOrderInput | SortOrder
    _count?: SellerAccountCountOrderByAggregateInput
    _max?: SellerAccountMaxOrderByAggregateInput
    _min?: SellerAccountMinOrderByAggregateInput
  }

  export type SellerAccountScalarWhereWithAggregatesInput = {
    AND?: SellerAccountScalarWhereWithAggregatesInput | SellerAccountScalarWhereWithAggregatesInput[]
    OR?: SellerAccountScalarWhereWithAggregatesInput[]
    NOT?: SellerAccountScalarWhereWithAggregatesInput | SellerAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellerAccount"> | string
    sales?: StringNullableWithAggregatesFilter<"SellerAccount"> | string | null
  }

  export type ProductsWhereInput = {
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    id?: StringFilter<"Products"> | string
    name?: StringFilter<"Products"> | string
    price?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    rating?: StringNullableFilter<"Products"> | string | null
    imageurl?: StringNullableFilter<"Products"> | string | null
    quantity?: StringNullableFilter<"Products"> | string | null
    sellerName?: StringFilter<"Products"> | string
    expirydate?: StringNullableFilter<"Products"> | string | null
    category?: EnumCategoriesFilter<"Products"> | $Enums.Categories
    specialmsg?: StringNullableFilter<"Products"> | string | null
    stock?: StringNullableFilter<"Products"> | string | null
    contact?: StringNullableFilter<"Products"> | string | null
    questions?: StringNullableListFilter<"Products">
    mode?: EnumModeNullableFilter<"Products"> | $Enums.Mode | null
    type?: EnumTypeFilter<"Products"> | $Enums.Type
    offers?: StringNullableFilter<"Products"> | string | null
    sellerid?: StringFilter<"Products"> | string
    Review?: ReviewListRelationFilter
    Seller?: XOR<SellerAccountScalarRelationFilter, SellerAccountWhereInput>
    order?: OrderListRelationFilter
    WishList?: WishListListRelationFilter
    Queries?: ProductQueryListRelationFilter
  }

  export type ProductsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    imageurl?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    sellerName?: SortOrder
    expirydate?: SortOrderInput | SortOrder
    category?: SortOrder
    specialmsg?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    questions?: SortOrder
    mode?: SortOrderInput | SortOrder
    type?: SortOrder
    offers?: SortOrderInput | SortOrder
    sellerid?: SortOrder
    Review?: ReviewOrderByRelationAggregateInput
    Seller?: SellerAccountOrderByWithRelationInput
    order?: OrderOrderByRelationAggregateInput
    WishList?: WishListOrderByRelationAggregateInput
    Queries?: ProductQueryOrderByRelationAggregateInput
  }

  export type ProductsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductsWhereInput | ProductsWhereInput[]
    OR?: ProductsWhereInput[]
    NOT?: ProductsWhereInput | ProductsWhereInput[]
    name?: StringFilter<"Products"> | string
    price?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    rating?: StringNullableFilter<"Products"> | string | null
    imageurl?: StringNullableFilter<"Products"> | string | null
    quantity?: StringNullableFilter<"Products"> | string | null
    sellerName?: StringFilter<"Products"> | string
    expirydate?: StringNullableFilter<"Products"> | string | null
    category?: EnumCategoriesFilter<"Products"> | $Enums.Categories
    specialmsg?: StringNullableFilter<"Products"> | string | null
    stock?: StringNullableFilter<"Products"> | string | null
    contact?: StringNullableFilter<"Products"> | string | null
    questions?: StringNullableListFilter<"Products">
    mode?: EnumModeNullableFilter<"Products"> | $Enums.Mode | null
    type?: EnumTypeFilter<"Products"> | $Enums.Type
    offers?: StringNullableFilter<"Products"> | string | null
    sellerid?: StringFilter<"Products"> | string
    Review?: ReviewListRelationFilter
    Seller?: XOR<SellerAccountScalarRelationFilter, SellerAccountWhereInput>
    order?: OrderListRelationFilter
    WishList?: WishListListRelationFilter
    Queries?: ProductQueryListRelationFilter
  }, "id">

  export type ProductsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    imageurl?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    sellerName?: SortOrder
    expirydate?: SortOrderInput | SortOrder
    category?: SortOrder
    specialmsg?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    questions?: SortOrder
    mode?: SortOrderInput | SortOrder
    type?: SortOrder
    offers?: SortOrderInput | SortOrder
    sellerid?: SortOrder
    _count?: ProductsCountOrderByAggregateInput
    _max?: ProductsMaxOrderByAggregateInput
    _min?: ProductsMinOrderByAggregateInput
  }

  export type ProductsScalarWhereWithAggregatesInput = {
    AND?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    OR?: ProductsScalarWhereWithAggregatesInput[]
    NOT?: ProductsScalarWhereWithAggregatesInput | ProductsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Products"> | string
    name?: StringWithAggregatesFilter<"Products"> | string
    price?: StringNullableWithAggregatesFilter<"Products"> | string | null
    description?: StringNullableWithAggregatesFilter<"Products"> | string | null
    rating?: StringNullableWithAggregatesFilter<"Products"> | string | null
    imageurl?: StringNullableWithAggregatesFilter<"Products"> | string | null
    quantity?: StringNullableWithAggregatesFilter<"Products"> | string | null
    sellerName?: StringWithAggregatesFilter<"Products"> | string
    expirydate?: StringNullableWithAggregatesFilter<"Products"> | string | null
    category?: EnumCategoriesWithAggregatesFilter<"Products"> | $Enums.Categories
    specialmsg?: StringNullableWithAggregatesFilter<"Products"> | string | null
    stock?: StringNullableWithAggregatesFilter<"Products"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Products"> | string | null
    questions?: StringNullableListFilter<"Products">
    mode?: EnumModeNullableWithAggregatesFilter<"Products"> | $Enums.Mode | null
    type?: EnumTypeWithAggregatesFilter<"Products"> | $Enums.Type
    offers?: StringNullableWithAggregatesFilter<"Products"> | string | null
    sellerid?: StringWithAggregatesFilter<"Products"> | string
  }

  export type ProductQueryWhereInput = {
    AND?: ProductQueryWhereInput | ProductQueryWhereInput[]
    OR?: ProductQueryWhereInput[]
    NOT?: ProductQueryWhereInput | ProductQueryWhereInput[]
    id?: IntFilter<"ProductQuery"> | number
    username?: StringNullableFilter<"ProductQuery"> | string | null
    userid?: StringFilter<"ProductQuery"> | string
    name?: StringNullableFilter<"ProductQuery"> | string | null
    contact?: StringNullableFilter<"ProductQuery"> | string | null
    additionalQueies?: StringNullableFilter<"ProductQuery"> | string | null
    question?: StringNullableListFilter<"ProductQuery">
    answers?: StringNullableListFilter<"ProductQuery">
    productId?: StringNullableFilter<"ProductQuery"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }

  export type ProductQueryOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    userid?: SortOrder
    name?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    additionalQueies?: SortOrderInput | SortOrder
    question?: SortOrder
    answers?: SortOrder
    productId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Product?: ProductsOrderByWithRelationInput
  }

  export type ProductQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductQueryWhereInput | ProductQueryWhereInput[]
    OR?: ProductQueryWhereInput[]
    NOT?: ProductQueryWhereInput | ProductQueryWhereInput[]
    username?: StringNullableFilter<"ProductQuery"> | string | null
    userid?: StringFilter<"ProductQuery"> | string
    name?: StringNullableFilter<"ProductQuery"> | string | null
    contact?: StringNullableFilter<"ProductQuery"> | string | null
    additionalQueies?: StringNullableFilter<"ProductQuery"> | string | null
    question?: StringNullableListFilter<"ProductQuery">
    answers?: StringNullableListFilter<"ProductQuery">
    productId?: StringNullableFilter<"ProductQuery"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }, "id">

  export type ProductQueryOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    userid?: SortOrder
    name?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    additionalQueies?: SortOrderInput | SortOrder
    question?: SortOrder
    answers?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: ProductQueryCountOrderByAggregateInput
    _avg?: ProductQueryAvgOrderByAggregateInput
    _max?: ProductQueryMaxOrderByAggregateInput
    _min?: ProductQueryMinOrderByAggregateInput
    _sum?: ProductQuerySumOrderByAggregateInput
  }

  export type ProductQueryScalarWhereWithAggregatesInput = {
    AND?: ProductQueryScalarWhereWithAggregatesInput | ProductQueryScalarWhereWithAggregatesInput[]
    OR?: ProductQueryScalarWhereWithAggregatesInput[]
    NOT?: ProductQueryScalarWhereWithAggregatesInput | ProductQueryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductQuery"> | number
    username?: StringNullableWithAggregatesFilter<"ProductQuery"> | string | null
    userid?: StringWithAggregatesFilter<"ProductQuery"> | string
    name?: StringNullableWithAggregatesFilter<"ProductQuery"> | string | null
    contact?: StringNullableWithAggregatesFilter<"ProductQuery"> | string | null
    additionalQueies?: StringNullableWithAggregatesFilter<"ProductQuery"> | string | null
    question?: StringNullableListFilter<"ProductQuery">
    answers?: StringNullableListFilter<"ProductQuery">
    productId?: StringNullableWithAggregatesFilter<"ProductQuery"> | string | null
  }

  export type WishListWhereInput = {
    AND?: WishListWhereInput | WishListWhereInput[]
    OR?: WishListWhereInput[]
    NOT?: WishListWhereInput | WishListWhereInput[]
    id?: StringFilter<"WishList"> | string
    userid?: StringNullableFilter<"WishList"> | string | null
    productid?: StringNullableFilter<"WishList"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }

  export type WishListOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Product?: ProductsOrderByWithRelationInput
  }

  export type WishListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WishListWhereInput | WishListWhereInput[]
    OR?: WishListWhereInput[]
    NOT?: WishListWhereInput | WishListWhereInput[]
    userid?: StringNullableFilter<"WishList"> | string | null
    productid?: StringNullableFilter<"WishList"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }, "id">

  export type WishListOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    _count?: WishListCountOrderByAggregateInput
    _max?: WishListMaxOrderByAggregateInput
    _min?: WishListMinOrderByAggregateInput
  }

  export type WishListScalarWhereWithAggregatesInput = {
    AND?: WishListScalarWhereWithAggregatesInput | WishListScalarWhereWithAggregatesInput[]
    OR?: WishListScalarWhereWithAggregatesInput[]
    NOT?: WishListScalarWhereWithAggregatesInput | WishListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WishList"> | string
    userid?: StringNullableWithAggregatesFilter<"WishList"> | string | null
    productid?: StringNullableWithAggregatesFilter<"WishList"> | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: FloatNullableFilter<"Review"> | number | null
    review?: StringNullableFilter<"Review"> | string | null
    userid?: StringNullableFilter<"Review"> | string | null
    username?: StringNullableFilter<"Review"> | string | null
    productId?: StringNullableFilter<"Review"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    Product?: ProductsOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    rating?: FloatNullableFilter<"Review"> | number | null
    review?: StringNullableFilter<"Review"> | string | null
    userid?: StringNullableFilter<"Review"> | string | null
    username?: StringNullableFilter<"Review"> | string | null
    productId?: StringNullableFilter<"Review"> | string | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Product?: XOR<ProductsNullableScalarRelationFilter, ProductsWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    rating?: FloatNullableWithAggregatesFilter<"Review"> | number | null
    review?: StringNullableWithAggregatesFilter<"Review"> | string | null
    userid?: StringNullableWithAggregatesFilter<"Review"> | string | null
    username?: StringNullableWithAggregatesFilter<"Review"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Review"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringNullableFilter<"Document"> | string | null
    originalName?: StringNullableFilter<"Document"> | string | null
    title?: StringFilter<"Document"> | string
    storageUrl?: StringNullableFilter<"Document"> | string | null
    uploadDate?: DateTimeFilter<"Document"> | Date | string
    isEncrypted?: BoolFilter<"Document"> | boolean
    notes?: StringNullableFilter<"Document"> | string | null
    projectId?: StringFilter<"Document"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    originalName?: SortOrderInput | SortOrder
    title?: SortOrder
    storageUrl?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    isEncrypted?: SortOrder
    notes?: SortOrderInput | SortOrder
    projectId?: SortOrder
    Project?: ProjectOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringNullableFilter<"Document"> | string | null
    originalName?: StringNullableFilter<"Document"> | string | null
    title?: StringFilter<"Document"> | string
    storageUrl?: StringNullableFilter<"Document"> | string | null
    uploadDate?: DateTimeFilter<"Document"> | Date | string
    isEncrypted?: BoolFilter<"Document"> | boolean
    notes?: StringNullableFilter<"Document"> | string | null
    projectId?: StringFilter<"Document"> | string
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    originalName?: SortOrderInput | SortOrder
    title?: SortOrder
    storageUrl?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    isEncrypted?: SortOrder
    notes?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    originalName?: StringNullableWithAggregatesFilter<"Document"> | string | null
    title?: StringWithAggregatesFilter<"Document"> | string
    storageUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadDate?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    isEncrypted?: BoolWithAggregatesFilter<"Document"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Document"> | string | null
    projectId?: StringWithAggregatesFilter<"Document"> | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobProfileCreateInput = {
    rating?: number | null
    jobsapplied?: JobProfileCreatejobsappliedInput | string[]
    lastdisabled?: Date | string | null
    createdAt?: Date | string
    workdone?: number | null
    status: boolean
    location?: string | null
    User?: UserCreateNestedOneWithoutJobProfleInput
  }

  export type JobProfileUncheckedCreateInput = {
    id?: string
    rating?: number | null
    jobsapplied?: JobProfileCreatejobsappliedInput | string[]
    lastdisabled?: Date | string | null
    createdAt?: Date | string
    workdone?: number | null
    status: boolean
    location?: string | null
  }

  export type JobProfileUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutJobProfleNestedInput
  }

  export type JobProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobProfileCreateManyInput = {
    id?: string
    rating?: number | null
    jobsapplied?: JobProfileCreatejobsappliedInput | string[]
    lastdisabled?: Date | string | null
    createdAt?: Date | string
    workdone?: number | null
    status: boolean
    location?: string | null
  }

  export type JobProfileUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealersCreateInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
    Users?: UserCreateNestedOneWithoutDealerInput
  }

  export type DealersUncheckedCreateInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    dealerid?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
  }

  export type DealersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UserUpdateOneWithoutDealerNestedInput
  }

  export type DealersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    dealerid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealersCreateManyInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    dealerid?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
  }

  export type DealersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    dealerid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
    seller?: SellerAccountCreateNestedOneWithoutOrderInput
    product?: ProductsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    sellerid?: string | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
    product?: ProductsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: SellerAccountUpdateOneWithoutOrderNestedInput
    product?: ProductsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    sellerid?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    sellerid?: string | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    sellerid?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MemberCreateInput = {
    id?: string
    userid?: string | null
    name?: string | null
    Project: ProjectCreateNestedOneWithoutMemberInput
    User: UserCreateNestedOneWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    userid?: string | null
    projectId: string
    name?: string | null
    useremail: string
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutMemberNestedInput
    User?: UserUpdateOneRequiredWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    useremail?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyInput = {
    id?: string
    userid?: string | null
    projectId: string
    name?: string | null
    useremail: string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    useremail?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
    Project: ProjectCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
    projectId: string
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryCreateManyInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
    projectId: string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    email: string
    name: string
    verified: boolean
    phonenum: number
    createdat?: Date | string
    User?: UserCreateNestedOneWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    verified: boolean
    phonenum: number
    useriid?: string | null
    createdat?: Date | string
  }

  export type TeamUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    useriid?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyInput = {
    id?: number
    email: string
    name: string
    verified: boolean
    phonenum: number
    useriid?: string | null
    createdat?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    useriid?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
    owner?: UserCreateNestedOneWithoutListingInput
  }

  export type ListingUncheckedCreateInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
    ownerId?: string | null
  }

  export type ListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListingCreateManyInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
    ownerId?: string | null
  }

  export type ListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    createdAt?: Date | string
    Project?: ProjectCreateNestedOneWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    projectId?: string | null
    createdAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Project?: ProjectUpdateOneWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    projectId?: string | null
    createdAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
    finance: FinanceCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
    financeId: string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finance?: FinanceUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
    financeId: string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
  }

  export type FinanceCreateInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionCreateNestedManyWithoutFinanceInput
    finance?: ProjectCreateNestedOneWithoutFinanceInput
    notes?: NoteCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUncheckedCreateInput = {
    id?: string
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutFinanceInput
    notes?: NoteUncheckedCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersUncheckedCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUpdateInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateManyWithoutFinanceNestedInput
    finance?: ProjectUpdateOneWithoutFinanceNestedInput
    notes?: NoteUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutFinanceNestedInput
    notes?: NoteUncheckedUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUncheckedUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceCreateManyInput = {
    id?: string
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
  }

  export type FinanceUpdateManyMutationInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RemaindersCreateInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
    finance: FinanceCreateNestedOneWithoutRemainderInput
  }

  export type RemaindersUncheckedCreateInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
    financeId: string
  }

  export type RemaindersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    finance?: FinanceUpdateOneRequiredWithoutRemainderNestedInput
  }

  export type RemaindersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
  }

  export type RemaindersCreateManyInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
    financeId: string
  }

  export type RemaindersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemaindersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
  }

  export type NoteCreateInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    type?: $Enums.NoteType | null
    finance: FinanceCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    financeId: string
    type?: $Enums.NoteType | null
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
    finance?: FinanceUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type NoteCreateManyInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    financeId: string
    type?: $Enums.NoteType | null
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    financeId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type ScheduleMsgCreateInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutScheduledMsgInput
  }

  export type ScheduleMsgUncheckedCreateInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
    projectId: string
  }

  export type ScheduleMsgUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutScheduledMsgNestedInput
  }

  export type ScheduleMsgUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleMsgCreateManyInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
    projectId: string
  }

  export type ScheduleMsgUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleMsgUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SellerAccountCreateInput = {
    sales?: string | null
    User?: UserCreateNestedOneWithoutSelleraccountInput
    Product?: ProductsCreateNestedManyWithoutSellerInput
    Order?: OrderCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountUncheckedCreateInput = {
    id: string
    sales?: string | null
    Product?: ProductsUncheckedCreateNestedManyWithoutSellerInput
    Order?: OrderUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountUpdateInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutSelleraccountNestedInput
    Product?: ProductsUpdateManyWithoutSellerNestedInput
    Order?: OrderUpdateManyWithoutSellerNestedInput
  }

  export type SellerAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductsUncheckedUpdateManyWithoutSellerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type SellerAccountCreateManyInput = {
    id: string
    sales?: string | null
  }

  export type SellerAccountUpdateManyMutationInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsCreateInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewCreateNestedManyWithoutProductInput
    Seller: SellerAccountCreateNestedOneWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    WishList?: WishListCreateNestedManyWithoutProductInput
    Queries?: ProductQueryCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
    Review?: ReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
    WishList?: WishListUncheckedCreateNestedManyWithoutProductInput
    Queries?: ProductQueryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUpdateManyWithoutProductNestedInput
    Seller?: SellerAccountUpdateOneRequiredWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    WishList?: WishListUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
    Review?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsCreateManyInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
  }

  export type ProductsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
  }

  export type ProductQueryCreateInput = {
    username?: string | null
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    User: UserCreateNestedOneWithoutProductQueryInput
    Product?: ProductsCreateNestedOneWithoutQueriesInput
  }

  export type ProductQueryUncheckedCreateInput = {
    id?: number
    username?: string | null
    userid: string
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    productId?: string | null
  }

  export type ProductQueryUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    User?: UserUpdateOneRequiredWithoutProductQueryNestedInput
    Product?: ProductsUpdateOneWithoutQueriesNestedInput
  }

  export type ProductQueryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductQueryCreateManyInput = {
    id?: number
    username?: string | null
    userid: string
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    productId?: string | null
  }

  export type ProductQueryUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
  }

  export type ProductQueryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListCreateInput = {
    id?: string
    User?: UserCreateNestedOneWithoutWishListInput
    Product?: ProductsCreateNestedOneWithoutWishListInput
  }

  export type WishListUncheckedCreateInput = {
    id?: string
    userid?: string | null
    productid?: string | null
  }

  export type WishListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutWishListNestedInput
    Product?: ProductsUpdateOneWithoutWishListNestedInput
  }

  export type WishListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListCreateManyInput = {
    id?: string
    userid?: string | null
    productid?: string | null
  }

  export type WishListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type WishListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateInput = {
    id?: string
    rating?: number | null
    review?: string | null
    username?: string | null
    User?: UserCreateNestedOneWithoutReviewInput
    Product?: ProductsCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    rating?: number | null
    review?: string | null
    userid?: string | null
    username?: string | null
    productId?: string | null
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutReviewNestedInput
    Product?: ProductsUpdateOneWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyInput = {
    id?: string
    rating?: number | null
    review?: string | null
    userid?: string | null
    username?: string | null
    productId?: string | null
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
    Project: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
    projectId: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
    projectId: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type ListingListRelationFilter = {
    every?: ListingWhereInput
    some?: ListingWhereInput
    none?: ListingWhereInput
  }

  export type SellerAccountNullableScalarRelationFilter = {
    is?: SellerAccountWhereInput | null
    isNot?: SellerAccountWhereInput | null
  }

  export type DealersListRelationFilter = {
    every?: DealersWhereInput
    some?: DealersWhereInput
    none?: DealersWhereInput
  }

  export type JobProfileNullableScalarRelationFilter = {
    is?: JobProfileWhereInput | null
    isNot?: JobProfileWhereInput | null
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type WishListListRelationFilter = {
    every?: WishListWhereInput
    some?: WishListWhereInput
    none?: WishListWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type ProductQueryListRelationFilter = {
    every?: ProductQueryWhereInput
    some?: ProductQueryWhereInput
    none?: ProductQueryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductQueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    googlemail?: SortOrder
    extra?: SortOrder
    contact?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    contact?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    googlemail?: SortOrder
    extra?: SortOrder
    contact?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    googlemail?: SortOrder
    extra?: SortOrder
    contact?: SortOrder
    lastname?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    contact?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type JobProfileCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    jobsapplied?: SortOrder
    lastdisabled?: SortOrder
    createdAt?: SortOrder
    workdone?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type JobProfileAvgOrderByAggregateInput = {
    rating?: SortOrder
    workdone?: SortOrder
  }

  export type JobProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    lastdisabled?: SortOrder
    createdAt?: SortOrder
    workdone?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type JobProfileMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    lastdisabled?: SortOrder
    createdAt?: SortOrder
    workdone?: SortOrder
    status?: SortOrder
    location?: SortOrder
  }

  export type JobProfileSumOrderByAggregateInput = {
    rating?: SortOrder
    workdone?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DealersCountOrderByAggregateInput = {
    id?: SortOrder
    idd?: SortOrder
    name?: SortOrder
    dealeremail?: SortOrder
    dealerid?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    category?: SortOrder
    transactionWorth?: SortOrder
    createdAt?: SortOrder
  }

  export type DealersAvgOrderByAggregateInput = {
    transactionWorth?: SortOrder
  }

  export type DealersMaxOrderByAggregateInput = {
    id?: SortOrder
    idd?: SortOrder
    name?: SortOrder
    dealeremail?: SortOrder
    dealerid?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    category?: SortOrder
    transactionWorth?: SortOrder
    createdAt?: SortOrder
  }

  export type DealersMinOrderByAggregateInput = {
    id?: SortOrder
    idd?: SortOrder
    name?: SortOrder
    dealeremail?: SortOrder
    dealerid?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    verified?: SortOrder
    address?: SortOrder
    category?: SortOrder
    transactionWorth?: SortOrder
    createdAt?: SortOrder
  }

  export type DealersSumOrderByAggregateInput = {
    transactionWorth?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type ProductsListRelationFilter = {
    every?: ProductsWhereInput
    some?: ProductsWhereInput
    none?: ProductsWhereInput
  }

  export type ProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    sellerid?: SortOrder
    buyerName?: SortOrder
    buyerEmail?: SortOrder
    buyerContact?: SortOrder
    buyerId?: SortOrder
    orders?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    sellerid?: SortOrder
    buyerName?: SortOrder
    buyerEmail?: SortOrder
    buyerContact?: SortOrder
    buyerId?: SortOrder
    orders?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderStatus?: SortOrder
    sellerid?: SortOrder
    buyerName?: SortOrder
    buyerEmail?: SortOrder
    buyerContact?: SortOrder
    buyerId?: SortOrder
    orders?: SortOrder
  }

  export type EnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type FinanceNullableScalarRelationFilter = {
    is?: FinanceWhereInput | null
    isNot?: FinanceWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type ScheduleMsgListRelationFilter = {
    every?: ScheduleMsgWhereInput
    some?: ScheduleMsgWhereInput
    none?: ScheduleMsgWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleMsgOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    userid?: SortOrder
    coverimgUrl?: SortOrder
    budget?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    userid?: SortOrder
    coverimgUrl?: SortOrder
    budget?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    userid?: SortOrder
    coverimgUrl?: SortOrder
    budget?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    useremail?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    useremail?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    useremail?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    available?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    stock?: SortOrder
    valueperpeice?: SortOrder
    projectId?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    available?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    stock?: SortOrder
    valueperpeice?: SortOrder
    projectId?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    available?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    stock?: SortOrder
    valueperpeice?: SortOrder
    projectId?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    verified?: SortOrder
    phonenum?: SortOrder
    useriid?: SortOrder
    createdat?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    phonenum?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    verified?: SortOrder
    phonenum?: SortOrder
    useriid?: SortOrder
    createdat?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    verified?: SortOrder
    phonenum?: SortOrder
    useriid?: SortOrder
    createdat?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    phonenum?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ListingCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    address?: SortOrder
    soldout?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
  }

  export type ListingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ListingMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    address?: SortOrder
    soldout?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
  }

  export type ListingMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    address?: SortOrder
    soldout?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
  }

  export type ListingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    team?: SortOrder
    amount?: SortOrder
    startdate?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    supplier?: SortOrder
    subtasks?: SortOrder
    inventories?: SortOrder
    teamlead?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    amount?: SortOrder
    startdate?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    teamlead?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    amount?: SortOrder
    startdate?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    teamlead?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type EnumTypetransFilter<$PrismaModel = never> = {
    equals?: $Enums.Typetrans | EnumTypetransFieldRefInput<$PrismaModel>
    in?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    notIn?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    not?: NestedEnumTypetransFilter<$PrismaModel> | $Enums.Typetrans
  }

  export type FinanceScalarRelationFilter = {
    is?: FinanceWhereInput
    isNot?: FinanceWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    gstrate?: SortOrder
    dealer?: SortOrder
    status?: SortOrder
    proof?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    gstrate?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    gstrate?: SortOrder
    dealer?: SortOrder
    status?: SortOrder
    proof?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    gstrate?: SortOrder
    dealer?: SortOrder
    status?: SortOrder
    proof?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    gstrate?: SortOrder
  }

  export type EnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type EnumTypetransWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Typetrans | EnumTypetransFieldRefInput<$PrismaModel>
    in?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    notIn?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    not?: NestedEnumTypetransWithAggregatesFilter<$PrismaModel> | $Enums.Typetrans
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypetransFilter<$PrismaModel>
    _max?: NestedEnumTypetransFilter<$PrismaModel>
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type RemaindersListRelationFilter = {
    every?: RemaindersWhereInput
    some?: RemaindersWhereInput
    none?: RemaindersWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemaindersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinanceCountOrderByAggregateInput = {
    id?: SortOrder
    income?: SortOrder
    expenditure?: SortOrder
    budget?: SortOrder
    balance?: SortOrder
    MPIN?: SortOrder
  }

  export type FinanceAvgOrderByAggregateInput = {
    income?: SortOrder
    expenditure?: SortOrder
    budget?: SortOrder
    balance?: SortOrder
  }

  export type FinanceMaxOrderByAggregateInput = {
    id?: SortOrder
    income?: SortOrder
    expenditure?: SortOrder
    budget?: SortOrder
    balance?: SortOrder
    MPIN?: SortOrder
  }

  export type FinanceMinOrderByAggregateInput = {
    id?: SortOrder
    income?: SortOrder
    expenditure?: SortOrder
    budget?: SortOrder
    balance?: SortOrder
    MPIN?: SortOrder
  }

  export type FinanceSumOrderByAggregateInput = {
    income?: SortOrder
    expenditure?: SortOrder
    budget?: SortOrder
    balance?: SortOrder
  }

  export type RemaindersCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dealer?: SortOrder
    date?: SortOrder
    financeId?: SortOrder
  }

  export type RemaindersAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RemaindersMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dealer?: SortOrder
    date?: SortOrder
    financeId?: SortOrder
  }

  export type RemaindersMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    dealer?: SortOrder
    date?: SortOrder
    financeId?: SortOrder
  }

  export type RemaindersSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumNoteTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoteTypeNullableFilter<$PrismaModel> | $Enums.NoteType | null
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    type?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    type?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    financeId?: SortOrder
    type?: SortOrder
  }

  export type EnumNoteTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoteTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NoteType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeNullableFilter<$PrismaModel>
  }

  export type EnumMsgtypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Msgtype | EnumMsgtypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMsgtypeNullableFilter<$PrismaModel> | $Enums.Msgtype | null
  }

  export type EnumScheduleMsgStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleMsgStatus | EnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel> | $Enums.ScheduleMsgStatus | null
  }

  export type ScheduleMsgCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    Datetime?: SortOrder
    type?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type ScheduleMsgMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    Datetime?: SortOrder
    type?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type ScheduleMsgMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phonenum?: SortOrder
    Datetime?: SortOrder
    type?: SortOrder
    text?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnumMsgtypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Msgtype | EnumMsgtypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMsgtypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Msgtype | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMsgtypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMsgtypeNullableFilter<$PrismaModel>
  }

  export type EnumScheduleMsgStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleMsgStatus | EnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleMsgStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleMsgStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel>
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellerAccountCountOrderByAggregateInput = {
    id?: SortOrder
    sales?: SortOrder
  }

  export type SellerAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    sales?: SortOrder
  }

  export type SellerAccountMinOrderByAggregateInput = {
    id?: SortOrder
    sales?: SortOrder
  }

  export type EnumCategoriesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categories | EnumCategoriesFieldRefInput<$PrismaModel>
    in?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoriesFilter<$PrismaModel> | $Enums.Categories
  }

  export type EnumModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Mode | EnumModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModeNullableFilter<$PrismaModel> | $Enums.Mode | null
  }

  export type EnumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeFilter<$PrismaModel> | $Enums.Type
  }

  export type SellerAccountScalarRelationFilter = {
    is?: SellerAccountWhereInput
    isNot?: SellerAccountWhereInput
  }

  export type ProductsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    imageurl?: SortOrder
    quantity?: SortOrder
    sellerName?: SortOrder
    expirydate?: SortOrder
    category?: SortOrder
    specialmsg?: SortOrder
    stock?: SortOrder
    contact?: SortOrder
    questions?: SortOrder
    mode?: SortOrder
    type?: SortOrder
    offers?: SortOrder
    sellerid?: SortOrder
  }

  export type ProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    imageurl?: SortOrder
    quantity?: SortOrder
    sellerName?: SortOrder
    expirydate?: SortOrder
    category?: SortOrder
    specialmsg?: SortOrder
    stock?: SortOrder
    contact?: SortOrder
    mode?: SortOrder
    type?: SortOrder
    offers?: SortOrder
    sellerid?: SortOrder
  }

  export type ProductsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    imageurl?: SortOrder
    quantity?: SortOrder
    sellerName?: SortOrder
    expirydate?: SortOrder
    category?: SortOrder
    specialmsg?: SortOrder
    stock?: SortOrder
    contact?: SortOrder
    mode?: SortOrder
    type?: SortOrder
    offers?: SortOrder
    sellerid?: SortOrder
  }

  export type EnumCategoriesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categories | EnumCategoriesFieldRefInput<$PrismaModel>
    in?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoriesWithAggregatesFilter<$PrismaModel> | $Enums.Categories
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoriesFilter<$PrismaModel>
    _max?: NestedEnumCategoriesFilter<$PrismaModel>
  }

  export type EnumModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Mode | EnumModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Mode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumModeNullableFilter<$PrismaModel>
    _max?: NestedEnumModeNullableFilter<$PrismaModel>
  }

  export type EnumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeWithAggregatesFilter<$PrismaModel> | $Enums.Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFilter<$PrismaModel>
    _max?: NestedEnumTypeFilter<$PrismaModel>
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: ProductsWhereInput | null
    isNot?: ProductsWhereInput | null
  }

  export type ProductQueryCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    additionalQueies?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    productId?: SortOrder
  }

  export type ProductQueryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    additionalQueies?: SortOrder
    productId?: SortOrder
  }

  export type ProductQueryMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    additionalQueies?: SortOrder
    productId?: SortOrder
  }

  export type ProductQuerySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WishListCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    productid?: SortOrder
  }

  export type WishListMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    productid?: SortOrder
  }

  export type WishListMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    productid?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userid?: SortOrder
    username?: SortOrder
    productId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userid?: SortOrder
    username?: SortOrder
    productId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userid?: SortOrder
    username?: SortOrder
    productId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalName?: SortOrder
    title?: SortOrder
    storageUrl?: SortOrder
    uploadDate?: SortOrder
    isEncrypted?: SortOrder
    notes?: SortOrder
    projectId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalName?: SortOrder
    title?: SortOrder
    storageUrl?: SortOrder
    uploadDate?: SortOrder
    isEncrypted?: SortOrder
    notes?: SortOrder
    projectId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originalName?: SortOrder
    title?: SortOrder
    storageUrl?: SortOrder
    uploadDate?: SortOrder
    isEncrypted?: SortOrder
    notes?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput> | TeamCreateWithoutUserInput[] | TeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput | TeamCreateOrConnectWithoutUserInput[]
    createMany?: TeamCreateManyUserInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type SellerAccountCreateNestedOneWithoutUserInput = {
    create?: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutUserInput
    connect?: SellerAccountWhereUniqueInput
  }

  export type DealersCreateNestedManyWithoutUsersInput = {
    create?: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput> | DealersCreateWithoutUsersInput[] | DealersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DealersCreateOrConnectWithoutUsersInput | DealersCreateOrConnectWithoutUsersInput[]
    createMany?: DealersCreateManyUsersInputEnvelope
    connect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
  }

  export type JobProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: JobProfileCreateOrConnectWithoutUserInput
    connect?: JobProfileWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type WishListCreateNestedManyWithoutUserInput = {
    create?: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput> | WishListCreateWithoutUserInput[] | WishListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutUserInput | WishListCreateOrConnectWithoutUserInput[]
    createMany?: WishListCreateManyUserInputEnvelope
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ProductQueryCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput> | ProductQueryCreateWithoutUserInput[] | ProductQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutUserInput | ProductQueryCreateOrConnectWithoutUserInput[]
    createMany?: ProductQueryCreateManyUserInputEnvelope
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput> | TeamCreateWithoutUserInput[] | TeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput | TeamCreateOrConnectWithoutUserInput[]
    createMany?: TeamCreateManyUserInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type SellerAccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutUserInput
    connect?: SellerAccountWhereUniqueInput
  }

  export type DealersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput> | DealersCreateWithoutUsersInput[] | DealersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DealersCreateOrConnectWithoutUsersInput | DealersCreateOrConnectWithoutUsersInput[]
    createMany?: DealersCreateManyUsersInputEnvelope
    connect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
  }

  export type JobProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: JobProfileCreateOrConnectWithoutUserInput
    connect?: JobProfileWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type WishListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput> | WishListCreateWithoutUserInput[] | WishListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutUserInput | WishListCreateOrConnectWithoutUserInput[]
    createMany?: WishListCreateManyUserInputEnvelope
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ProductQueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput> | ProductQueryCreateWithoutUserInput[] | ProductQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutUserInput | ProductQueryCreateOrConnectWithoutUserInput[]
    createMany?: ProductQueryCreateManyUserInputEnvelope
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput> | TeamCreateWithoutUserInput[] | TeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput | TeamCreateOrConnectWithoutUserInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutUserInput | TeamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamCreateManyUserInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutUserInput | TeamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutUserInput | TeamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOwnerInput | ListingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOwnerInput | ListingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOwnerInput | ListingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type SellerAccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutUserInput
    upsert?: SellerAccountUpsertWithoutUserInput
    disconnect?: SellerAccountWhereInput | boolean
    delete?: SellerAccountWhereInput | boolean
    connect?: SellerAccountWhereUniqueInput
    update?: XOR<XOR<SellerAccountUpdateToOneWithWhereWithoutUserInput, SellerAccountUpdateWithoutUserInput>, SellerAccountUncheckedUpdateWithoutUserInput>
  }

  export type DealersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput> | DealersCreateWithoutUsersInput[] | DealersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DealersCreateOrConnectWithoutUsersInput | DealersCreateOrConnectWithoutUsersInput[]
    upsert?: DealersUpsertWithWhereUniqueWithoutUsersInput | DealersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DealersCreateManyUsersInputEnvelope
    set?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    disconnect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    delete?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    connect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    update?: DealersUpdateWithWhereUniqueWithoutUsersInput | DealersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DealersUpdateManyWithWhereWithoutUsersInput | DealersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DealersScalarWhereInput | DealersScalarWhereInput[]
  }

  export type JobProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: JobProfileCreateOrConnectWithoutUserInput
    upsert?: JobProfileUpsertWithoutUserInput
    disconnect?: JobProfileWhereInput | boolean
    delete?: JobProfileWhereInput | boolean
    connect?: JobProfileWhereUniqueInput
    update?: XOR<XOR<JobProfileUpdateToOneWithWhereWithoutUserInput, JobProfileUpdateWithoutUserInput>, JobProfileUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type WishListUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput> | WishListCreateWithoutUserInput[] | WishListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutUserInput | WishListCreateOrConnectWithoutUserInput[]
    upsert?: WishListUpsertWithWhereUniqueWithoutUserInput | WishListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishListCreateManyUserInputEnvelope
    set?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    disconnect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    delete?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    update?: WishListUpdateWithWhereUniqueWithoutUserInput | WishListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishListUpdateManyWithWhereWithoutUserInput | WishListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishListScalarWhereInput | WishListScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProductQueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput> | ProductQueryCreateWithoutUserInput[] | ProductQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutUserInput | ProductQueryCreateOrConnectWithoutUserInput[]
    upsert?: ProductQueryUpsertWithWhereUniqueWithoutUserInput | ProductQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductQueryCreateManyUserInputEnvelope
    set?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    disconnect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    delete?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    update?: ProductQueryUpdateWithWhereUniqueWithoutUserInput | ProductQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductQueryUpdateManyWithWhereWithoutUserInput | ProductQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput> | TeamCreateWithoutUserInput[] | TeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUserInput | TeamCreateOrConnectWithoutUserInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutUserInput | TeamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamCreateManyUserInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutUserInput | TeamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutUserInput | TeamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOwnerInput | ListingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOwnerInput | ListingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOwnerInput | ListingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type SellerAccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutUserInput
    upsert?: SellerAccountUpsertWithoutUserInput
    disconnect?: SellerAccountWhereInput | boolean
    delete?: SellerAccountWhereInput | boolean
    connect?: SellerAccountWhereUniqueInput
    update?: XOR<XOR<SellerAccountUpdateToOneWithWhereWithoutUserInput, SellerAccountUpdateWithoutUserInput>, SellerAccountUncheckedUpdateWithoutUserInput>
  }

  export type DealersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput> | DealersCreateWithoutUsersInput[] | DealersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DealersCreateOrConnectWithoutUsersInput | DealersCreateOrConnectWithoutUsersInput[]
    upsert?: DealersUpsertWithWhereUniqueWithoutUsersInput | DealersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DealersCreateManyUsersInputEnvelope
    set?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    disconnect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    delete?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    connect?: DealersWhereUniqueInput | DealersWhereUniqueInput[]
    update?: DealersUpdateWithWhereUniqueWithoutUsersInput | DealersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DealersUpdateManyWithWhereWithoutUsersInput | DealersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DealersScalarWhereInput | DealersScalarWhereInput[]
  }

  export type JobProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: JobProfileCreateOrConnectWithoutUserInput
    upsert?: JobProfileUpsertWithoutUserInput
    disconnect?: JobProfileWhereInput | boolean
    delete?: JobProfileWhereInput | boolean
    connect?: JobProfileWhereUniqueInput
    update?: XOR<XOR<JobProfileUpdateToOneWithWhereWithoutUserInput, JobProfileUpdateWithoutUserInput>, JobProfileUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type WishListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput> | WishListCreateWithoutUserInput[] | WishListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutUserInput | WishListCreateOrConnectWithoutUserInput[]
    upsert?: WishListUpsertWithWhereUniqueWithoutUserInput | WishListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishListCreateManyUserInputEnvelope
    set?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    disconnect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    delete?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    update?: WishListUpdateWithWhereUniqueWithoutUserInput | WishListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishListUpdateManyWithWhereWithoutUserInput | WishListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishListScalarWhereInput | WishListScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProductQueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput> | ProductQueryCreateWithoutUserInput[] | ProductQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutUserInput | ProductQueryCreateOrConnectWithoutUserInput[]
    upsert?: ProductQueryUpsertWithWhereUniqueWithoutUserInput | ProductQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductQueryCreateManyUserInputEnvelope
    set?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    disconnect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    delete?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    update?: ProductQueryUpdateWithWhereUniqueWithoutUserInput | ProductQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductQueryUpdateManyWithWhereWithoutUserInput | ProductQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
  }

  export type JobProfileCreatejobsappliedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutJobProfleInput = {
    create?: XOR<UserCreateWithoutJobProfleInput, UserUncheckedCreateWithoutJobProfleInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobProfleInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobProfileUpdatejobsappliedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutJobProfleNestedInput = {
    create?: XOR<UserCreateWithoutJobProfleInput, UserUncheckedCreateWithoutJobProfleInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobProfleInput
    upsert?: UserUpsertWithoutJobProfleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobProfleInput, UserUpdateWithoutJobProfleInput>, UserUncheckedUpdateWithoutJobProfleInput>
  }

  export type UserCreateNestedOneWithoutDealerInput = {
    create?: XOR<UserCreateWithoutDealerInput, UserUncheckedCreateWithoutDealerInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealerInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutDealerNestedInput = {
    create?: XOR<UserCreateWithoutDealerInput, UserUncheckedCreateWithoutDealerInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealerInput
    upsert?: UserUpsertWithoutDealerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDealerInput, UserUpdateWithoutDealerInput>, UserUncheckedUpdateWithoutDealerInput>
  }

  export type SellerAccountCreateNestedOneWithoutOrderInput = {
    create?: XOR<SellerAccountCreateWithoutOrderInput, SellerAccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutOrderInput
    connect?: SellerAccountWhereUniqueInput
  }

  export type ProductsCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput> | ProductsCreateWithoutOrderInput[] | ProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderInput | ProductsCreateOrConnectWithoutOrderInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput> | ProductsCreateWithoutOrderInput[] | ProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderInput | ProductsCreateOrConnectWithoutOrderInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type NullableEnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus | null
  }

  export type SellerAccountUpdateOneWithoutOrderNestedInput = {
    create?: XOR<SellerAccountCreateWithoutOrderInput, SellerAccountUncheckedCreateWithoutOrderInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutOrderInput
    upsert?: SellerAccountUpsertWithoutOrderInput
    disconnect?: SellerAccountWhereInput | boolean
    delete?: SellerAccountWhereInput | boolean
    connect?: SellerAccountWhereUniqueInput
    update?: XOR<XOR<SellerAccountUpdateToOneWithWhereWithoutOrderInput, SellerAccountUpdateWithoutOrderInput>, SellerAccountUncheckedUpdateWithoutOrderInput>
  }

  export type ProductsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput> | ProductsCreateWithoutOrderInput[] | ProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderInput | ProductsCreateOrConnectWithoutOrderInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutOrderInput | ProductsUpsertWithWhereUniqueWithoutOrderInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutOrderInput | ProductsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutOrderInput | ProductsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput> | ProductsCreateWithoutOrderInput[] | ProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutOrderInput | ProductsCreateOrConnectWithoutOrderInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutOrderInput | ProductsUpsertWithWhereUniqueWithoutOrderInput[]
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutOrderInput | ProductsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutOrderInput | ProductsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type FinanceCreateNestedOneWithoutFinanceInput = {
    create?: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutFinanceInput
    connect?: FinanceWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ScheduleMsgCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput> | ScheduleMsgCreateWithoutProjectInput[] | ScheduleMsgUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleMsgCreateOrConnectWithoutProjectInput | ScheduleMsgCreateOrConnectWithoutProjectInput[]
    createMany?: ScheduleMsgCreateManyProjectInputEnvelope
    connect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput> | InventoryCreateWithoutProjectInput[] | InventoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProjectInput | InventoryCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryCreateManyProjectInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type FinanceUncheckedCreateNestedOneWithoutFinanceInput = {
    create?: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutFinanceInput
    connect?: FinanceWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput> | ScheduleMsgCreateWithoutProjectInput[] | ScheduleMsgUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleMsgCreateOrConnectWithoutProjectInput | ScheduleMsgCreateOrConnectWithoutProjectInput[]
    createMany?: ScheduleMsgCreateManyProjectInputEnvelope
    connect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput> | InventoryCreateWithoutProjectInput[] | InventoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProjectInput | InventoryCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryCreateManyProjectInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type MemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type FinanceUpdateOneWithoutFinanceNestedInput = {
    create?: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutFinanceInput
    upsert?: FinanceUpsertWithoutFinanceInput
    disconnect?: FinanceWhereInput | boolean
    delete?: FinanceWhereInput | boolean
    connect?: FinanceWhereUniqueInput
    update?: XOR<XOR<FinanceUpdateToOneWithWhereWithoutFinanceInput, FinanceUpdateWithoutFinanceInput>, FinanceUncheckedUpdateWithoutFinanceInput>
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ScheduleMsgUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput> | ScheduleMsgCreateWithoutProjectInput[] | ScheduleMsgUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleMsgCreateOrConnectWithoutProjectInput | ScheduleMsgCreateOrConnectWithoutProjectInput[]
    upsert?: ScheduleMsgUpsertWithWhereUniqueWithoutProjectInput | ScheduleMsgUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScheduleMsgCreateManyProjectInputEnvelope
    set?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    disconnect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    delete?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    connect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    update?: ScheduleMsgUpdateWithWhereUniqueWithoutProjectInput | ScheduleMsgUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScheduleMsgUpdateManyWithWhereWithoutProjectInput | ScheduleMsgUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScheduleMsgScalarWhereInput | ScheduleMsgScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput> | InventoryCreateWithoutProjectInput[] | InventoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProjectInput | InventoryCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProjectInput | InventoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryCreateManyProjectInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProjectInput | InventoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProjectInput | InventoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput> | MemberCreateWithoutProjectInput[] | MemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutProjectInput | MemberCreateOrConnectWithoutProjectInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutProjectInput | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MemberCreateManyProjectInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutProjectInput | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutProjectInput | MemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type FinanceUncheckedUpdateOneWithoutFinanceNestedInput = {
    create?: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutFinanceInput
    upsert?: FinanceUpsertWithoutFinanceInput
    disconnect?: FinanceWhereInput | boolean
    delete?: FinanceWhereInput | boolean
    connect?: FinanceWhereUniqueInput
    update?: XOR<XOR<FinanceUpdateToOneWithWhereWithoutFinanceInput, FinanceUpdateWithoutFinanceInput>, FinanceUncheckedUpdateWithoutFinanceInput>
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput> | ScheduleMsgCreateWithoutProjectInput[] | ScheduleMsgUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleMsgCreateOrConnectWithoutProjectInput | ScheduleMsgCreateOrConnectWithoutProjectInput[]
    upsert?: ScheduleMsgUpsertWithWhereUniqueWithoutProjectInput | ScheduleMsgUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScheduleMsgCreateManyProjectInputEnvelope
    set?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    disconnect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    delete?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    connect?: ScheduleMsgWhereUniqueInput | ScheduleMsgWhereUniqueInput[]
    update?: ScheduleMsgUpdateWithWhereUniqueWithoutProjectInput | ScheduleMsgUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScheduleMsgUpdateManyWithWhereWithoutProjectInput | ScheduleMsgUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScheduleMsgScalarWhereInput | ScheduleMsgScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput> | InventoryCreateWithoutProjectInput[] | InventoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProjectInput | InventoryCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProjectInput | InventoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryCreateManyProjectInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProjectInput | InventoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProjectInput | InventoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMemberInput = {
    create?: XOR<ProjectCreateWithoutMemberInput, ProjectUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMemberInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMemberInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMemberNestedInput = {
    create?: XOR<ProjectCreateWithoutMemberInput, ProjectUncheckedCreateWithoutMemberInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMemberInput
    upsert?: ProjectUpsertWithoutMemberInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMemberInput, ProjectUpdateWithoutMemberInput>, ProjectUncheckedUpdateWithoutMemberInput>
  }

  export type UserUpdateOneRequiredWithoutMemberNestedInput = {
    create?: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberInput
    upsert?: UserUpsertWithoutMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMemberInput, UserUpdateWithoutMemberInput>, UserUncheckedUpdateWithoutMemberInput>
  }

  export type ProjectCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryInput
    connect?: ProjectWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProjectUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventoryInput
    upsert?: ProjectUpsertWithoutInventoryInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInventoryInput, ProjectUpdateWithoutInventoryInput>, ProjectUncheckedUpdateWithoutInventoryInput>
  }

  export type UserCreateNestedOneWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput
    upsert?: UserUpsertWithoutTeamInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamInput, UserUpdateWithoutTeamInput>, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserCreateNestedOneWithoutListingInput = {
    create?: XOR<UserCreateWithoutListingInput, UserUncheckedCreateWithoutListingInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutListingNestedInput = {
    create?: XOR<UserCreateWithoutListingInput, UserUncheckedCreateWithoutListingInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingInput
    upsert?: UserUpsertWithoutListingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListingInput, UserUpdateWithoutListingInput>, UserUncheckedUpdateWithoutListingInput>
  }

  export type TaskCreateteamInput = {
    set: string[]
  }

  export type TaskCreatesupplierInput = {
    set: string[]
  }

  export type TaskCreatesubtasksInput = {
    set: string[]
  }

  export type TaskCreateinventoriesInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutTaskInput = {
    create?: XOR<ProjectCreateWithoutTaskInput, ProjectUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskUpdateteamInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskUpdatesupplierInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskUpdatesubtasksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TaskUpdateinventoriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneWithoutTaskNestedInput = {
    create?: XOR<ProjectCreateWithoutTaskInput, ProjectUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTaskInput
    upsert?: ProjectUpsertWithoutTaskInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTaskInput, ProjectUpdateWithoutTaskInput>, ProjectUncheckedUpdateWithoutTaskInput>
  }

  export type FinanceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<FinanceCreateWithoutTransactionInput, FinanceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutTransactionInput
    connect?: FinanceWhereUniqueInput
  }

  export type NullableEnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status | null
  }

  export type EnumTypetransFieldUpdateOperationsInput = {
    set?: $Enums.Typetrans
  }

  export type FinanceUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<FinanceCreateWithoutTransactionInput, FinanceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutTransactionInput
    upsert?: FinanceUpsertWithoutTransactionInput
    connect?: FinanceWhereUniqueInput
    update?: XOR<XOR<FinanceUpdateToOneWithWhereWithoutTransactionInput, FinanceUpdateWithoutTransactionInput>, FinanceUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionCreateNestedManyWithoutFinanceInput = {
    create?: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput> | TransactionCreateWithoutFinanceInput[] | TransactionUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFinanceInput | TransactionCreateOrConnectWithoutFinanceInput[]
    createMany?: TransactionCreateManyFinanceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutFinanceInput = {
    create?: XOR<ProjectCreateWithoutFinanceInput, ProjectUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFinanceInput
    connect?: ProjectWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutFinanceInput = {
    create?: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput> | NoteCreateWithoutFinanceInput[] | NoteUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutFinanceInput | NoteCreateOrConnectWithoutFinanceInput[]
    createMany?: NoteCreateManyFinanceInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type RemaindersCreateNestedManyWithoutFinanceInput = {
    create?: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput> | RemaindersCreateWithoutFinanceInput[] | RemaindersUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: RemaindersCreateOrConnectWithoutFinanceInput | RemaindersCreateOrConnectWithoutFinanceInput[]
    createMany?: RemaindersCreateManyFinanceInputEnvelope
    connect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFinanceInput = {
    create?: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput> | TransactionCreateWithoutFinanceInput[] | TransactionUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFinanceInput | TransactionCreateOrConnectWithoutFinanceInput[]
    createMany?: TransactionCreateManyFinanceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutFinanceInput = {
    create?: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput> | NoteCreateWithoutFinanceInput[] | NoteUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutFinanceInput | NoteCreateOrConnectWithoutFinanceInput[]
    createMany?: NoteCreateManyFinanceInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type RemaindersUncheckedCreateNestedManyWithoutFinanceInput = {
    create?: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput> | RemaindersCreateWithoutFinanceInput[] | RemaindersUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: RemaindersCreateOrConnectWithoutFinanceInput | RemaindersCreateOrConnectWithoutFinanceInput[]
    createMany?: RemaindersCreateManyFinanceInputEnvelope
    connect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput> | TransactionCreateWithoutFinanceInput[] | TransactionUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFinanceInput | TransactionCreateOrConnectWithoutFinanceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFinanceInput | TransactionUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: TransactionCreateManyFinanceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFinanceInput | TransactionUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFinanceInput | TransactionUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutFinanceNestedInput = {
    create?: XOR<ProjectCreateWithoutFinanceInput, ProjectUncheckedCreateWithoutFinanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFinanceInput
    upsert?: ProjectUpsertWithoutFinanceInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFinanceInput, ProjectUpdateWithoutFinanceInput>, ProjectUncheckedUpdateWithoutFinanceInput>
  }

  export type NoteUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput> | NoteCreateWithoutFinanceInput[] | NoteUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutFinanceInput | NoteCreateOrConnectWithoutFinanceInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutFinanceInput | NoteUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: NoteCreateManyFinanceInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutFinanceInput | NoteUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutFinanceInput | NoteUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type RemaindersUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput> | RemaindersCreateWithoutFinanceInput[] | RemaindersUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: RemaindersCreateOrConnectWithoutFinanceInput | RemaindersCreateOrConnectWithoutFinanceInput[]
    upsert?: RemaindersUpsertWithWhereUniqueWithoutFinanceInput | RemaindersUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: RemaindersCreateManyFinanceInputEnvelope
    set?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    disconnect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    delete?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    connect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    update?: RemaindersUpdateWithWhereUniqueWithoutFinanceInput | RemaindersUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: RemaindersUpdateManyWithWhereWithoutFinanceInput | RemaindersUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: RemaindersScalarWhereInput | RemaindersScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput> | TransactionCreateWithoutFinanceInput[] | TransactionUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFinanceInput | TransactionCreateOrConnectWithoutFinanceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFinanceInput | TransactionUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: TransactionCreateManyFinanceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFinanceInput | TransactionUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFinanceInput | TransactionUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput> | NoteCreateWithoutFinanceInput[] | NoteUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutFinanceInput | NoteCreateOrConnectWithoutFinanceInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutFinanceInput | NoteUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: NoteCreateManyFinanceInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutFinanceInput | NoteUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutFinanceInput | NoteUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type RemaindersUncheckedUpdateManyWithoutFinanceNestedInput = {
    create?: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput> | RemaindersCreateWithoutFinanceInput[] | RemaindersUncheckedCreateWithoutFinanceInput[]
    connectOrCreate?: RemaindersCreateOrConnectWithoutFinanceInput | RemaindersCreateOrConnectWithoutFinanceInput[]
    upsert?: RemaindersUpsertWithWhereUniqueWithoutFinanceInput | RemaindersUpsertWithWhereUniqueWithoutFinanceInput[]
    createMany?: RemaindersCreateManyFinanceInputEnvelope
    set?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    disconnect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    delete?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    connect?: RemaindersWhereUniqueInput | RemaindersWhereUniqueInput[]
    update?: RemaindersUpdateWithWhereUniqueWithoutFinanceInput | RemaindersUpdateWithWhereUniqueWithoutFinanceInput[]
    updateMany?: RemaindersUpdateManyWithWhereWithoutFinanceInput | RemaindersUpdateManyWithWhereWithoutFinanceInput[]
    deleteMany?: RemaindersScalarWhereInput | RemaindersScalarWhereInput[]
  }

  export type FinanceCreateNestedOneWithoutRemainderInput = {
    create?: XOR<FinanceCreateWithoutRemainderInput, FinanceUncheckedCreateWithoutRemainderInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutRemainderInput
    connect?: FinanceWhereUniqueInput
  }

  export type FinanceUpdateOneRequiredWithoutRemainderNestedInput = {
    create?: XOR<FinanceCreateWithoutRemainderInput, FinanceUncheckedCreateWithoutRemainderInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutRemainderInput
    upsert?: FinanceUpsertWithoutRemainderInput
    connect?: FinanceWhereUniqueInput
    update?: XOR<XOR<FinanceUpdateToOneWithWhereWithoutRemainderInput, FinanceUpdateWithoutRemainderInput>, FinanceUncheckedUpdateWithoutRemainderInput>
  }

  export type FinanceCreateNestedOneWithoutNotesInput = {
    create?: XOR<FinanceCreateWithoutNotesInput, FinanceUncheckedCreateWithoutNotesInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutNotesInput
    connect?: FinanceWhereUniqueInput
  }

  export type NullableEnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType | null
  }

  export type FinanceUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<FinanceCreateWithoutNotesInput, FinanceUncheckedCreateWithoutNotesInput>
    connectOrCreate?: FinanceCreateOrConnectWithoutNotesInput
    upsert?: FinanceUpsertWithoutNotesInput
    connect?: FinanceWhereUniqueInput
    update?: XOR<XOR<FinanceUpdateToOneWithWhereWithoutNotesInput, FinanceUpdateWithoutNotesInput>, FinanceUncheckedUpdateWithoutNotesInput>
  }

  export type ProjectCreateNestedOneWithoutScheduledMsgInput = {
    create?: XOR<ProjectCreateWithoutScheduledMsgInput, ProjectUncheckedCreateWithoutScheduledMsgInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScheduledMsgInput
    connect?: ProjectWhereUniqueInput
  }

  export type NullableEnumMsgtypeFieldUpdateOperationsInput = {
    set?: $Enums.Msgtype | null
  }

  export type NullableEnumScheduleMsgStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleMsgStatus | null
  }

  export type ProjectUpdateOneRequiredWithoutScheduledMsgNestedInput = {
    create?: XOR<ProjectCreateWithoutScheduledMsgInput, ProjectUncheckedCreateWithoutScheduledMsgInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScheduledMsgInput
    upsert?: ProjectUpsertWithoutScheduledMsgInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutScheduledMsgInput, ProjectUpdateWithoutScheduledMsgInput>, ProjectUncheckedUpdateWithoutScheduledMsgInput>
  }

  export type UserCreateNestedOneWithoutSelleraccountInput = {
    create?: XOR<UserCreateWithoutSelleraccountInput, UserUncheckedCreateWithoutSelleraccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutSelleraccountInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput> | ProductsCreateWithoutSellerInput[] | ProductsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSellerInput | ProductsCreateOrConnectWithoutSellerInput[]
    createMany?: ProductsCreateManySellerInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutSellerInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput> | OrderCreateWithoutSellerInput[] | OrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput | OrderCreateOrConnectWithoutSellerInput[]
    createMany?: OrderCreateManySellerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductsUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput> | ProductsCreateWithoutSellerInput[] | ProductsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSellerInput | ProductsCreateOrConnectWithoutSellerInput[]
    createMany?: ProductsCreateManySellerInputEnvelope
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput> | OrderCreateWithoutSellerInput[] | OrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput | OrderCreateOrConnectWithoutSellerInput[]
    createMany?: OrderCreateManySellerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSelleraccountNestedInput = {
    create?: XOR<UserCreateWithoutSelleraccountInput, UserUncheckedCreateWithoutSelleraccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutSelleraccountInput
    upsert?: UserUpsertWithoutSelleraccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSelleraccountInput, UserUpdateWithoutSelleraccountInput>, UserUncheckedUpdateWithoutSelleraccountInput>
  }

  export type ProductsUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput> | ProductsCreateWithoutSellerInput[] | ProductsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSellerInput | ProductsCreateOrConnectWithoutSellerInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutSellerInput | ProductsUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductsCreateManySellerInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutSellerInput | ProductsUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutSellerInput | ProductsUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput> | OrderCreateWithoutSellerInput[] | OrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput | OrderCreateOrConnectWithoutSellerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSellerInput | OrderUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OrderCreateManySellerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSellerInput | OrderUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSellerInput | OrderUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductsUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput> | ProductsCreateWithoutSellerInput[] | ProductsUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductsCreateOrConnectWithoutSellerInput | ProductsCreateOrConnectWithoutSellerInput[]
    upsert?: ProductsUpsertWithWhereUniqueWithoutSellerInput | ProductsUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductsCreateManySellerInputEnvelope
    set?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    disconnect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    delete?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    connect?: ProductsWhereUniqueInput | ProductsWhereUniqueInput[]
    update?: ProductsUpdateWithWhereUniqueWithoutSellerInput | ProductsUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductsUpdateManyWithWhereWithoutSellerInput | ProductsUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput> | OrderCreateWithoutSellerInput[] | OrderUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSellerInput | OrderCreateOrConnectWithoutSellerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSellerInput | OrderUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: OrderCreateManySellerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSellerInput | OrderUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSellerInput | OrderUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductsCreatequestionsInput = {
    set: string[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type SellerAccountCreateNestedOneWithoutProductInput = {
    create?: XOR<SellerAccountCreateWithoutProductInput, SellerAccountUncheckedCreateWithoutProductInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutProductInput
    connect?: SellerAccountWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WishListCreateNestedManyWithoutProductInput = {
    create?: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput> | WishListCreateWithoutProductInput[] | WishListUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutProductInput | WishListCreateOrConnectWithoutProductInput[]
    createMany?: WishListCreateManyProductInputEnvelope
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
  }

  export type ProductQueryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput> | ProductQueryCreateWithoutProductInput[] | ProductQueryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutProductInput | ProductQueryCreateOrConnectWithoutProductInput[]
    createMany?: ProductQueryCreateManyProductInputEnvelope
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WishListUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput> | WishListCreateWithoutProductInput[] | WishListUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutProductInput | WishListCreateOrConnectWithoutProductInput[]
    createMany?: WishListCreateManyProductInputEnvelope
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
  }

  export type ProductQueryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput> | ProductQueryCreateWithoutProductInput[] | ProductQueryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutProductInput | ProductQueryCreateOrConnectWithoutProductInput[]
    createMany?: ProductQueryCreateManyProductInputEnvelope
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
  }

  export type EnumCategoriesFieldUpdateOperationsInput = {
    set?: $Enums.Categories
  }

  export type ProductsUpdatequestionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumModeFieldUpdateOperationsInput = {
    set?: $Enums.Mode | null
  }

  export type EnumTypeFieldUpdateOperationsInput = {
    set?: $Enums.Type
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type SellerAccountUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<SellerAccountCreateWithoutProductInput, SellerAccountUncheckedCreateWithoutProductInput>
    connectOrCreate?: SellerAccountCreateOrConnectWithoutProductInput
    upsert?: SellerAccountUpsertWithoutProductInput
    connect?: SellerAccountWhereUniqueInput
    update?: XOR<XOR<SellerAccountUpdateToOneWithWhereWithoutProductInput, SellerAccountUpdateWithoutProductInput>, SellerAccountUncheckedUpdateWithoutProductInput>
  }

  export type OrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductInput | OrderUpsertWithWhereUniqueWithoutProductInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductInput | OrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductInput | OrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WishListUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput> | WishListCreateWithoutProductInput[] | WishListUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutProductInput | WishListCreateOrConnectWithoutProductInput[]
    upsert?: WishListUpsertWithWhereUniqueWithoutProductInput | WishListUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishListCreateManyProductInputEnvelope
    set?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    disconnect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    delete?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    update?: WishListUpdateWithWhereUniqueWithoutProductInput | WishListUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishListUpdateManyWithWhereWithoutProductInput | WishListUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishListScalarWhereInput | WishListScalarWhereInput[]
  }

  export type ProductQueryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput> | ProductQueryCreateWithoutProductInput[] | ProductQueryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutProductInput | ProductQueryCreateOrConnectWithoutProductInput[]
    upsert?: ProductQueryUpsertWithWhereUniqueWithoutProductInput | ProductQueryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductQueryCreateManyProductInputEnvelope
    set?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    disconnect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    delete?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    update?: ProductQueryUpdateWithWhereUniqueWithoutProductInput | ProductQueryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductQueryUpdateManyWithWhereWithoutProductInput | ProductQueryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput> | OrderCreateWithoutProductInput[] | OrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProductInput | OrderCreateOrConnectWithoutProductInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProductInput | OrderUpsertWithWhereUniqueWithoutProductInput[]
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProductInput | OrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProductInput | OrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WishListUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput> | WishListCreateWithoutProductInput[] | WishListUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishListCreateOrConnectWithoutProductInput | WishListCreateOrConnectWithoutProductInput[]
    upsert?: WishListUpsertWithWhereUniqueWithoutProductInput | WishListUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishListCreateManyProductInputEnvelope
    set?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    disconnect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    delete?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    connect?: WishListWhereUniqueInput | WishListWhereUniqueInput[]
    update?: WishListUpdateWithWhereUniqueWithoutProductInput | WishListUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishListUpdateManyWithWhereWithoutProductInput | WishListUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishListScalarWhereInput | WishListScalarWhereInput[]
  }

  export type ProductQueryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput> | ProductQueryCreateWithoutProductInput[] | ProductQueryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductQueryCreateOrConnectWithoutProductInput | ProductQueryCreateOrConnectWithoutProductInput[]
    upsert?: ProductQueryUpsertWithWhereUniqueWithoutProductInput | ProductQueryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductQueryCreateManyProductInputEnvelope
    set?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    disconnect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    delete?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    connect?: ProductQueryWhereUniqueInput | ProductQueryWhereUniqueInput[]
    update?: ProductQueryUpdateWithWhereUniqueWithoutProductInput | ProductQueryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductQueryUpdateManyWithWhereWithoutProductInput | ProductQueryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
  }

  export type ProductQueryCreatequestionInput = {
    set: string[]
  }

  export type ProductQueryCreateanswersInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProductQueryInput = {
    create?: XOR<UserCreateWithoutProductQueryInput, UserUncheckedCreateWithoutProductQueryInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductQueryInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutQueriesInput = {
    create?: XOR<ProductsCreateWithoutQueriesInput, ProductsUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutQueriesInput
    connect?: ProductsWhereUniqueInput
  }

  export type ProductQueryUpdatequestionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductQueryUpdateanswersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProductQueryNestedInput = {
    create?: XOR<UserCreateWithoutProductQueryInput, UserUncheckedCreateWithoutProductQueryInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductQueryInput
    upsert?: UserUpsertWithoutProductQueryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductQueryInput, UserUpdateWithoutProductQueryInput>, UserUncheckedUpdateWithoutProductQueryInput>
  }

  export type ProductsUpdateOneWithoutQueriesNestedInput = {
    create?: XOR<ProductsCreateWithoutQueriesInput, ProductsUncheckedCreateWithoutQueriesInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutQueriesInput
    upsert?: ProductsUpsertWithoutQueriesInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutQueriesInput, ProductsUpdateWithoutQueriesInput>, ProductsUncheckedUpdateWithoutQueriesInput>
  }

  export type UserCreateNestedOneWithoutWishListInput = {
    create?: XOR<UserCreateWithoutWishListInput, UserUncheckedCreateWithoutWishListInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishListInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutWishListInput = {
    create?: XOR<ProductsCreateWithoutWishListInput, ProductsUncheckedCreateWithoutWishListInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutWishListInput
    connect?: ProductsWhereUniqueInput
  }

  export type UserUpdateOneWithoutWishListNestedInput = {
    create?: XOR<UserCreateWithoutWishListInput, UserUncheckedCreateWithoutWishListInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishListInput
    upsert?: UserUpsertWithoutWishListInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishListInput, UserUpdateWithoutWishListInput>, UserUncheckedUpdateWithoutWishListInput>
  }

  export type ProductsUpdateOneWithoutWishListNestedInput = {
    create?: XOR<ProductsCreateWithoutWishListInput, ProductsUncheckedCreateWithoutWishListInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutWishListInput
    upsert?: ProductsUpsertWithoutWishListInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutWishListInput, ProductsUpdateWithoutWishListInput>, ProductsUncheckedUpdateWithoutWishListInput>
  }

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    connect?: UserWhereUniqueInput
  }

  export type ProductsCreateNestedOneWithoutReviewInput = {
    create?: XOR<ProductsCreateWithoutReviewInput, ProductsUncheckedCreateWithoutReviewInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutReviewInput
    connect?: ProductsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    upsert?: UserUpsertWithoutReviewInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>
  }

  export type ProductsUpdateOneWithoutReviewNestedInput = {
    create?: XOR<ProductsCreateWithoutReviewInput, ProductsUncheckedCreateWithoutReviewInput>
    connectOrCreate?: ProductsCreateOrConnectWithoutReviewInput
    upsert?: ProductsUpsertWithoutReviewInput
    disconnect?: ProductsWhereInput | boolean
    delete?: ProductsWhereInput | boolean
    connect?: ProductsWhereUniqueInput
    update?: XOR<XOR<ProductsUpdateToOneWithWhereWithoutReviewInput, ProductsUpdateWithoutReviewInput>, ProductsUncheckedUpdateWithoutReviewInput>
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type NestedEnumTypetransFilter<$PrismaModel = never> = {
    equals?: $Enums.Typetrans | EnumTypetransFieldRefInput<$PrismaModel>
    in?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    notIn?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    not?: NestedEnumTypetransFilter<$PrismaModel> | $Enums.Typetrans
  }

  export type NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTypetransWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Typetrans | EnumTypetransFieldRefInput<$PrismaModel>
    in?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    notIn?: $Enums.Typetrans[] | ListEnumTypetransFieldRefInput<$PrismaModel>
    not?: NestedEnumTypetransWithAggregatesFilter<$PrismaModel> | $Enums.Typetrans
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypetransFilter<$PrismaModel>
    _max?: NestedEnumTypetransFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoteTypeNullableFilter<$PrismaModel> | $Enums.NoteType | null
  }

  export type NestedEnumNoteTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoteTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NoteType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMsgtypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Msgtype | EnumMsgtypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMsgtypeNullableFilter<$PrismaModel> | $Enums.Msgtype | null
  }

  export type NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleMsgStatus | EnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel> | $Enums.ScheduleMsgStatus | null
  }

  export type NestedEnumMsgtypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Msgtype | EnumMsgtypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Msgtype[] | ListEnumMsgtypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMsgtypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Msgtype | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMsgtypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMsgtypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumScheduleMsgStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleMsgStatus | EnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleMsgStatus[] | ListEnumScheduleMsgStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleMsgStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleMsgStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumScheduleMsgStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoriesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categories | EnumCategoriesFieldRefInput<$PrismaModel>
    in?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoriesFilter<$PrismaModel> | $Enums.Categories
  }

  export type NestedEnumModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Mode | EnumModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModeNullableFilter<$PrismaModel> | $Enums.Mode | null
  }

  export type NestedEnumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeFilter<$PrismaModel> | $Enums.Type
  }

  export type NestedEnumCategoriesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categories | EnumCategoriesFieldRefInput<$PrismaModel>
    in?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categories[] | ListEnumCategoriesFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoriesWithAggregatesFilter<$PrismaModel> | $Enums.Categories
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoriesFilter<$PrismaModel>
    _max?: NestedEnumCategoriesFilter<$PrismaModel>
  }

  export type NestedEnumModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Mode | EnumModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mode[] | ListEnumModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Mode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumModeNullableFilter<$PrismaModel>
    _max?: NestedEnumModeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Type | EnumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Type[] | ListEnumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeWithAggregatesFilter<$PrismaModel> | $Enums.Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeFilter<$PrismaModel>
    _max?: NestedEnumTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutUserInput = {
    email: string
    name: string
    verified: boolean
    phonenum: number
    createdat?: Date | string
  }

  export type TeamUncheckedCreateWithoutUserInput = {
    id?: number
    email: string
    name: string
    verified: boolean
    phonenum: number
    createdat?: Date | string
  }

  export type TeamCreateOrConnectWithoutUserInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
  }

  export type TeamCreateManyUserInputEnvelope = {
    data: TeamCreateManyUserInput | TeamCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutOwnerInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
  }

  export type ListingUncheckedCreateWithoutOwnerInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
  }

  export type ListingCreateOrConnectWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput>
  }

  export type ListingCreateManyOwnerInputEnvelope = {
    data: ListingCreateManyOwnerInput | ListingCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type SellerAccountCreateWithoutUserInput = {
    sales?: string | null
    Product?: ProductsCreateNestedManyWithoutSellerInput
    Order?: OrderCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountUncheckedCreateWithoutUserInput = {
    sales?: string | null
    Product?: ProductsUncheckedCreateNestedManyWithoutSellerInput
    Order?: OrderUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountCreateOrConnectWithoutUserInput = {
    where: SellerAccountWhereUniqueInput
    create: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
  }

  export type DealersCreateWithoutUsersInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
  }

  export type DealersUncheckedCreateWithoutUsersInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
  }

  export type DealersCreateOrConnectWithoutUsersInput = {
    where: DealersWhereUniqueInput
    create: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput>
  }

  export type DealersCreateManyUsersInputEnvelope = {
    data: DealersCreateManyUsersInput | DealersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type JobProfileCreateWithoutUserInput = {
    rating?: number | null
    jobsapplied?: JobProfileCreatejobsappliedInput | string[]
    lastdisabled?: Date | string | null
    createdAt?: Date | string
    workdone?: number | null
    status: boolean
    location?: string | null
  }

  export type JobProfileUncheckedCreateWithoutUserInput = {
    rating?: number | null
    jobsapplied?: JobProfileCreatejobsappliedInput | string[]
    lastdisabled?: Date | string | null
    createdAt?: Date | string
    workdone?: number | null
    status: boolean
    location?: string | null
  }

  export type JobProfileCreateOrConnectWithoutUserInput = {
    where: JobProfileWhereUniqueInput
    create: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating?: number | null
    review?: string | null
    username?: string | null
    Product?: ProductsCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    rating?: number | null
    review?: string | null
    username?: string | null
    productId?: string | null
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishListCreateWithoutUserInput = {
    id?: string
    Product?: ProductsCreateNestedOneWithoutWishListInput
  }

  export type WishListUncheckedCreateWithoutUserInput = {
    id?: string
    productid?: string | null
  }

  export type WishListCreateOrConnectWithoutUserInput = {
    where: WishListWhereUniqueInput
    create: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput>
  }

  export type WishListCreateManyUserInputEnvelope = {
    data: WishListCreateManyUserInput | WishListCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    userid?: string | null
    name?: string | null
    Project: ProjectCreateNestedOneWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    userid?: string | null
    projectId: string
    name?: string | null
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductQueryCreateWithoutUserInput = {
    username?: string | null
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    Product?: ProductsCreateNestedOneWithoutQueriesInput
  }

  export type ProductQueryUncheckedCreateWithoutUserInput = {
    id?: number
    username?: string | null
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    productId?: string | null
  }

  export type ProductQueryCreateOrConnectWithoutUserInput = {
    where: ProductQueryWhereUniqueInput
    create: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput>
  }

  export type ProductQueryCreateManyUserInputEnvelope = {
    data: ProductQueryCreateManyUserInput | ProductQueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    category?: EnumCategoryFilter<"Project"> | $Enums.Category
    createdAt?: DateTimeFilter<"Project"> | Date | string
    userid?: StringFilter<"Project"> | string
    coverimgUrl?: StringNullableFilter<"Project"> | string | null
    budget?: IntNullableFilter<"Project"> | number | null
  }

  export type TeamUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutUserInput, TeamUncheckedUpdateWithoutUserInput>
    create: XOR<TeamCreateWithoutUserInput, TeamUncheckedCreateWithoutUserInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutUserInput, TeamUncheckedUpdateWithoutUserInput>
  }

  export type TeamUpdateManyWithWhereWithoutUserInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    email?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    verified?: BoolFilter<"Team"> | boolean
    phonenum?: IntFilter<"Team"> | number
    useriid?: StringNullableFilter<"Team"> | string | null
    createdat?: DateTimeFilter<"Team"> | Date | string
  }

  export type ListingUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutOwnerInput, ListingUncheckedUpdateWithoutOwnerInput>
    create: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutOwnerInput, ListingUncheckedUpdateWithoutOwnerInput>
  }

  export type ListingUpdateManyWithWhereWithoutOwnerInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ListingScalarWhereInput = {
    AND?: ListingScalarWhereInput | ListingScalarWhereInput[]
    OR?: ListingScalarWhereInput[]
    NOT?: ListingScalarWhereInput | ListingScalarWhereInput[]
    id?: StringFilter<"Listing"> | string
    image?: StringFilter<"Listing"> | string
    rating?: FloatFilter<"Listing"> | number
    address?: StringFilter<"Listing"> | string
    soldout?: BoolFilter<"Listing"> | boolean
    description?: StringNullableFilter<"Listing"> | string | null
    ownerId?: StringNullableFilter<"Listing"> | string | null
  }

  export type SellerAccountUpsertWithoutUserInput = {
    update: XOR<SellerAccountUpdateWithoutUserInput, SellerAccountUncheckedUpdateWithoutUserInput>
    create: XOR<SellerAccountCreateWithoutUserInput, SellerAccountUncheckedCreateWithoutUserInput>
    where?: SellerAccountWhereInput
  }

  export type SellerAccountUpdateToOneWithWhereWithoutUserInput = {
    where?: SellerAccountWhereInput
    data: XOR<SellerAccountUpdateWithoutUserInput, SellerAccountUncheckedUpdateWithoutUserInput>
  }

  export type SellerAccountUpdateWithoutUserInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductsUpdateManyWithoutSellerNestedInput
    Order?: OrderUpdateManyWithoutSellerNestedInput
  }

  export type SellerAccountUncheckedUpdateWithoutUserInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductsUncheckedUpdateManyWithoutSellerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type DealersUpsertWithWhereUniqueWithoutUsersInput = {
    where: DealersWhereUniqueInput
    update: XOR<DealersUpdateWithoutUsersInput, DealersUncheckedUpdateWithoutUsersInput>
    create: XOR<DealersCreateWithoutUsersInput, DealersUncheckedCreateWithoutUsersInput>
  }

  export type DealersUpdateWithWhereUniqueWithoutUsersInput = {
    where: DealersWhereUniqueInput
    data: XOR<DealersUpdateWithoutUsersInput, DealersUncheckedUpdateWithoutUsersInput>
  }

  export type DealersUpdateManyWithWhereWithoutUsersInput = {
    where: DealersScalarWhereInput
    data: XOR<DealersUpdateManyMutationInput, DealersUncheckedUpdateManyWithoutUsersInput>
  }

  export type DealersScalarWhereInput = {
    AND?: DealersScalarWhereInput | DealersScalarWhereInput[]
    OR?: DealersScalarWhereInput[]
    NOT?: DealersScalarWhereInput | DealersScalarWhereInput[]
    id?: StringFilter<"Dealers"> | string
    idd?: StringNullableFilter<"Dealers"> | string | null
    name?: StringNullableFilter<"Dealers"> | string | null
    dealeremail?: StringNullableFilter<"Dealers"> | string | null
    dealerid?: StringNullableFilter<"Dealers"> | string | null
    email?: StringNullableFilter<"Dealers"> | string | null
    phonenum?: StringNullableFilter<"Dealers"> | string | null
    verified?: BoolNullableFilter<"Dealers"> | boolean | null
    address?: StringNullableFilter<"Dealers"> | string | null
    category?: StringNullableFilter<"Dealers"> | string | null
    transactionWorth?: IntNullableFilter<"Dealers"> | number | null
    createdAt?: DateTimeFilter<"Dealers"> | Date | string
  }

  export type JobProfileUpsertWithoutUserInput = {
    update: XOR<JobProfileUpdateWithoutUserInput, JobProfileUncheckedUpdateWithoutUserInput>
    create: XOR<JobProfileCreateWithoutUserInput, JobProfileUncheckedCreateWithoutUserInput>
    where?: JobProfileWhereInput
  }

  export type JobProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: JobProfileWhereInput
    data: XOR<JobProfileUpdateWithoutUserInput, JobProfileUncheckedUpdateWithoutUserInput>
  }

  export type JobProfileUpdateWithoutUserInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobProfileUncheckedUpdateWithoutUserInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    jobsapplied?: JobProfileUpdatejobsappliedInput | string[]
    lastdisabled?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workdone?: NullableIntFieldUpdateOperationsInput | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: FloatNullableFilter<"Review"> | number | null
    review?: StringNullableFilter<"Review"> | string | null
    userid?: StringNullableFilter<"Review"> | string | null
    username?: StringNullableFilter<"Review"> | string | null
    productId?: StringNullableFilter<"Review"> | string | null
  }

  export type WishListUpsertWithWhereUniqueWithoutUserInput = {
    where: WishListWhereUniqueInput
    update: XOR<WishListUpdateWithoutUserInput, WishListUncheckedUpdateWithoutUserInput>
    create: XOR<WishListCreateWithoutUserInput, WishListUncheckedCreateWithoutUserInput>
  }

  export type WishListUpdateWithWhereUniqueWithoutUserInput = {
    where: WishListWhereUniqueInput
    data: XOR<WishListUpdateWithoutUserInput, WishListUncheckedUpdateWithoutUserInput>
  }

  export type WishListUpdateManyWithWhereWithoutUserInput = {
    where: WishListScalarWhereInput
    data: XOR<WishListUpdateManyMutationInput, WishListUncheckedUpdateManyWithoutUserInput>
  }

  export type WishListScalarWhereInput = {
    AND?: WishListScalarWhereInput | WishListScalarWhereInput[]
    OR?: WishListScalarWhereInput[]
    NOT?: WishListScalarWhereInput | WishListScalarWhereInput[]
    id?: StringFilter<"WishList"> | string
    userid?: StringNullableFilter<"WishList"> | string | null
    productid?: StringNullableFilter<"WishList"> | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    userid?: StringNullableFilter<"Member"> | string | null
    projectId?: StringFilter<"Member"> | string
    name?: StringNullableFilter<"Member"> | string | null
    useremail?: StringFilter<"Member"> | string
  }

  export type ProductQueryUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductQueryWhereUniqueInput
    update: XOR<ProductQueryUpdateWithoutUserInput, ProductQueryUncheckedUpdateWithoutUserInput>
    create: XOR<ProductQueryCreateWithoutUserInput, ProductQueryUncheckedCreateWithoutUserInput>
  }

  export type ProductQueryUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductQueryWhereUniqueInput
    data: XOR<ProductQueryUpdateWithoutUserInput, ProductQueryUncheckedUpdateWithoutUserInput>
  }

  export type ProductQueryUpdateManyWithWhereWithoutUserInput = {
    where: ProductQueryScalarWhereInput
    data: XOR<ProductQueryUpdateManyMutationInput, ProductQueryUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductQueryScalarWhereInput = {
    AND?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
    OR?: ProductQueryScalarWhereInput[]
    NOT?: ProductQueryScalarWhereInput | ProductQueryScalarWhereInput[]
    id?: IntFilter<"ProductQuery"> | number
    username?: StringNullableFilter<"ProductQuery"> | string | null
    userid?: StringFilter<"ProductQuery"> | string
    name?: StringNullableFilter<"ProductQuery"> | string | null
    contact?: StringNullableFilter<"ProductQuery"> | string | null
    additionalQueies?: StringNullableFilter<"ProductQuery"> | string | null
    question?: StringNullableListFilter<"ProductQuery">
    answers?: StringNullableListFilter<"ProductQuery">
    productId?: StringNullableFilter<"ProductQuery"> | string | null
  }

  export type UserCreateWithoutJobProfleInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobProfleInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobProfleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobProfleInput, UserUncheckedCreateWithoutJobProfleInput>
  }

  export type UserUpsertWithoutJobProfleInput = {
    update: XOR<UserUpdateWithoutJobProfleInput, UserUncheckedUpdateWithoutJobProfleInput>
    create: XOR<UserCreateWithoutJobProfleInput, UserUncheckedCreateWithoutJobProfleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobProfleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobProfleInput, UserUncheckedUpdateWithoutJobProfleInput>
  }

  export type UserUpdateWithoutJobProfleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobProfleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDealerInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDealerInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDealerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDealerInput, UserUncheckedCreateWithoutDealerInput>
  }

  export type UserUpsertWithoutDealerInput = {
    update: XOR<UserUpdateWithoutDealerInput, UserUncheckedUpdateWithoutDealerInput>
    create: XOR<UserCreateWithoutDealerInput, UserUncheckedCreateWithoutDealerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDealerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDealerInput, UserUncheckedUpdateWithoutDealerInput>
  }

  export type UserUpdateWithoutDealerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDealerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SellerAccountCreateWithoutOrderInput = {
    sales?: string | null
    User?: UserCreateNestedOneWithoutSelleraccountInput
    Product?: ProductsCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountUncheckedCreateWithoutOrderInput = {
    id: string
    sales?: string | null
    Product?: ProductsUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountCreateOrConnectWithoutOrderInput = {
    where: SellerAccountWhereUniqueInput
    create: XOR<SellerAccountCreateWithoutOrderInput, SellerAccountUncheckedCreateWithoutOrderInput>
  }

  export type ProductsCreateWithoutOrderInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewCreateNestedManyWithoutProductInput
    Seller: SellerAccountCreateNestedOneWithoutProductInput
    WishList?: WishListCreateNestedManyWithoutProductInput
    Queries?: ProductQueryCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutOrderInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
    Review?: ReviewUncheckedCreateNestedManyWithoutProductInput
    WishList?: WishListUncheckedCreateNestedManyWithoutProductInput
    Queries?: ProductQueryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutOrderInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput>
  }

  export type SellerAccountUpsertWithoutOrderInput = {
    update: XOR<SellerAccountUpdateWithoutOrderInput, SellerAccountUncheckedUpdateWithoutOrderInput>
    create: XOR<SellerAccountCreateWithoutOrderInput, SellerAccountUncheckedCreateWithoutOrderInput>
    where?: SellerAccountWhereInput
  }

  export type SellerAccountUpdateToOneWithWhereWithoutOrderInput = {
    where?: SellerAccountWhereInput
    data: XOR<SellerAccountUpdateWithoutOrderInput, SellerAccountUncheckedUpdateWithoutOrderInput>
  }

  export type SellerAccountUpdateWithoutOrderInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutSelleraccountNestedInput
    Product?: ProductsUpdateManyWithoutSellerNestedInput
  }

  export type SellerAccountUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductsUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type ProductsUpsertWithWhereUniqueWithoutOrderInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutOrderInput, ProductsUncheckedUpdateWithoutOrderInput>
    create: XOR<ProductsCreateWithoutOrderInput, ProductsUncheckedCreateWithoutOrderInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutOrderInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutOrderInput, ProductsUncheckedUpdateWithoutOrderInput>
  }

  export type ProductsUpdateManyWithWhereWithoutOrderInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProductsScalarWhereInput = {
    AND?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    OR?: ProductsScalarWhereInput[]
    NOT?: ProductsScalarWhereInput | ProductsScalarWhereInput[]
    id?: StringFilter<"Products"> | string
    name?: StringFilter<"Products"> | string
    price?: StringNullableFilter<"Products"> | string | null
    description?: StringNullableFilter<"Products"> | string | null
    rating?: StringNullableFilter<"Products"> | string | null
    imageurl?: StringNullableFilter<"Products"> | string | null
    quantity?: StringNullableFilter<"Products"> | string | null
    sellerName?: StringFilter<"Products"> | string
    expirydate?: StringNullableFilter<"Products"> | string | null
    category?: EnumCategoriesFilter<"Products"> | $Enums.Categories
    specialmsg?: StringNullableFilter<"Products"> | string | null
    stock?: StringNullableFilter<"Products"> | string | null
    contact?: StringNullableFilter<"Products"> | string | null
    questions?: StringNullableListFilter<"Products">
    mode?: EnumModeNullableFilter<"Products"> | $Enums.Mode | null
    type?: EnumTypeFilter<"Products"> | $Enums.Type
    offers?: StringNullableFilter<"Products"> | string | null
    sellerid?: StringFilter<"Products"> | string
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type MemberCreateWithoutProjectInput = {
    id?: string
    userid?: string | null
    name?: string | null
    User: UserCreateNestedOneWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userid?: string | null
    name?: string | null
    useremail: string
  }

  export type MemberCreateOrConnectWithoutProjectInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberCreateManyProjectInputEnvelope = {
    data: MemberCreateManyProjectInput | MemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    createdAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    createdAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FinanceCreateWithoutFinanceInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionCreateNestedManyWithoutFinanceInput
    notes?: NoteCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUncheckedCreateWithoutFinanceInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutFinanceInput
    notes?: NoteUncheckedCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersUncheckedCreateNestedManyWithoutFinanceInput
  }

  export type FinanceCreateOrConnectWithoutFinanceInput = {
    where: FinanceWhereUniqueInput
    create: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: DocumentCreateManyProjectInput | DocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleMsgCreateWithoutProjectInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
  }

  export type ScheduleMsgUncheckedCreateWithoutProjectInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
  }

  export type ScheduleMsgCreateOrConnectWithoutProjectInput = {
    where: ScheduleMsgWhereUniqueInput
    create: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput>
  }

  export type ScheduleMsgCreateManyProjectInputEnvelope = {
    data: ScheduleMsgCreateManyProjectInput | ScheduleMsgCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutProjectInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
  }

  export type InventoryUncheckedCreateWithoutProjectInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
  }

  export type InventoryCreateOrConnectWithoutProjectInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput>
  }

  export type InventoryCreateManyProjectInputEnvelope = {
    data: InventoryCreateManyProjectInput | InventoryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
    create: XOR<MemberCreateWithoutProjectInput, MemberUncheckedCreateWithoutProjectInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutProjectInput, MemberUncheckedUpdateWithoutProjectInput>
  }

  export type MemberUpdateManyWithWhereWithoutProjectInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    task?: StringFilter<"Task"> | string
    team?: StringNullableListFilter<"Task">
    amount?: IntNullableFilter<"Task"> | number | null
    startdate?: StringFilter<"Task"> | string
    deadline?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    supplier?: StringNullableListFilter<"Task">
    subtasks?: StringNullableListFilter<"Task">
    inventories?: StringNullableListFilter<"Task">
    teamlead?: StringNullableFilter<"Task"> | string | null
    priority?: StringNullableFilter<"Task"> | string | null
    status?: BoolNullableFilter<"Task"> | boolean | null
    projectId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type FinanceUpsertWithoutFinanceInput = {
    update: XOR<FinanceUpdateWithoutFinanceInput, FinanceUncheckedUpdateWithoutFinanceInput>
    create: XOR<FinanceCreateWithoutFinanceInput, FinanceUncheckedCreateWithoutFinanceInput>
    where?: FinanceWhereInput
  }

  export type FinanceUpdateToOneWithWhereWithoutFinanceInput = {
    where?: FinanceWhereInput
    data: XOR<FinanceUpdateWithoutFinanceInput, FinanceUncheckedUpdateWithoutFinanceInput>
  }

  export type FinanceUpdateWithoutFinanceInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateManyWithoutFinanceNestedInput
    notes?: NoteUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceUncheckedUpdateWithoutFinanceInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutFinanceNestedInput
    notes?: NoteUncheckedUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUncheckedUpdateManyWithoutFinanceNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringNullableFilter<"Document"> | string | null
    originalName?: StringNullableFilter<"Document"> | string | null
    title?: StringFilter<"Document"> | string
    storageUrl?: StringNullableFilter<"Document"> | string | null
    uploadDate?: DateTimeFilter<"Document"> | Date | string
    isEncrypted?: BoolFilter<"Document"> | boolean
    notes?: StringNullableFilter<"Document"> | string | null
    projectId?: StringFilter<"Document"> | string
  }

  export type ScheduleMsgUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScheduleMsgWhereUniqueInput
    update: XOR<ScheduleMsgUpdateWithoutProjectInput, ScheduleMsgUncheckedUpdateWithoutProjectInput>
    create: XOR<ScheduleMsgCreateWithoutProjectInput, ScheduleMsgUncheckedCreateWithoutProjectInput>
  }

  export type ScheduleMsgUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScheduleMsgWhereUniqueInput
    data: XOR<ScheduleMsgUpdateWithoutProjectInput, ScheduleMsgUncheckedUpdateWithoutProjectInput>
  }

  export type ScheduleMsgUpdateManyWithWhereWithoutProjectInput = {
    where: ScheduleMsgScalarWhereInput
    data: XOR<ScheduleMsgUpdateManyMutationInput, ScheduleMsgUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScheduleMsgScalarWhereInput = {
    AND?: ScheduleMsgScalarWhereInput | ScheduleMsgScalarWhereInput[]
    OR?: ScheduleMsgScalarWhereInput[]
    NOT?: ScheduleMsgScalarWhereInput | ScheduleMsgScalarWhereInput[]
    id?: StringFilter<"ScheduleMsg"> | string
    email?: StringNullableFilter<"ScheduleMsg"> | string | null
    phonenum?: StringNullableFilter<"ScheduleMsg"> | string | null
    Datetime?: StringNullableFilter<"ScheduleMsg"> | string | null
    type?: EnumMsgtypeNullableFilter<"ScheduleMsg"> | $Enums.Msgtype | null
    text?: StringNullableFilter<"ScheduleMsg"> | string | null
    status?: EnumScheduleMsgStatusNullableFilter<"ScheduleMsg"> | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFilter<"ScheduleMsg"> | Date | string
    projectId?: StringFilter<"ScheduleMsg"> | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProjectInput, InventoryUncheckedUpdateWithoutProjectInput>
    create: XOR<InventoryCreateWithoutProjectInput, InventoryUncheckedCreateWithoutProjectInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProjectInput, InventoryUncheckedUpdateWithoutProjectInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProjectInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: StringFilter<"Inventory"> | string
    available?: BoolNullableFilter<"Inventory"> | boolean | null
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    value?: BigIntFilter<"Inventory"> | bigint | number
    stock?: StringNullableFilter<"Inventory"> | string | null
    valueperpeice?: StringNullableFilter<"Inventory"> | string | null
    projectId?: StringFilter<"Inventory"> | string
  }

  export type ProjectCreateWithoutMemberInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMemberInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMemberInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMemberInput, ProjectUncheckedCreateWithoutMemberInput>
  }

  export type UserCreateWithoutMemberInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMemberInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
  }

  export type ProjectUpsertWithoutMemberInput = {
    update: XOR<ProjectUpdateWithoutMemberInput, ProjectUncheckedUpdateWithoutMemberInput>
    create: XOR<ProjectCreateWithoutMemberInput, ProjectUncheckedCreateWithoutMemberInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMemberInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMemberInput, ProjectUncheckedUpdateWithoutMemberInput>
  }

  export type ProjectUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMemberInput = {
    update: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
    create: XOR<UserCreateWithoutMemberInput, UserUncheckedCreateWithoutMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMemberInput, UserUncheckedUpdateWithoutMemberInput>
  }

  export type UserUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutInventoryInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInventoryInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
  }

  export type ProjectUpsertWithoutInventoryInput = {
    update: XOR<ProjectUpdateWithoutInventoryInput, ProjectUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProjectCreateWithoutInventoryInput, ProjectUncheckedCreateWithoutInventoryInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInventoryInput, ProjectUncheckedUpdateWithoutInventoryInput>
  }

  export type ProjectUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutTeamInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserUpsertWithoutTeamInput = {
    update: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutListingInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListingInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingInput, UserUncheckedCreateWithoutListingInput>
  }

  export type UserUpsertWithoutListingInput = {
    update: XOR<UserUpdateWithoutListingInput, UserUncheckedUpdateWithoutListingInput>
    create: XOR<UserCreateWithoutListingInput, UserUncheckedCreateWithoutListingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListingInput, UserUncheckedUpdateWithoutListingInput>
  }

  export type UserUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutTaskInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTaskInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTaskInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTaskInput, ProjectUncheckedCreateWithoutTaskInput>
  }

  export type ProjectUpsertWithoutTaskInput = {
    update: XOR<ProjectUpdateWithoutTaskInput, ProjectUncheckedUpdateWithoutTaskInput>
    create: XOR<ProjectCreateWithoutTaskInput, ProjectUncheckedCreateWithoutTaskInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTaskInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTaskInput, ProjectUncheckedUpdateWithoutTaskInput>
  }

  export type ProjectUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type FinanceCreateWithoutTransactionInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    finance?: ProjectCreateNestedOneWithoutFinanceInput
    notes?: NoteCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUncheckedCreateWithoutTransactionInput = {
    id?: string
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    notes?: NoteUncheckedCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersUncheckedCreateNestedManyWithoutFinanceInput
  }

  export type FinanceCreateOrConnectWithoutTransactionInput = {
    where: FinanceWhereUniqueInput
    create: XOR<FinanceCreateWithoutTransactionInput, FinanceUncheckedCreateWithoutTransactionInput>
  }

  export type FinanceUpsertWithoutTransactionInput = {
    update: XOR<FinanceUpdateWithoutTransactionInput, FinanceUncheckedUpdateWithoutTransactionInput>
    create: XOR<FinanceCreateWithoutTransactionInput, FinanceUncheckedCreateWithoutTransactionInput>
    where?: FinanceWhereInput
  }

  export type FinanceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: FinanceWhereInput
    data: XOR<FinanceUpdateWithoutTransactionInput, FinanceUncheckedUpdateWithoutTransactionInput>
  }

  export type FinanceUpdateWithoutTransactionInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    finance?: ProjectUpdateOneWithoutFinanceNestedInput
    notes?: NoteUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NoteUncheckedUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUncheckedUpdateManyWithoutFinanceNestedInput
  }

  export type TransactionCreateWithoutFinanceInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutFinanceInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutFinanceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput>
  }

  export type TransactionCreateManyFinanceInputEnvelope = {
    data: TransactionCreateManyFinanceInput | TransactionCreateManyFinanceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutFinanceInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFinanceInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFinanceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFinanceInput, ProjectUncheckedCreateWithoutFinanceInput>
  }

  export type NoteCreateWithoutFinanceInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    type?: $Enums.NoteType | null
  }

  export type NoteUncheckedCreateWithoutFinanceInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    type?: $Enums.NoteType | null
  }

  export type NoteCreateOrConnectWithoutFinanceInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput>
  }

  export type NoteCreateManyFinanceInputEnvelope = {
    data: NoteCreateManyFinanceInput | NoteCreateManyFinanceInput[]
    skipDuplicates?: boolean
  }

  export type RemaindersCreateWithoutFinanceInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
  }

  export type RemaindersUncheckedCreateWithoutFinanceInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
  }

  export type RemaindersCreateOrConnectWithoutFinanceInput = {
    where: RemaindersWhereUniqueInput
    create: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput>
  }

  export type RemaindersCreateManyFinanceInputEnvelope = {
    data: RemaindersCreateManyFinanceInput | RemaindersCreateManyFinanceInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutFinanceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFinanceInput, TransactionUncheckedUpdateWithoutFinanceInput>
    create: XOR<TransactionCreateWithoutFinanceInput, TransactionUncheckedCreateWithoutFinanceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFinanceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFinanceInput, TransactionUncheckedUpdateWithoutFinanceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFinanceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFinanceInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    gstrate?: IntNullableFilter<"Transaction"> | number | null
    dealer?: StringFilter<"Transaction"> | string
    status?: EnumStatusNullableFilter<"Transaction"> | $Enums.Status | null
    proof?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTypetransFilter<"Transaction"> | $Enums.Typetrans
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    financeId?: StringFilter<"Transaction"> | string
  }

  export type ProjectUpsertWithoutFinanceInput = {
    update: XOR<ProjectUpdateWithoutFinanceInput, ProjectUncheckedUpdateWithoutFinanceInput>
    create: XOR<ProjectCreateWithoutFinanceInput, ProjectUncheckedCreateWithoutFinanceInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFinanceInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFinanceInput, ProjectUncheckedUpdateWithoutFinanceInput>
  }

  export type ProjectUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutFinanceInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutFinanceInput, NoteUncheckedUpdateWithoutFinanceInput>
    create: XOR<NoteCreateWithoutFinanceInput, NoteUncheckedCreateWithoutFinanceInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutFinanceInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutFinanceInput, NoteUncheckedUpdateWithoutFinanceInput>
  }

  export type NoteUpdateManyWithWhereWithoutFinanceInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutFinanceInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    title?: StringNullableFilter<"Note"> | string | null
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    financeId?: StringFilter<"Note"> | string
    type?: EnumNoteTypeNullableFilter<"Note"> | $Enums.NoteType | null
  }

  export type RemaindersUpsertWithWhereUniqueWithoutFinanceInput = {
    where: RemaindersWhereUniqueInput
    update: XOR<RemaindersUpdateWithoutFinanceInput, RemaindersUncheckedUpdateWithoutFinanceInput>
    create: XOR<RemaindersCreateWithoutFinanceInput, RemaindersUncheckedCreateWithoutFinanceInput>
  }

  export type RemaindersUpdateWithWhereUniqueWithoutFinanceInput = {
    where: RemaindersWhereUniqueInput
    data: XOR<RemaindersUpdateWithoutFinanceInput, RemaindersUncheckedUpdateWithoutFinanceInput>
  }

  export type RemaindersUpdateManyWithWhereWithoutFinanceInput = {
    where: RemaindersScalarWhereInput
    data: XOR<RemaindersUpdateManyMutationInput, RemaindersUncheckedUpdateManyWithoutFinanceInput>
  }

  export type RemaindersScalarWhereInput = {
    AND?: RemaindersScalarWhereInput | RemaindersScalarWhereInput[]
    OR?: RemaindersScalarWhereInput[]
    NOT?: RemaindersScalarWhereInput | RemaindersScalarWhereInput[]
    id?: StringFilter<"Remainders"> | string
    amount?: IntFilter<"Remainders"> | number
    dealer?: StringFilter<"Remainders"> | string
    date?: DateTimeFilter<"Remainders"> | Date | string
    financeId?: StringFilter<"Remainders"> | string
  }

  export type FinanceCreateWithoutRemainderInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionCreateNestedManyWithoutFinanceInput
    finance?: ProjectCreateNestedOneWithoutFinanceInput
    notes?: NoteCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUncheckedCreateWithoutRemainderInput = {
    id?: string
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutFinanceInput
    notes?: NoteUncheckedCreateNestedManyWithoutFinanceInput
  }

  export type FinanceCreateOrConnectWithoutRemainderInput = {
    where: FinanceWhereUniqueInput
    create: XOR<FinanceCreateWithoutRemainderInput, FinanceUncheckedCreateWithoutRemainderInput>
  }

  export type FinanceUpsertWithoutRemainderInput = {
    update: XOR<FinanceUpdateWithoutRemainderInput, FinanceUncheckedUpdateWithoutRemainderInput>
    create: XOR<FinanceCreateWithoutRemainderInput, FinanceUncheckedCreateWithoutRemainderInput>
    where?: FinanceWhereInput
  }

  export type FinanceUpdateToOneWithWhereWithoutRemainderInput = {
    where?: FinanceWhereInput
    data: XOR<FinanceUpdateWithoutRemainderInput, FinanceUncheckedUpdateWithoutRemainderInput>
  }

  export type FinanceUpdateWithoutRemainderInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateManyWithoutFinanceNestedInput
    finance?: ProjectUpdateOneWithoutFinanceNestedInput
    notes?: NoteUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceUncheckedUpdateWithoutRemainderInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutFinanceNestedInput
    notes?: NoteUncheckedUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceCreateWithoutNotesInput = {
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionCreateNestedManyWithoutFinanceInput
    finance?: ProjectCreateNestedOneWithoutFinanceInput
    remainder?: RemaindersCreateNestedManyWithoutFinanceInput
  }

  export type FinanceUncheckedCreateWithoutNotesInput = {
    id?: string
    income?: number | null
    expenditure?: number | null
    budget?: number | null
    balance?: number | null
    MPIN?: string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutFinanceInput
    remainder?: RemaindersUncheckedCreateNestedManyWithoutFinanceInput
  }

  export type FinanceCreateOrConnectWithoutNotesInput = {
    where: FinanceWhereUniqueInput
    create: XOR<FinanceCreateWithoutNotesInput, FinanceUncheckedCreateWithoutNotesInput>
  }

  export type FinanceUpsertWithoutNotesInput = {
    update: XOR<FinanceUpdateWithoutNotesInput, FinanceUncheckedUpdateWithoutNotesInput>
    create: XOR<FinanceCreateWithoutNotesInput, FinanceUncheckedCreateWithoutNotesInput>
    where?: FinanceWhereInput
  }

  export type FinanceUpdateToOneWithWhereWithoutNotesInput = {
    where?: FinanceWhereInput
    data: XOR<FinanceUpdateWithoutNotesInput, FinanceUncheckedUpdateWithoutNotesInput>
  }

  export type FinanceUpdateWithoutNotesInput = {
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateManyWithoutFinanceNestedInput
    finance?: ProjectUpdateOneWithoutFinanceNestedInput
    remainder?: RemaindersUpdateManyWithoutFinanceNestedInput
  }

  export type FinanceUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    income?: NullableIntFieldUpdateOperationsInput | number | null
    expenditure?: NullableIntFieldUpdateOperationsInput | number | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    MPIN?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutFinanceNestedInput
    remainder?: RemaindersUncheckedUpdateManyWithoutFinanceNestedInput
  }

  export type ProjectCreateWithoutScheduledMsgInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutScheduledMsgInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutScheduledMsgInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutScheduledMsgInput, ProjectUncheckedCreateWithoutScheduledMsgInput>
  }

  export type ProjectUpsertWithoutScheduledMsgInput = {
    update: XOR<ProjectUpdateWithoutScheduledMsgInput, ProjectUncheckedUpdateWithoutScheduledMsgInput>
    create: XOR<ProjectCreateWithoutScheduledMsgInput, ProjectUncheckedCreateWithoutScheduledMsgInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutScheduledMsgInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutScheduledMsgInput, ProjectUncheckedUpdateWithoutScheduledMsgInput>
  }

  export type ProjectUpdateWithoutScheduledMsgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutScheduledMsgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutSelleraccountInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSelleraccountInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSelleraccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSelleraccountInput, UserUncheckedCreateWithoutSelleraccountInput>
  }

  export type ProductsCreateWithoutSellerInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    WishList?: WishListCreateNestedManyWithoutProductInput
    Queries?: ProductQueryCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutSellerInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
    WishList?: WishListUncheckedCreateNestedManyWithoutProductInput
    Queries?: ProductQueryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutSellerInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput>
  }

  export type ProductsCreateManySellerInputEnvelope = {
    data: ProductsCreateManySellerInput | ProductsCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutSellerInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
    product?: ProductsCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSellerInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
    product?: ProductsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSellerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
  }

  export type OrderCreateManySellerInputEnvelope = {
    data: OrderCreateManySellerInput | OrderCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSelleraccountInput = {
    update: XOR<UserUpdateWithoutSelleraccountInput, UserUncheckedUpdateWithoutSelleraccountInput>
    create: XOR<UserCreateWithoutSelleraccountInput, UserUncheckedCreateWithoutSelleraccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSelleraccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSelleraccountInput, UserUncheckedUpdateWithoutSelleraccountInput>
  }

  export type UserUpdateWithoutSelleraccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSelleraccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithWhereUniqueWithoutSellerInput = {
    where: ProductsWhereUniqueInput
    update: XOR<ProductsUpdateWithoutSellerInput, ProductsUncheckedUpdateWithoutSellerInput>
    create: XOR<ProductsCreateWithoutSellerInput, ProductsUncheckedCreateWithoutSellerInput>
  }

  export type ProductsUpdateWithWhereUniqueWithoutSellerInput = {
    where: ProductsWhereUniqueInput
    data: XOR<ProductsUpdateWithoutSellerInput, ProductsUncheckedUpdateWithoutSellerInput>
  }

  export type ProductsUpdateManyWithWhereWithoutSellerInput = {
    where: ProductsScalarWhereInput
    data: XOR<ProductsUpdateManyMutationInput, ProductsUncheckedUpdateManyWithoutSellerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutSellerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSellerInput, OrderUncheckedUpdateWithoutSellerInput>
    create: XOR<OrderCreateWithoutSellerInput, OrderUncheckedCreateWithoutSellerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSellerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSellerInput, OrderUncheckedUpdateWithoutSellerInput>
  }

  export type OrderUpdateManyWithWhereWithoutSellerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSellerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderStatus?: EnumOrderStatusNullableFilter<"Order"> | $Enums.OrderStatus | null
    sellerid?: StringNullableFilter<"Order"> | string | null
    buyerName?: StringFilter<"Order"> | string
    buyerEmail?: StringFilter<"Order"> | string
    buyerContact?: StringNullableFilter<"Order"> | string | null
    buyerId?: StringNullableFilter<"Order"> | string | null
    orders?: StringNullableFilter<"Order"> | string | null
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating?: number | null
    review?: string | null
    username?: string | null
    User?: UserCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    rating?: number | null
    review?: string | null
    userid?: string | null
    username?: string | null
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SellerAccountCreateWithoutProductInput = {
    sales?: string | null
    User?: UserCreateNestedOneWithoutSelleraccountInput
    Order?: OrderCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountUncheckedCreateWithoutProductInput = {
    id: string
    sales?: string | null
    Order?: OrderUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerAccountCreateOrConnectWithoutProductInput = {
    where: SellerAccountWhereUniqueInput
    create: XOR<SellerAccountCreateWithoutProductInput, SellerAccountUncheckedCreateWithoutProductInput>
  }

  export type OrderCreateWithoutProductInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
    seller?: SellerAccountCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    sellerid?: string | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
  }

  export type OrderCreateOrConnectWithoutProductInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type WishListCreateWithoutProductInput = {
    id?: string
    User?: UserCreateNestedOneWithoutWishListInput
  }

  export type WishListUncheckedCreateWithoutProductInput = {
    id?: string
    userid?: string | null
  }

  export type WishListCreateOrConnectWithoutProductInput = {
    where: WishListWhereUniqueInput
    create: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput>
  }

  export type WishListCreateManyProductInputEnvelope = {
    data: WishListCreateManyProductInput | WishListCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductQueryCreateWithoutProductInput = {
    username?: string | null
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    User: UserCreateNestedOneWithoutProductQueryInput
  }

  export type ProductQueryUncheckedCreateWithoutProductInput = {
    id?: number
    username?: string | null
    userid: string
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
  }

  export type ProductQueryCreateOrConnectWithoutProductInput = {
    where: ProductQueryWhereUniqueInput
    create: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput>
  }

  export type ProductQueryCreateManyProductInputEnvelope = {
    data: ProductQueryCreateManyProductInput | ProductQueryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type SellerAccountUpsertWithoutProductInput = {
    update: XOR<SellerAccountUpdateWithoutProductInput, SellerAccountUncheckedUpdateWithoutProductInput>
    create: XOR<SellerAccountCreateWithoutProductInput, SellerAccountUncheckedCreateWithoutProductInput>
    where?: SellerAccountWhereInput
  }

  export type SellerAccountUpdateToOneWithWhereWithoutProductInput = {
    where?: SellerAccountWhereInput
    data: XOR<SellerAccountUpdateWithoutProductInput, SellerAccountUncheckedUpdateWithoutProductInput>
  }

  export type SellerAccountUpdateWithoutProductInput = {
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutSelleraccountNestedInput
    Order?: OrderUpdateManyWithoutSellerNestedInput
  }

  export type SellerAccountUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales?: NullableStringFieldUpdateOperationsInput | string | null
    Order?: OrderUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProductInput>
  }

  export type WishListUpsertWithWhereUniqueWithoutProductInput = {
    where: WishListWhereUniqueInput
    update: XOR<WishListUpdateWithoutProductInput, WishListUncheckedUpdateWithoutProductInput>
    create: XOR<WishListCreateWithoutProductInput, WishListUncheckedCreateWithoutProductInput>
  }

  export type WishListUpdateWithWhereUniqueWithoutProductInput = {
    where: WishListWhereUniqueInput
    data: XOR<WishListUpdateWithoutProductInput, WishListUncheckedUpdateWithoutProductInput>
  }

  export type WishListUpdateManyWithWhereWithoutProductInput = {
    where: WishListScalarWhereInput
    data: XOR<WishListUpdateManyMutationInput, WishListUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductQueryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductQueryWhereUniqueInput
    update: XOR<ProductQueryUpdateWithoutProductInput, ProductQueryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductQueryCreateWithoutProductInput, ProductQueryUncheckedCreateWithoutProductInput>
  }

  export type ProductQueryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductQueryWhereUniqueInput
    data: XOR<ProductQueryUpdateWithoutProductInput, ProductQueryUncheckedUpdateWithoutProductInput>
  }

  export type ProductQueryUpdateManyWithWhereWithoutProductInput = {
    where: ProductQueryScalarWhereInput
    data: XOR<ProductQueryUpdateManyMutationInput, ProductQueryUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutProductQueryInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductQueryInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductQueryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductQueryInput, UserUncheckedCreateWithoutProductQueryInput>
  }

  export type ProductsCreateWithoutQueriesInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewCreateNestedManyWithoutProductInput
    Seller: SellerAccountCreateNestedOneWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    WishList?: WishListCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutQueriesInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
    Review?: ReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
    WishList?: WishListUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutQueriesInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutQueriesInput, ProductsUncheckedCreateWithoutQueriesInput>
  }

  export type UserUpsertWithoutProductQueryInput = {
    update: XOR<UserUpdateWithoutProductQueryInput, UserUncheckedUpdateWithoutProductQueryInput>
    create: XOR<UserCreateWithoutProductQueryInput, UserUncheckedCreateWithoutProductQueryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductQueryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductQueryInput, UserUncheckedUpdateWithoutProductQueryInput>
  }

  export type UserUpdateWithoutProductQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithoutQueriesInput = {
    update: XOR<ProductsUpdateWithoutQueriesInput, ProductsUncheckedUpdateWithoutQueriesInput>
    create: XOR<ProductsCreateWithoutQueriesInput, ProductsUncheckedCreateWithoutQueriesInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutQueriesInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutQueriesInput, ProductsUncheckedUpdateWithoutQueriesInput>
  }

  export type ProductsUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUpdateManyWithoutProductNestedInput
    Seller?: SellerAccountUpdateOneRequiredWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    WishList?: WishListUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
    Review?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutWishListInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishListInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishListInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishListInput, UserUncheckedCreateWithoutWishListInput>
  }

  export type ProductsCreateWithoutWishListInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Review?: ReviewCreateNestedManyWithoutProductInput
    Seller: SellerAccountCreateNestedOneWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    Queries?: ProductQueryCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutWishListInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
    Review?: ReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
    Queries?: ProductQueryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutWishListInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutWishListInput, ProductsUncheckedCreateWithoutWishListInput>
  }

  export type UserUpsertWithoutWishListInput = {
    update: XOR<UserUpdateWithoutWishListInput, UserUncheckedUpdateWithoutWishListInput>
    create: XOR<UserCreateWithoutWishListInput, UserUncheckedCreateWithoutWishListInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishListInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishListInput, UserUncheckedUpdateWithoutWishListInput>
  }

  export type UserUpdateWithoutWishListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithoutWishListInput = {
    update: XOR<ProductsUpdateWithoutWishListInput, ProductsUncheckedUpdateWithoutWishListInput>
    create: XOR<ProductsCreateWithoutWishListInput, ProductsUncheckedCreateWithoutWishListInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutWishListInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutWishListInput, ProductsUncheckedUpdateWithoutWishListInput>
  }

  export type ProductsUpdateWithoutWishListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUpdateManyWithoutProductNestedInput
    Seller?: SellerAccountUpdateOneRequiredWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutWishListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
    Review?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutReviewInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedManyWithoutUserInput
    Listing?: ListingCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountCreateNestedOneWithoutUserInput
    Dealer?: DealersCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileCreateNestedOneWithoutUserInput
    WishList?: WishListCreateNestedManyWithoutUserInput
    Member?: MemberCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewInput = {
    id?: string
    name: string
    email: string
    googlemail?: string | null
    extra?: string | null
    contact?: bigint | number | null
    lastname?: string | null
    password?: string | null
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    team?: TeamUncheckedCreateNestedManyWithoutUserInput
    Listing?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    Selleraccount?: SellerAccountUncheckedCreateNestedOneWithoutUserInput
    Dealer?: DealersUncheckedCreateNestedManyWithoutUsersInput
    JobProfle?: JobProfileUncheckedCreateNestedOneWithoutUserInput
    WishList?: WishListUncheckedCreateNestedManyWithoutUserInput
    Member?: MemberUncheckedCreateNestedManyWithoutUserInput
    ProductQuery?: ProductQueryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
  }

  export type ProductsCreateWithoutReviewInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    Seller: SellerAccountCreateNestedOneWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    WishList?: WishListCreateNestedManyWithoutProductInput
    Queries?: ProductQueryCreateNestedManyWithoutProductInput
  }

  export type ProductsUncheckedCreateWithoutReviewInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
    sellerid: string
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
    WishList?: WishListUncheckedCreateNestedManyWithoutProductInput
    Queries?: ProductQueryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductsCreateOrConnectWithoutReviewInput = {
    where: ProductsWhereUniqueInput
    create: XOR<ProductsCreateWithoutReviewInput, ProductsUncheckedCreateWithoutReviewInput>
  }

  export type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUpdateManyWithoutUserNestedInput
    team?: TeamUpdateManyWithoutUserNestedInput
    Listing?: ListingUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUpdateOneWithoutUserNestedInput
    Dealer?: DealersUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUpdateOneWithoutUserNestedInput
    WishList?: WishListUpdateManyWithoutUserNestedInput
    Member?: MemberUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    googlemail?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    team?: TeamUncheckedUpdateManyWithoutUserNestedInput
    Listing?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    Selleraccount?: SellerAccountUncheckedUpdateOneWithoutUserNestedInput
    Dealer?: DealersUncheckedUpdateManyWithoutUsersNestedInput
    JobProfle?: JobProfileUncheckedUpdateOneWithoutUserNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutUserNestedInput
    Member?: MemberUncheckedUpdateManyWithoutUserNestedInput
    ProductQuery?: ProductQueryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductsUpsertWithoutReviewInput = {
    update: XOR<ProductsUpdateWithoutReviewInput, ProductsUncheckedUpdateWithoutReviewInput>
    create: XOR<ProductsCreateWithoutReviewInput, ProductsUncheckedCreateWithoutReviewInput>
    where?: ProductsWhereInput
  }

  export type ProductsUpdateToOneWithWhereWithoutReviewInput = {
    where?: ProductsWhereInput
    data: XOR<ProductsUpdateWithoutReviewInput, ProductsUncheckedUpdateWithoutReviewInput>
  }

  export type ProductsUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Seller?: SellerAccountUpdateOneRequiredWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    WishList?: WishListUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
    User: UserCreateNestedOneWithoutProjectsInput
    member?: MemberCreateNestedManyWithoutProjectInput
    Task?: TaskCreateNestedManyWithoutProjectInput
    finance?: FinanceCreateNestedOneWithoutFinanceInput
    ScheduledMsg?: ScheduleMsgCreateNestedManyWithoutProjectInput
    Inventory?: InventoryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    userid: string
    coverimgUrl?: string | null
    budget?: number | null
    member?: MemberUncheckedCreateNestedManyWithoutProjectInput
    Task?: TaskUncheckedCreateNestedManyWithoutProjectInput
    finance?: FinanceUncheckedCreateNestedOneWithoutFinanceInput
    ScheduledMsg?: ScheduleMsgUncheckedCreateNestedManyWithoutProjectInput
    Inventory?: InventoryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutProjectsNestedInput
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userid?: StringFieldUpdateOperationsInput | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyUserInput = {
    id?: string
    name: string
    description: string
    category: $Enums.Category
    createdAt?: Date | string
    coverimgUrl?: string | null
    budget?: number | null
  }

  export type TeamCreateManyUserInput = {
    id?: number
    email: string
    name: string
    verified: boolean
    phonenum: number
    createdat?: Date | string
  }

  export type ListingCreateManyOwnerInput = {
    id?: string
    image: string
    rating: number
    address: string
    soldout: boolean
    description?: string | null
  }

  export type DealersCreateManyUsersInput = {
    id?: string
    idd?: string | null
    name?: string | null
    dealeremail?: string | null
    email?: string | null
    phonenum?: string | null
    verified?: boolean | null
    address?: string | null
    category?: string | null
    transactionWorth?: number | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    rating?: number | null
    review?: string | null
    username?: string | null
    productId?: string | null
  }

  export type WishListCreateManyUserInput = {
    id?: string
    productid?: string | null
  }

  export type MemberCreateManyUserInput = {
    id?: string
    userid?: string | null
    projectId: string
    name?: string | null
  }

  export type ProductQueryCreateManyUserInput = {
    id?: number
    username?: string | null
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
    productId?: string | null
  }

  export type ProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUpdateManyWithoutProjectNestedInput
    Task?: TaskUpdateManyWithoutProjectNestedInput
    finance?: FinanceUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    member?: MemberUncheckedUpdateManyWithoutProjectNestedInput
    Task?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    finance?: FinanceUncheckedUpdateOneWithoutFinanceNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    ScheduledMsg?: ScheduleMsgUncheckedUpdateManyWithoutProjectNestedInput
    Inventory?: InventoryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coverimgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    phonenum?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListingUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListingUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    soldout?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    idd?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dealeremail?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    transactionWorth?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductsUpdateOneWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    Product?: ProductsUpdateOneWithoutWishListNestedInput
  }

  export type WishListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    Project?: ProjectUpdateOneRequiredWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductQueryUpdateWithoutUserInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    Product?: ProductsUpdateOneWithoutQueriesNestedInput
  }

  export type ProductQueryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductQueryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductsUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUpdateManyWithoutProductNestedInput
    Seller?: SellerAccountUpdateOneRequiredWithoutProductNestedInput
    WishList?: WishListUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
    Review?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    sellerid?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyProjectInput = {
    id?: string
    userid?: string | null
    name?: string | null
    useremail: string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    task: string
    team?: TaskCreateteamInput | string[]
    amount?: number | null
    startdate: string
    deadline: string
    description: string
    supplier?: TaskCreatesupplierInput | string[]
    subtasks?: TaskCreatesubtasksInput | string[]
    inventories?: TaskCreateinventoriesInput | string[]
    teamlead?: string | null
    priority?: string | null
    status?: boolean | null
    createdAt?: Date | string
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    userId?: string | null
    originalName?: string | null
    title: string
    storageUrl?: string | null
    uploadDate?: Date | string
    isEncrypted?: boolean
    notes?: string | null
  }

  export type ScheduleMsgCreateManyProjectInput = {
    id?: string
    email?: string | null
    phonenum?: string | null
    Datetime?: string | null
    type?: $Enums.Msgtype | null
    text?: string | null
    status?: $Enums.ScheduleMsgStatus | null
    createdAt?: Date | string
  }

  export type InventoryCreateManyProjectInput = {
    id?: string
    available?: boolean | null
    name: string
    description?: string | null
    createdAt?: Date | string
    value: bigint | number
    stock?: string | null
    valueperpeice?: string | null
  }

  export type MemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    useremail?: StringFieldUpdateOperationsInput | string
  }

  export type MemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    useremail?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    task?: StringFieldUpdateOperationsInput | string
    team?: TaskUpdateteamInput | string[]
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    startdate?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    supplier?: TaskUpdatesupplierInput | string[]
    subtasks?: TaskUpdatesubtasksInput | string[]
    inventories?: TaskUpdateinventoriesInput | string[]
    teamlead?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    storageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleMsgUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleMsgUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleMsgUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phonenum?: NullableStringFieldUpdateOperationsInput | string | null
    Datetime?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumMsgtypeFieldUpdateOperationsInput | $Enums.Msgtype | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumScheduleMsgStatusFieldUpdateOperationsInput | $Enums.ScheduleMsgStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    valueperpeice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateManyFinanceInput = {
    id?: string
    amount: number
    gstrate?: number | null
    dealer: string
    status?: $Enums.Status | null
    proof?: string | null
    type: $Enums.Typetrans
    createdAt?: Date | string
  }

  export type NoteCreateManyFinanceInput = {
    id?: string
    title?: string | null
    content: string
    createdAt?: Date | string
    type?: $Enums.NoteType | null
  }

  export type RemaindersCreateManyFinanceInput = {
    id?: string
    amount: number
    dealer: string
    date?: Date | string
  }

  export type TransactionUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    gstrate?: NullableIntFieldUpdateOperationsInput | number | null
    dealer?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    proof?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypetransFieldUpdateOperationsInput | $Enums.Typetrans
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type NoteUncheckedUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type NoteUncheckedUpdateManyWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableEnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType | null
  }

  export type RemaindersUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemaindersUncheckedUpdateWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemaindersUncheckedUpdateManyWithoutFinanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dealer?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductsCreateManySellerInput = {
    id?: string
    name: string
    price?: string | null
    description?: string | null
    rating?: string | null
    imageurl?: string | null
    quantity?: string | null
    sellerName: string
    expirydate?: string | null
    category: $Enums.Categories
    specialmsg?: string | null
    stock?: string | null
    contact?: string | null
    questions?: ProductsCreatequestionsInput | string[]
    mode?: $Enums.Mode | null
    type: $Enums.Type
    offers?: string | null
  }

  export type OrderCreateManySellerInput = {
    id?: string
    orderStatus?: $Enums.OrderStatus | null
    buyerName: string
    buyerEmail: string
    buyerContact?: string | null
    buyerId?: string | null
    orders?: string | null
  }

  export type ProductsUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    WishList?: WishListUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
    Review?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
    WishList?: WishListUncheckedUpdateManyWithoutProductNestedInput
    Queries?: ProductQueryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductsUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableStringFieldUpdateOperationsInput | string | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: StringFieldUpdateOperationsInput | string
    expirydate?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCategoriesFieldUpdateOperationsInput | $Enums.Categories
    specialmsg?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: ProductsUpdatequestionsInput | string[]
    mode?: NullableEnumModeFieldUpdateOperationsInput | $Enums.Mode | null
    type?: EnumTypeFieldUpdateOperationsInput | $Enums.Type
    offers?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductsUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    rating?: number | null
    review?: string | null
    userid?: string | null
    username?: string | null
  }

  export type WishListCreateManyProductInput = {
    id?: string
    userid?: string | null
  }

  export type ProductQueryCreateManyProductInput = {
    id?: number
    username?: string | null
    userid: string
    name?: string | null
    contact?: string | null
    additionalQueies?: string | null
    question?: ProductQueryCreatequestionInput | string[]
    answers?: ProductQueryCreateanswersInput | string[]
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: SellerAccountUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    sellerid?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    sellerid?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: StringFieldUpdateOperationsInput | string
    buyerEmail?: StringFieldUpdateOperationsInput | string
    buyerContact?: NullableStringFieldUpdateOperationsInput | string | null
    buyerId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutWishListNestedInput
  }

  export type WishListUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WishListUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductQueryUpdateWithoutProductInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
    User?: UserUpdateOneRequiredWithoutProductQueryNestedInput
  }

  export type ProductQueryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
  }

  export type ProductQueryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    userid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    additionalQueies?: NullableStringFieldUpdateOperationsInput | string | null
    question?: ProductQueryUpdatequestionInput | string[]
    answers?: ProductQueryUpdateanswersInput | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}